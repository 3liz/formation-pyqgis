{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Formation PyQGIS # Pr\u00e9-requis # Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent apprendre l'API Python de QGIS : Ajout de fonctionnalit\u00e9s \u00e0 QGIS Automatisation de certains traitements Cr\u00e9ation de script Cr\u00e9ation d'algorithme Processing Pour suivre la formation, il faut : Avoir QGIS LTR minimum Avoir des connaissances en QGIS bureautique Avoir des bases en programmation Avoir un jeu de donn\u00e9es, par exemple : Donn\u00e9es OSM \u00e0 l'aide du plugin QuickOSM Donn\u00e9es OSM2Igeo (utilisation de ce jeu de donn\u00e9es ci-apr\u00e8s dans la formation)","title":"Formation PyQGIS"},{"location":"#formation-pyqgis","text":"","title":"Formation PyQGIS"},{"location":"#pre-requis","text":"Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent apprendre l'API Python de QGIS : Ajout de fonctionnalit\u00e9s \u00e0 QGIS Automatisation de certains traitements Cr\u00e9ation de script Cr\u00e9ation d'algorithme Processing Pour suivre la formation, il faut : Avoir QGIS LTR minimum Avoir des connaissances en QGIS bureautique Avoir des bases en programmation Avoir un jeu de donn\u00e9es, par exemple : Donn\u00e9es OSM \u00e0 l'aide du plugin QuickOSM Donn\u00e9es OSM2Igeo (utilisation de ce jeu de donn\u00e9es ci-apr\u00e8s dans la formation)","title":"Pr\u00e9-requis"},{"location":"40_proprietes_vecteurs/","text":"Symbologie # Formulaire #","title":"Symbologie"},{"location":"40_proprietes_vecteurs/#symbologie","text":"","title":"Symbologie"},{"location":"40_proprietes_vecteurs/#formulaire","text":"","title":"Formulaire"},{"location":"90_deploiement_extension/","text":"Comment d\u00e9ployer son extension #","title":"Comment d\u00e9ployer son extension"},{"location":"90_deploiement_extension/#comment-deployer-son-extension","text":"","title":"Comment d\u00e9ployer son extension"},{"location":"95_standalone/","text":"QGIS Process # Standalone application #","title":"QGIS Process"},{"location":"95_standalone/#qgis-process","text":"","title":"QGIS Process"},{"location":"95_standalone/#standalone-application","text":"","title":"Standalone application"},{"location":"action/","text":"Les actions # Pour conna\u00eetre le principe des actions dans QGIS, il faut se r\u00e9f\u00e9rer au manuel de QGIS : https://docs.qgis.org/3.16/fr/docs/user_manual/working_with_vector/vector_properties.html#actions-properties On souhaite pouvoir faire notre propre action pour inverser le sens d'une ligne, par exemple une rivi\u00e8re. Ajouter la couche D_OSM_HYDROGRAPHIE/CANALISATION_EAU.shp , mais utilisons le script ci-dessous pour commencer sur un cas simple. Faire un style rapide pour mettre en \u00e9vidence le sens de la ligne \u00e0 l'aide d'une Ligne de symbole dans l'onglet Symbologie . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Notation pour ajouter des attributs en cr\u00e9ant une couche m\u00e9moire river = QgsVectorLayer ( 'MultiLineString?crs=epsg:2154&field=id:integer&field=name:string(20)&index=yes' , 'Rivers' , 'memory' ) QgsProject . instance () . addMapLayer ( river ) with edit ( river ): feature = QgsVectorLayerUtils . createFeature ( river ) feature . setAttribute ( 'id' , 0 ) feature . setAttribute ( 'name' , 'Une rivi\u00e8re' ) geom = QgsGeometry . fromMultiPolylineXY ( [ [ QgsPointXY ( 1 , 1 ), QgsPointXY ( 2 , 2 ), QgsPointXY ( 3 , 2 ), QgsPointXY ( 4 , 1 )] ]) feature . setGeometry ( geom ) river . addFeature ( feature ) extent = river . extent () canvas = iface . mapCanvas () canvas . setExtent ( extent ) canvas . refresh () Les actions par d\u00e9faut # Dans la fen\u00eatre des propri\u00e9t\u00e9s d'une couche vecteur, aller dans l'onglet Actions . Cliquer sur le bouton Cr\u00e9er les actions par d\u00e9faut . Observons quelques actions pour comprendre le fonctionnement. Notre propre action # Commen\u00e7ons un nouveau par un script Python classique, laissons de c\u00f4t\u00e9 les actions pour le moment. \u00c9crire une fonction qui se charge d'inverser une ligne. Cette fonction prend en param\u00e8tre la couche vecteur et une liste d'ID des entit\u00e9s. Il faut penser \u00e0 v\u00e9rifier le type exact de g\u00e9om\u00e9trie de nos lignes, dans les propri\u00e9t\u00e9s de la couche. 1 2 3 4 5 6 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" pass Le mot-cl\u00e9 pass est juste une instruction Python qui ne fait strictement rien mais qui permet de rendre une ligne de code valide en respectant l'indentation. Vous pouvez la supprimer d\u00e8s qu'il y a du code. Il faut : Utiliser une session d'\u00e9dition R\u00e9cup\u00e9rer la g\u00e9om\u00e9trie, tenir compte qu'il s'agit d'une multi-ligne Appliquer la fonction reverse en Python Utiliser QgsVectorLayer.changeGeometry() pour changer la g\u00e9om\u00e9trie d'un objet Solution : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = iface . activeLayer () ids = layer . selectedFeatureIds () reverse_geom ( layer , ids ) Incorporons ce code dans une action et adaptons le un peu : 1 2 3 4 5 6 7 8 9 10 11 12 def reverse_geom ( layer , ids ): with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = QgsProject . instance () . mapLayer ( '[% @layer_id %]' ) reverse_geom ( layer , '[% $id %]' ) On peut d\u00e9sormais cliquer sur une ligne pour automatiquement inverser une ligne. Le code de l'action est enregistr\u00e9 dans le style QML de la couche vecteur. Il peut donc \u00eatre partag\u00e9 avec d'autres utilisateurs qui ne connaissent pas Python","title":"Action"},{"location":"action/#les-actions","text":"Pour conna\u00eetre le principe des actions dans QGIS, il faut se r\u00e9f\u00e9rer au manuel de QGIS : https://docs.qgis.org/3.16/fr/docs/user_manual/working_with_vector/vector_properties.html#actions-properties On souhaite pouvoir faire notre propre action pour inverser le sens d'une ligne, par exemple une rivi\u00e8re. Ajouter la couche D_OSM_HYDROGRAPHIE/CANALISATION_EAU.shp , mais utilisons le script ci-dessous pour commencer sur un cas simple. Faire un style rapide pour mettre en \u00e9vidence le sens de la ligne \u00e0 l'aide d'une Ligne de symbole dans l'onglet Symbologie . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Notation pour ajouter des attributs en cr\u00e9ant une couche m\u00e9moire river = QgsVectorLayer ( 'MultiLineString?crs=epsg:2154&field=id:integer&field=name:string(20)&index=yes' , 'Rivers' , 'memory' ) QgsProject . instance () . addMapLayer ( river ) with edit ( river ): feature = QgsVectorLayerUtils . createFeature ( river ) feature . setAttribute ( 'id' , 0 ) feature . setAttribute ( 'name' , 'Une rivi\u00e8re' ) geom = QgsGeometry . fromMultiPolylineXY ( [ [ QgsPointXY ( 1 , 1 ), QgsPointXY ( 2 , 2 ), QgsPointXY ( 3 , 2 ), QgsPointXY ( 4 , 1 )] ]) feature . setGeometry ( geom ) river . addFeature ( feature ) extent = river . extent () canvas = iface . mapCanvas () canvas . setExtent ( extent ) canvas . refresh ()","title":"Les actions"},{"location":"action/#les-actions-par-defaut","text":"Dans la fen\u00eatre des propri\u00e9t\u00e9s d'une couche vecteur, aller dans l'onglet Actions . Cliquer sur le bouton Cr\u00e9er les actions par d\u00e9faut . Observons quelques actions pour comprendre le fonctionnement.","title":"Les actions par d\u00e9faut"},{"location":"action/#notre-propre-action","text":"Commen\u00e7ons un nouveau par un script Python classique, laissons de c\u00f4t\u00e9 les actions pour le moment. \u00c9crire une fonction qui se charge d'inverser une ligne. Cette fonction prend en param\u00e8tre la couche vecteur et une liste d'ID des entit\u00e9s. Il faut penser \u00e0 v\u00e9rifier le type exact de g\u00e9om\u00e9trie de nos lignes, dans les propri\u00e9t\u00e9s de la couche. 1 2 3 4 5 6 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" pass Le mot-cl\u00e9 pass est juste une instruction Python qui ne fait strictement rien mais qui permet de rendre une ligne de code valide en respectant l'indentation. Vous pouvez la supprimer d\u00e8s qu'il y a du code. Il faut : Utiliser une session d'\u00e9dition R\u00e9cup\u00e9rer la g\u00e9om\u00e9trie, tenir compte qu'il s'agit d'une multi-ligne Appliquer la fonction reverse en Python Utiliser QgsVectorLayer.changeGeometry() pour changer la g\u00e9om\u00e9trie d'un objet Solution : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = iface . activeLayer () ids = layer . selectedFeatureIds () reverse_geom ( layer , ids ) Incorporons ce code dans une action et adaptons le un peu : 1 2 3 4 5 6 7 8 9 10 11 12 def reverse_geom ( layer , ids ): with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = QgsProject . instance () . mapLayer ( '[% @layer_id %]' ) reverse_geom ( layer , '[% $id %]' ) On peut d\u00e9sormais cliquer sur une ligne pour automatiquement inverser une ligne. Le code de l'action est enregistr\u00e9 dans le style QML de la couche vecteur. Il peut donc \u00eatre partag\u00e9 avec d'autres utilisateurs qui ne connaissent pas Python","title":"Notre propre action"},{"location":"console/","text":"Introduction \u00e0 la console Python dans QGIS # La documentation et les liens utiles : # QGIS est compos\u00e9 de plusieurs centaines de classes \u00e9crites en C++. La plupart de ces classes (et donc des fonctions) sont accessibles \u00e0 travers un API en Python. Comme il n'est pas possible de m\u00e9moriser enti\u00e8rement l'API de QGIS, il est n\u00e9cessaire de conna\u00eetre la documentation et comment rechercher des informations. QGIS repose sur la librairie Qt version 5 pour l'interface graphique et sur Python version 3. Toutes les classes QGIS commencent par Qgs et toutes les classes Qt commencent par Q . Voici une liste de liens pour la documentation : https://docs.qgis.org qui regroupe : Le Python Cookbook https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook (recette de cuisine) L'API C++ https://qgis.org/api/3.16/ L'API Python https://qgis.org/pyqgis/3.16/ Voici une liste non exhaustive de blog-post utiles pour manipuler PyQGIS : Optimisation des couches vecteurs Parcourir la l\u00e9gende en 3 parties Plugin Processing Workshop sur les expressions en Python Autre lien pour l'apprentissage de Python (sans QGIS) : https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python Configurer le projet # Commencer un nouveau projet et enregistrer le. \u00c0 c\u00f4t\u00e9 du projet, ajouter le dossier provenant d\u2019OSM2Igeo, par exemple 201909_11_ILE_DE_FRANCE_SHP_L93_2154 . Manipulation dans la console # Dans QGIS, Plugins -> Console Python QGIS nous donne acc\u00e8s au projet actuel via la classe QgsProject https://qgis.org/api/classQgsProject.html https://qgis.org/pyqgis/3.16/core/QgsProject.html Dans la documentation (en C++ surtout), on remarque plusieurs sections : Public types Public slots Signals Public Member Functions Static Public Member Functions Nous verrons progressivement ces diff\u00e9rentes sections. Recherchons filename . 1 QgsProject . instance () . fileName () Ajoutons un titre \u00e0 notre projet, recherchons donc title dans la page : setTitle . Objectif, ajouter une couche vecteur contenu dans un dossier fils : Recherchons dans l'API le dossier racine du projet. Indice , en informatique, on appelle souvent cela le home . Nous allons utiliser le module os.path pour manipuler les dossiers. https://docs.python.org/3/library/os.path.html join , isfile , isdir 1 2 3 4 5 6 7 8 9 10 11 12 from os.path import join , isfile , isdir racine = QgsProject . instance () . homePath () join ( racine , 'nexistepas' ) '/home/etienne/Documents/3liz/formation/nexistepas' isfile ( join ( racine , 'nexistepas' )) False isdir ( join ( racine , 'nexistepas' )) False chemin = join ( racine , '201909_11_ILE_DE_FRANCE_SHP_L93_2154' , 'H_OSM_ADMINISTRATIF' ) fichier_shape = join ( chemin , 'COMMUNE.shp' ) isfile ( fichier_shape ) True Charger la couche vecteur \u00e0 l'aide de iface QgisInterface (et non pas Qgs Interface !) 1 2 communes = iface . addVectorLayer ( fichier_shape , 'communes' , 'ogr' ) print ( communes ) Charger la couche autrement (conseill\u00e9) 1 2 3 communes = QgsVectorLayer ( fichier_shape , 'communes' , 'ogr' ) communes . isValid () QgsProject . instance () . addMapLayer ( communes ) Explorer l'objet communes qui est un QgsVectorLayer \u00e0 l'aide de la documentation pour chercher sa g\u00e9om\u00e9trie, le nombre d'entit\u00e9s. Pour la g\u00e9om\u00e9trie, toujours utiliser l'\u00e9num\u00e9ration et non pas le chiffre (explication dans l'exemple ci-dessous) Essayer d'ouvrir et de clore une session d'\u00e9dition Essayer d\u00e9sormais de chercher son nom, la projection ou encore les seuils de visibilit\u00e9 de la couche. On ne les trouve pas dans la page QgsVectorLayer ! Pour cela, il faut faire r\u00e9f\u00e9rence \u00e0 la notion d'h\u00e9ritage en Programmation Orient\u00e9e Objet. L'objet QgsVectorLayer h\u00e9rite de QgsMapLayer qui est une classe commune avec QgsMapLayer . Objectif, ne pas afficher la couche commune pour une \u00e9chelle plus petite que le 1:2 000 000 . Code # Petit r\u00e9capitulatif \u00e0 tester pour voir si cela fonctionne correctement ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) result = QgsProject . instance () . addMapLayer ( layer ) print ( layer . featureCount ()) print ( layer . crs () . authid ()) print ( 'Est en m\u00e8tre : {} ' . format ( layer . crs () . mapUnits () == QgsUnitTypes . DistanceMeters )) print ( layer . name ()) layer . setScaleBasedVisibility ( True ) layer . setMaximumScale ( 1 ) layer . setMinimumScale ( 2000000 ) layer . triggerRepaint () Ajouter \u00e9galement la couche ARRONDISSEMENT et s\u00e9lectionner la. Parcourir les entit\u00e9s # Un raccourci a savoir, dans la console : 1 iface . activeLayer () Cela retourne la couche QgsMapLayer active dans la l\u00e9gende ! On souhaite d\u00e9sormais it\u00e9rer sur les polygones et les faire clignoter depuis la console. Nous allons donc avoir besoin de getFeatures . 1 2 3 4 5 6 layer = iface . activeLayer () features = layer . getFeatures () features feature = QgsFeature () features . nextFeature ( feature ) iface . mapCanvas () . flashFeatureIds ( layer , [ feature . id ()]) Note , nous pouvons concat\u00e9ner les deux derni\u00e8res lignes \u00e0 l'aide du caract\u00e8re ; pour que cela soit plus pratique. On souhaite d\u00e9sormais afficher le nom des arrondissements \u00e0 l'aide d'une boucle for . 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): # On peut traiter l'entit\u00e9 courante. pass Noter l'apparition de ... au lieu de >>> apr\u00e8s avoir \u00e9crit la premi\u00e8re ligne du for . Il faut faire une indentation obligatoire !","title":"Console"},{"location":"console/#introduction-a-la-console-python-dans-qgis","text":"","title":"Introduction \u00e0 la console Python dans QGIS"},{"location":"console/#la-documentation-et-les-liens-utiles","text":"QGIS est compos\u00e9 de plusieurs centaines de classes \u00e9crites en C++. La plupart de ces classes (et donc des fonctions) sont accessibles \u00e0 travers un API en Python. Comme il n'est pas possible de m\u00e9moriser enti\u00e8rement l'API de QGIS, il est n\u00e9cessaire de conna\u00eetre la documentation et comment rechercher des informations. QGIS repose sur la librairie Qt version 5 pour l'interface graphique et sur Python version 3. Toutes les classes QGIS commencent par Qgs et toutes les classes Qt commencent par Q . Voici une liste de liens pour la documentation : https://docs.qgis.org qui regroupe : Le Python Cookbook https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook (recette de cuisine) L'API C++ https://qgis.org/api/3.16/ L'API Python https://qgis.org/pyqgis/3.16/ Voici une liste non exhaustive de blog-post utiles pour manipuler PyQGIS : Optimisation des couches vecteurs Parcourir la l\u00e9gende en 3 parties Plugin Processing Workshop sur les expressions en Python Autre lien pour l'apprentissage de Python (sans QGIS) : https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python","title":"La documentation et les liens utiles :"},{"location":"console/#configurer-le-projet","text":"Commencer un nouveau projet et enregistrer le. \u00c0 c\u00f4t\u00e9 du projet, ajouter le dossier provenant d\u2019OSM2Igeo, par exemple 201909_11_ILE_DE_FRANCE_SHP_L93_2154 .","title":"Configurer le projet"},{"location":"console/#manipulation-dans-la-console","text":"Dans QGIS, Plugins -> Console Python QGIS nous donne acc\u00e8s au projet actuel via la classe QgsProject https://qgis.org/api/classQgsProject.html https://qgis.org/pyqgis/3.16/core/QgsProject.html Dans la documentation (en C++ surtout), on remarque plusieurs sections : Public types Public slots Signals Public Member Functions Static Public Member Functions Nous verrons progressivement ces diff\u00e9rentes sections. Recherchons filename . 1 QgsProject . instance () . fileName () Ajoutons un titre \u00e0 notre projet, recherchons donc title dans la page : setTitle . Objectif, ajouter une couche vecteur contenu dans un dossier fils : Recherchons dans l'API le dossier racine du projet. Indice , en informatique, on appelle souvent cela le home . Nous allons utiliser le module os.path pour manipuler les dossiers. https://docs.python.org/3/library/os.path.html join , isfile , isdir 1 2 3 4 5 6 7 8 9 10 11 12 from os.path import join , isfile , isdir racine = QgsProject . instance () . homePath () join ( racine , 'nexistepas' ) '/home/etienne/Documents/3liz/formation/nexistepas' isfile ( join ( racine , 'nexistepas' )) False isdir ( join ( racine , 'nexistepas' )) False chemin = join ( racine , '201909_11_ILE_DE_FRANCE_SHP_L93_2154' , 'H_OSM_ADMINISTRATIF' ) fichier_shape = join ( chemin , 'COMMUNE.shp' ) isfile ( fichier_shape ) True Charger la couche vecteur \u00e0 l'aide de iface QgisInterface (et non pas Qgs Interface !) 1 2 communes = iface . addVectorLayer ( fichier_shape , 'communes' , 'ogr' ) print ( communes ) Charger la couche autrement (conseill\u00e9) 1 2 3 communes = QgsVectorLayer ( fichier_shape , 'communes' , 'ogr' ) communes . isValid () QgsProject . instance () . addMapLayer ( communes ) Explorer l'objet communes qui est un QgsVectorLayer \u00e0 l'aide de la documentation pour chercher sa g\u00e9om\u00e9trie, le nombre d'entit\u00e9s. Pour la g\u00e9om\u00e9trie, toujours utiliser l'\u00e9num\u00e9ration et non pas le chiffre (explication dans l'exemple ci-dessous) Essayer d'ouvrir et de clore une session d'\u00e9dition Essayer d\u00e9sormais de chercher son nom, la projection ou encore les seuils de visibilit\u00e9 de la couche. On ne les trouve pas dans la page QgsVectorLayer ! Pour cela, il faut faire r\u00e9f\u00e9rence \u00e0 la notion d'h\u00e9ritage en Programmation Orient\u00e9e Objet. L'objet QgsVectorLayer h\u00e9rite de QgsMapLayer qui est une classe commune avec QgsMapLayer . Objectif, ne pas afficher la couche commune pour une \u00e9chelle plus petite que le 1:2 000 000 .","title":"Manipulation dans la console"},{"location":"console/#code","text":"Petit r\u00e9capitulatif \u00e0 tester pour voir si cela fonctionne correctement ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) result = QgsProject . instance () . addMapLayer ( layer ) print ( layer . featureCount ()) print ( layer . crs () . authid ()) print ( 'Est en m\u00e8tre : {} ' . format ( layer . crs () . mapUnits () == QgsUnitTypes . DistanceMeters )) print ( layer . name ()) layer . setScaleBasedVisibility ( True ) layer . setMaximumScale ( 1 ) layer . setMinimumScale ( 2000000 ) layer . triggerRepaint () Ajouter \u00e9galement la couche ARRONDISSEMENT et s\u00e9lectionner la.","title":"Code"},{"location":"console/#parcourir-les-entites","text":"Un raccourci a savoir, dans la console : 1 iface . activeLayer () Cela retourne la couche QgsMapLayer active dans la l\u00e9gende ! On souhaite d\u00e9sormais it\u00e9rer sur les polygones et les faire clignoter depuis la console. Nous allons donc avoir besoin de getFeatures . 1 2 3 4 5 6 layer = iface . activeLayer () features = layer . getFeatures () features feature = QgsFeature () features . nextFeature ( feature ) iface . mapCanvas () . flashFeatureIds ( layer , [ feature . id ()]) Note , nous pouvons concat\u00e9ner les deux derni\u00e8res lignes \u00e0 l'aide du caract\u00e8re ; pour que cela soit plus pratique. On souhaite d\u00e9sormais afficher le nom des arrondissements \u00e0 l'aide d'une boucle for . 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): # On peut traiter l'entit\u00e9 courante. pass Noter l'apparition de ... au lieu de >>> apr\u00e8s avoir \u00e9crit la premi\u00e8re ligne du for . Il faut faire une indentation obligatoire !","title":"Parcourir les entit\u00e9s"},{"location":"extension-generique/","text":"La base pour cr\u00e9er une extension # Pour cr\u00e9er une extension dans QGIS, il existe deux fa\u00e7ons de d\u00e9marrer : Utilisation de l'extension \"Plugin Builder\" : Disponible depuis le gestionnaire des extensions de QGIS Assistant de cr\u00e9ation Tr\u00e8s (trop) complet, il y a squelette pour : Du code avec des actions, ... G\u00e9n\u00e9rer de la documentation Sphinx Des tests unitaires Les traductions (multilingue) Tr\u00e8s historique, moins mis \u00e0 jour ces derni\u00e8res ann\u00e9es QGIS Minimal plugin : https://github.com/wonder-sk/qgis-minimal-plugin ZIP \u00e0 t\u00e9l\u00e9charger et \u00e0 extraire Tr\u00e8s l\u00e9ger Besoin de tout refaire depuis z\u00e9ro Nous pouvons suivre une des deux m\u00e9thodes, mais dans le cadre de la formation, faisons la m\u00e9thode minimale. Dans les deux cas, le r\u00e9sultat doit \u00eatre dans le dossier python/plugins du profil courant. Pour trouver le profil courant, dans QGIS, Profils Utilisateurs -> Ouvrir le dossier du profil actif . Plugin reloader # Le \"Plugin Reloader\" est une extension indispensable pour d\u00e9velopper une extension pour recharger son extension. Elle est disponible dans le gestionnaire des extensions.","title":"Extension G\u00e9n\u00e9rique"},{"location":"extension-generique/#la-base-pour-creer-une-extension","text":"Pour cr\u00e9er une extension dans QGIS, il existe deux fa\u00e7ons de d\u00e9marrer : Utilisation de l'extension \"Plugin Builder\" : Disponible depuis le gestionnaire des extensions de QGIS Assistant de cr\u00e9ation Tr\u00e8s (trop) complet, il y a squelette pour : Du code avec des actions, ... G\u00e9n\u00e9rer de la documentation Sphinx Des tests unitaires Les traductions (multilingue) Tr\u00e8s historique, moins mis \u00e0 jour ces derni\u00e8res ann\u00e9es QGIS Minimal plugin : https://github.com/wonder-sk/qgis-minimal-plugin ZIP \u00e0 t\u00e9l\u00e9charger et \u00e0 extraire Tr\u00e8s l\u00e9ger Besoin de tout refaire depuis z\u00e9ro Nous pouvons suivre une des deux m\u00e9thodes, mais dans le cadre de la formation, faisons la m\u00e9thode minimale. Dans les deux cas, le r\u00e9sultat doit \u00eatre dans le dossier python/plugins du profil courant. Pour trouver le profil courant, dans QGIS, Profils Utilisateurs -> Ouvrir le dossier du profil actif .","title":"La base pour cr\u00e9er une extension"},{"location":"extension-generique/#plugin-reloader","text":"Le \"Plugin Reloader\" est une extension indispensable pour d\u00e9velopper une extension pour recharger son extension. Elle est disponible dans le gestionnaire des extensions.","title":"Plugin reloader"},{"location":"extension-graphique/","text":"Cr\u00e9er une extension QGIS avec une interface graphique # Pour faire ce chapitre, il faut d'abord avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent. QtDesigner # Cr\u00e9ons un fichier QtDesigner comme-ceci : et y ajouter des \"widgets\" : Ouvrir la page des slots/signaux depuis la barre d'outils et supprimer ceux qui existent. La classe qui accompagne # Cr\u00e9ons un fichier dialog.py avec le contenu suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self ): super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner Modifions la m\u00e9thode la m\u00e9thode run du fichier __init__.py en 1 2 3 4 def run ( self ): from .dialog import MonDialog dialog = MonDialog () dialog . exec_ () Relan\u00e7ons l'extension \u00e0 l'aide du \"plugin reloader\" et cliquons sur le bouton. Les signaux et les slots # Connectons le signal clicked du bouton \"Annuler\" dans le constructeur __init__ : 1 self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) On dit que clicked est un signal , auquel on connecte le slot close . Connectons-le signal clicked du bouton \"Accepter\" \u00e0 notre propre slot (qui est une fonction) : 1 self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) et ajoutons notre propre fonction click_ok pour quitter la fen\u00eatre et en affichant la saisie de l'utilisateur dans la QgsMessageBar de QGIS. Le widget de saisie est un QLineEdit : https://doc.qt.io/qt-5/qlineedit.html 1 2 3 def click_ok ( self ): message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) Faire le test dans QGIS avec une saisie de l'utilisateur et fermer la fen\u00eatre. Continuons en rendant en lecture seule le gros bloc de texte et affichons \u00e0 l'int\u00e9rieur la description de la la couche qui est s\u00e9lectionn\u00e9e dans le menu d\u00e9roulant. Documentation : QPlainTextEdit : https://doc.qt.io/qt-5/qplaintextedit.html QgsMapLayerComboBox : https://qgis.org/api/classQgsMapLayerComboBox.html Dans le __init__ : 1 2 self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) Et la nouvelle fonction qui va se charger de mettre \u00e0 jour le texte : 1 2 3 4 5 6 7 def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" ) On peut donc d\u00e9sormais cumuler l'ensemble des chapitres pr\u00e9c\u00e9dents pour lancer des algorithmes, manipuler les donn\u00e9es etc. Solution # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self , parent = None ): _ = parent super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner # Connectons les signaux self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) def click_ok ( self ): self . close () message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" )","title":"Extension Graphique"},{"location":"extension-graphique/#creer-une-extension-qgis-avec-une-interface-graphique","text":"Pour faire ce chapitre, il faut d'abord avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent.","title":"Cr\u00e9er une extension QGIS avec une interface graphique"},{"location":"extension-graphique/#qtdesigner","text":"Cr\u00e9ons un fichier QtDesigner comme-ceci : et y ajouter des \"widgets\" : Ouvrir la page des slots/signaux depuis la barre d'outils et supprimer ceux qui existent.","title":"QtDesigner"},{"location":"extension-graphique/#la-classe-qui-accompagne","text":"Cr\u00e9ons un fichier dialog.py avec le contenu suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self ): super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner Modifions la m\u00e9thode la m\u00e9thode run du fichier __init__.py en 1 2 3 4 def run ( self ): from .dialog import MonDialog dialog = MonDialog () dialog . exec_ () Relan\u00e7ons l'extension \u00e0 l'aide du \"plugin reloader\" et cliquons sur le bouton.","title":"La classe qui accompagne"},{"location":"extension-graphique/#les-signaux-et-les-slots","text":"Connectons le signal clicked du bouton \"Annuler\" dans le constructeur __init__ : 1 self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) On dit que clicked est un signal , auquel on connecte le slot close . Connectons-le signal clicked du bouton \"Accepter\" \u00e0 notre propre slot (qui est une fonction) : 1 self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) et ajoutons notre propre fonction click_ok pour quitter la fen\u00eatre et en affichant la saisie de l'utilisateur dans la QgsMessageBar de QGIS. Le widget de saisie est un QLineEdit : https://doc.qt.io/qt-5/qlineedit.html 1 2 3 def click_ok ( self ): message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) Faire le test dans QGIS avec une saisie de l'utilisateur et fermer la fen\u00eatre. Continuons en rendant en lecture seule le gros bloc de texte et affichons \u00e0 l'int\u00e9rieur la description de la la couche qui est s\u00e9lectionn\u00e9e dans le menu d\u00e9roulant. Documentation : QPlainTextEdit : https://doc.qt.io/qt-5/qplaintextedit.html QgsMapLayerComboBox : https://qgis.org/api/classQgsMapLayerComboBox.html Dans le __init__ : 1 2 self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) Et la nouvelle fonction qui va se charger de mettre \u00e0 jour le texte : 1 2 3 4 5 6 7 def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" ) On peut donc d\u00e9sormais cumuler l'ensemble des chapitres pr\u00e9c\u00e9dents pour lancer des algorithmes, manipuler les donn\u00e9es etc.","title":"Les signaux et les slots"},{"location":"extension-graphique/#solution","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self , parent = None ): _ = parent super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner # Connectons les signaux self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) def click_ok ( self ): self . close () message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" )","title":"Solution"},{"location":"extension-processing/","text":"Cr\u00e9er une extension QGIS pour Processing # Pour faire ce chapitre, il faut : avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent faire la mise \u00e0 jour en extension Processing \u00e0 l'aide de la documentation QGIS","title":"Extension Processing"},{"location":"extension-processing/#creer-une-extension-qgis-pour-processing","text":"Pour faire ce chapitre, il faut : avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent faire la mise \u00e0 jour en extension Processing \u00e0 l'aide de la documentation QGIS","title":"Cr\u00e9er une extension QGIS pour Processing"},{"location":"fonctions-scripts/","text":"Organisation du code dans un script avec des fonctions # Communication avec l'utilisateur des erreurs et des logs # Avant de commencer \u00e0 vraiment \u00e9crire un script avec des fonctions, regardons comment communiquer des informations \u00e0 l'utilisateur. On peut envoyer des messages vers l'utilisateur avec l'utilisation de la messageBar : 1 2 3 4 iface . messageBar () . pushMessage ( 'Erreur' , 'On peut afficher une erreur' , Qgis . Critical ) iface . messageBar () . pushMessage ( 'Avertissement' , 'ou un avertissement' , Qgis . Warning ) iface . messageBar () . pushMessage ( 'Information' , 'ou une information' , Qgis . Info ) iface . messageBar () . pushMessage ( 'Succ\u00e8s' , 'ou un succ\u00e8s' , Qgis . Success ) On peut aussi \u00e9crire des logs comme ceci (plus discret, mais plus verbeux) : 1 2 3 4 QgsMessageLog . logMessage ( 'Une erreur est survenue' , 'Notre outil' , Qgis . Critical ) QgsMessageLog . logMessage ( 'Un avertissement' , 'Notre outil' , Qgis . Warning ) QgsMessageLog . logMessage ( 'Une information' , 'Notre outil' , Qgis . Info ) QgsMessageLog . logMessage ( 'Un succ\u00e8s' , 'Notre outil' , Qgis . Success ) Charger automatiquement plusieurs couches \u00e0 l'aide d'un script # La console c'est bien, mais c'est tr\u00e8s limitant. Passons \u00e0 l'\u00e9criture d'un script qui va nous faciliter l'organisation du code. Voici le dernier script du fichier pr\u00e9c\u00e9dent, mais avec la gestion des erreurs : Red\u00e9marrer QGIS N'ouvrez pas le projet pr\u00e9c\u00e9dent Ouvrer la console, puis cliquer sur Afficher l'\u00e9diteur Copier/coller le script ci-dessous Ex\u00e9cuter le 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) else : fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) else : layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) else : QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) \u00c0 l'aide du m\u00e9mo Python : Essayons de faire une fonction qui prend 2 param\u00e8tres la th\u00e9matique (le dossier) le nom du shapefile La fonction se chargera de faire le n\u00e9cessaire, par exemple: charger_couche('H_OSM_ADMINISTRATIF', 'COMMUNE') La fonction peut \u00e9galement retourner False si la couche n'est pas charg\u00e9e (une erreur) ou sinon l'objet couche. 1 2 def charger_couche ( thematique , couche ): pass Une des solutions : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from os.path import join , isfile , isdir def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge une couche shapefile dans une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) return False layer = QgsVectorLayer ( fichier_shape , shapefile , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) return False QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) return layer charger_couche ( 'H_OSM_ADMINISTRATIF' , 'COMMUNE' ) charger_couche ( 'H_OSM_ADMINISTRATIF' , 'ARRONDISSEMENT' ) Essayons de faire une fonction qui liste les shapefiles d'une certaine th\u00e9matique. os.walk(path) permet de parcourir un chemin. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import os def liste_shapefiles ( thematique ): \"\"\"Liste les shapefiles d'une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () shapes = [] for root , directories , files in os . walk ( os . path . join ( racine , dossier , thematique )): for file in files : if file . lower () . endswith ( '.shp' ): shapes . append ( file . replace ( '.shp' , '' )) return shapes shapes = liste_shapefiles ( 'H_OSM_ADMINISTRATIF' ) print ( shapes ) Permettre le chargement automatique de toute un th\u00e9matique. Extraction des informations sous forme d'un fichier CSV. # On souhaite d\u00e9sormais r\u00e9aliser une fonction d'export des m\u00e9tadonn\u00e9es de nos couches au format CSV, avec son CSVT. Il existe d\u00e9j\u00e0 un module CSV dans Python pour nous aider \u00e0 \u00e9crire un fichier de type CSV, mais nous n'allons pas l'utiliser. Nous allons plut\u00f4t utiliser l'API QGIS pour cr\u00e9er une nouvelle couche en m\u00e9moire comportant les diff\u00e9rentes informations que l'on souhaite exporter. Puis nous allons utiliser l'API pour exporter cette couche m\u00e9moire au format CSV (l'\u00e9quivalent dans QGIS de l'action Exporter la couche ). Les diff\u00e9rents champs qui devront \u00eatre export\u00e9s sont : son nom son type de g\u00e9om\u00e9trie (format humain, lisible) la projection le nombre d'entit\u00e9 l'encodage si le seuil de visibilit\u00e9 est activ\u00e9 la source (le chemin) de la donn\u00e9e Exemple de sortie : nom type projection nombre_entite encodage source seuil_de_visibilite couche_1 Line EPSG:4326 5 UTF-8 /tmp/...geojson False couche_2 Point No geometry 0 /tmp/...shp True Pour cr\u00e9er une couche tabulaire en m\u00e9moire : 1 layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) La liste des couches : 1 layers = QgsProject . instance () . mapLayers () Nous allons avoir besoin de plusieurs classes dans l'API QGIS : Enregistrer un fichier : la classe QgsVectorFileWriter Un champ : QgsField Une entit\u00e9 : QgsFeature Il va y avoir plusieurs \u00e9tapes dans ce script : Cr\u00e9er une couche en m\u00e9moire Ajouter des champs \u00e0 cette couche en utilisant une session d'\u00e9dition R\u00e9cup\u00e9rer la liste des couches pr\u00e9sentes dans la l\u00e9gende It\u00e9rer sur les couches pour ajouter ligne par ligne les m\u00e9tadonn\u00e9es dans une session d'\u00e9dition Enregistrer en CSV la couche m\u00e9moire Solution : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from os.path import join layers = QgsProject . instance () . mapLayers () if not layers : iface . messageBar () . pushMessage ( 'Pas de couche' , 'Attention, il n \\' a pas de couche' , Qgis . Warning ) layers = [ layer for layer in layers . values ()] layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) fields = [] fields . append ( QgsField ( 'nom' , QVariant . String )) fields . append ( QgsField ( 'type' , QVariant . String )) fields . append ( QgsField ( 'projection' , QVariant . String )) fields . append ( QgsField ( 'nombre_entite' , QVariant . Int )) fields . append ( QgsField ( 'encodage' , QVariant . String )) fields . append ( QgsField ( 'source' , QVariant . String )) fields . append ( QgsField ( 'seuil_de_visibilite' , QVariant . String )) with edit ( layer_info ): for field in fields : layer_info . addAttribute ( field ) QgsProject . instance () . addMapLayer ( layer_info ) with edit ( layer_info ): for layer in layers : feature = QgsFeature () attributes = [ layer . name (), QgsWkbTypes . geometryDisplayString ( layer . geometryType ()), layer . crs () . authid (), layer . featureCount (), layer . dataProvider () . encoding (), layer . source (), str ( layer . hasScaleBasedVisibility ()) ] feature . setAttributes ( attributes ) layer_info . addFeature ( feature ) QgsVectorFileWriter . writeAsVectorFormat ( layer_info , join ( QgsProject . instance () . homePath (), 'test.csv' ), 'utf-8' , QgsCoordinateReferenceSystem (), 'CSV' , layerOptions = [ 'CREATE_CSVT=YES' ] ) # Afficher une messageBar pour confirmer que c'est OK, en vert ;-)","title":"Fonctions & Scripts"},{"location":"fonctions-scripts/#organisation-du-code-dans-un-script-avec-des-fonctions","text":"","title":"Organisation du code dans un script avec des fonctions"},{"location":"fonctions-scripts/#communication-avec-lutilisateur-des-erreurs-et-des-logs","text":"Avant de commencer \u00e0 vraiment \u00e9crire un script avec des fonctions, regardons comment communiquer des informations \u00e0 l'utilisateur. On peut envoyer des messages vers l'utilisateur avec l'utilisation de la messageBar : 1 2 3 4 iface . messageBar () . pushMessage ( 'Erreur' , 'On peut afficher une erreur' , Qgis . Critical ) iface . messageBar () . pushMessage ( 'Avertissement' , 'ou un avertissement' , Qgis . Warning ) iface . messageBar () . pushMessage ( 'Information' , 'ou une information' , Qgis . Info ) iface . messageBar () . pushMessage ( 'Succ\u00e8s' , 'ou un succ\u00e8s' , Qgis . Success ) On peut aussi \u00e9crire des logs comme ceci (plus discret, mais plus verbeux) : 1 2 3 4 QgsMessageLog . logMessage ( 'Une erreur est survenue' , 'Notre outil' , Qgis . Critical ) QgsMessageLog . logMessage ( 'Un avertissement' , 'Notre outil' , Qgis . Warning ) QgsMessageLog . logMessage ( 'Une information' , 'Notre outil' , Qgis . Info ) QgsMessageLog . logMessage ( 'Un succ\u00e8s' , 'Notre outil' , Qgis . Success )","title":"Communication avec l'utilisateur des erreurs et des logs"},{"location":"fonctions-scripts/#charger-automatiquement-plusieurs-couches-a-laide-dun-script","text":"La console c'est bien, mais c'est tr\u00e8s limitant. Passons \u00e0 l'\u00e9criture d'un script qui va nous faciliter l'organisation du code. Voici le dernier script du fichier pr\u00e9c\u00e9dent, mais avec la gestion des erreurs : Red\u00e9marrer QGIS N'ouvrez pas le projet pr\u00e9c\u00e9dent Ouvrer la console, puis cliquer sur Afficher l'\u00e9diteur Copier/coller le script ci-dessous Ex\u00e9cuter le 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) else : fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) else : layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) else : QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) \u00c0 l'aide du m\u00e9mo Python : Essayons de faire une fonction qui prend 2 param\u00e8tres la th\u00e9matique (le dossier) le nom du shapefile La fonction se chargera de faire le n\u00e9cessaire, par exemple: charger_couche('H_OSM_ADMINISTRATIF', 'COMMUNE') La fonction peut \u00e9galement retourner False si la couche n'est pas charg\u00e9e (une erreur) ou sinon l'objet couche. 1 2 def charger_couche ( thematique , couche ): pass Une des solutions : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from os.path import join , isfile , isdir def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge une couche shapefile dans une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) return False layer = QgsVectorLayer ( fichier_shape , shapefile , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) return False QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) return layer charger_couche ( 'H_OSM_ADMINISTRATIF' , 'COMMUNE' ) charger_couche ( 'H_OSM_ADMINISTRATIF' , 'ARRONDISSEMENT' ) Essayons de faire une fonction qui liste les shapefiles d'une certaine th\u00e9matique. os.walk(path) permet de parcourir un chemin. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import os def liste_shapefiles ( thematique ): \"\"\"Liste les shapefiles d'une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () shapes = [] for root , directories , files in os . walk ( os . path . join ( racine , dossier , thematique )): for file in files : if file . lower () . endswith ( '.shp' ): shapes . append ( file . replace ( '.shp' , '' )) return shapes shapes = liste_shapefiles ( 'H_OSM_ADMINISTRATIF' ) print ( shapes ) Permettre le chargement automatique de toute un th\u00e9matique.","title":"Charger automatiquement plusieurs couches \u00e0 l'aide d'un script"},{"location":"fonctions-scripts/#extraction-des-informations-sous-forme-dun-fichier-csv","text":"On souhaite d\u00e9sormais r\u00e9aliser une fonction d'export des m\u00e9tadonn\u00e9es de nos couches au format CSV, avec son CSVT. Il existe d\u00e9j\u00e0 un module CSV dans Python pour nous aider \u00e0 \u00e9crire un fichier de type CSV, mais nous n'allons pas l'utiliser. Nous allons plut\u00f4t utiliser l'API QGIS pour cr\u00e9er une nouvelle couche en m\u00e9moire comportant les diff\u00e9rentes informations que l'on souhaite exporter. Puis nous allons utiliser l'API pour exporter cette couche m\u00e9moire au format CSV (l'\u00e9quivalent dans QGIS de l'action Exporter la couche ). Les diff\u00e9rents champs qui devront \u00eatre export\u00e9s sont : son nom son type de g\u00e9om\u00e9trie (format humain, lisible) la projection le nombre d'entit\u00e9 l'encodage si le seuil de visibilit\u00e9 est activ\u00e9 la source (le chemin) de la donn\u00e9e Exemple de sortie : nom type projection nombre_entite encodage source seuil_de_visibilite couche_1 Line EPSG:4326 5 UTF-8 /tmp/...geojson False couche_2 Point No geometry 0 /tmp/...shp True Pour cr\u00e9er une couche tabulaire en m\u00e9moire : 1 layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) La liste des couches : 1 layers = QgsProject . instance () . mapLayers () Nous allons avoir besoin de plusieurs classes dans l'API QGIS : Enregistrer un fichier : la classe QgsVectorFileWriter Un champ : QgsField Une entit\u00e9 : QgsFeature Il va y avoir plusieurs \u00e9tapes dans ce script : Cr\u00e9er une couche en m\u00e9moire Ajouter des champs \u00e0 cette couche en utilisant une session d'\u00e9dition R\u00e9cup\u00e9rer la liste des couches pr\u00e9sentes dans la l\u00e9gende It\u00e9rer sur les couches pour ajouter ligne par ligne les m\u00e9tadonn\u00e9es dans une session d'\u00e9dition Enregistrer en CSV la couche m\u00e9moire Solution : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from os.path import join layers = QgsProject . instance () . mapLayers () if not layers : iface . messageBar () . pushMessage ( 'Pas de couche' , 'Attention, il n \\' a pas de couche' , Qgis . Warning ) layers = [ layer for layer in layers . values ()] layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) fields = [] fields . append ( QgsField ( 'nom' , QVariant . String )) fields . append ( QgsField ( 'type' , QVariant . String )) fields . append ( QgsField ( 'projection' , QVariant . String )) fields . append ( QgsField ( 'nombre_entite' , QVariant . Int )) fields . append ( QgsField ( 'encodage' , QVariant . String )) fields . append ( QgsField ( 'source' , QVariant . String )) fields . append ( QgsField ( 'seuil_de_visibilite' , QVariant . String )) with edit ( layer_info ): for field in fields : layer_info . addAttribute ( field ) QgsProject . instance () . addMapLayer ( layer_info ) with edit ( layer_info ): for layer in layers : feature = QgsFeature () attributes = [ layer . name (), QgsWkbTypes . geometryDisplayString ( layer . geometryType ()), layer . crs () . authid (), layer . featureCount (), layer . dataProvider () . encoding (), layer . source (), str ( layer . hasScaleBasedVisibility ()) ] feature . setAttributes ( attributes ) layer_info . addFeature ( feature ) QgsVectorFileWriter . writeAsVectorFormat ( layer_info , join ( QgsProject . instance () . homePath (), 'test.csv' ), 'utf-8' , QgsCoordinateReferenceSystem (), 'CSV' , layerOptions = [ 'CREATE_CSVT=YES' ] ) # Afficher une messageBar pour confirmer que c'est OK, en vert ;-)","title":"Extraction des informations sous forme d'un fichier CSV."},{"location":"ide-git/","text":"Utilisation d'un IDE # Pour \u00e9crire du code Python, on peut utiliser n'importe quel \u00e9diteur de texte brut quelque soit l'OS. Cependant, l'utilisation d'un \u00e9diteur de texte qui \"comprend\" le code Python est vivement recommand\u00e9 car il peut vous signaler quelques erreurs facilement d\u00e9tectables, tel que les imports manquants. Comme \u00e9diteur de texte, il en existe plusieurs. Si vous souhaitez faire plus de programmation, nous vous recommandons l'utilisation d'un IDE. Il embarque l'\u00e9diteur de texte ci-dessus mais poss\u00e8de aussi des outils de debugs et d'assistance dans l'\u00e9criture du code comme l'autocompl\u00e9tion. En IDE gratuit, il existe : * Visual Studio en ajoutant les extensions Python * PyCharm Community, d\u00e9di\u00e9 au language Python Utilisation de GIT # Il est vivement recommand\u00e9 d'utiliser GIT : sauvegarde de son code sur un server versionner son code et suivre les modifications simplifier le travail d'\u00e9quipe La documentation : https://git-scm.com/docs/ Les commandes les plus utiles : git commit : https://git-scm.com/docs/git-commit/fr git add : https://git-scm.com/docs/git-add/fr git push : https://git-scm.com/docs/git-push/fr git pull : https://git-scm.com/docs/git-pull/fr Liens vers OpenClassRooms : https://openclassrooms.com/fr/courses/1233741-gerez-vos-codes-source-avec-git https://openclassrooms.com/fr/courses/5641721-utilisez-git-et-github-pour-vos-projets-de-developpement","title":"IDE & Git"},{"location":"ide-git/#utilisation-dun-ide","text":"Pour \u00e9crire du code Python, on peut utiliser n'importe quel \u00e9diteur de texte brut quelque soit l'OS. Cependant, l'utilisation d'un \u00e9diteur de texte qui \"comprend\" le code Python est vivement recommand\u00e9 car il peut vous signaler quelques erreurs facilement d\u00e9tectables, tel que les imports manquants. Comme \u00e9diteur de texte, il en existe plusieurs. Si vous souhaitez faire plus de programmation, nous vous recommandons l'utilisation d'un IDE. Il embarque l'\u00e9diteur de texte ci-dessus mais poss\u00e8de aussi des outils de debugs et d'assistance dans l'\u00e9criture du code comme l'autocompl\u00e9tion. En IDE gratuit, il existe : * Visual Studio en ajoutant les extensions Python * PyCharm Community, d\u00e9di\u00e9 au language Python","title":"Utilisation d'un IDE"},{"location":"ide-git/#utilisation-de-git","text":"Il est vivement recommand\u00e9 d'utiliser GIT : sauvegarde de son code sur un server versionner son code et suivre les modifications simplifier le travail d'\u00e9quipe La documentation : https://git-scm.com/docs/ Les commandes les plus utiles : git commit : https://git-scm.com/docs/git-commit/fr git add : https://git-scm.com/docs/git-add/fr git push : https://git-scm.com/docs/git-push/fr git pull : https://git-scm.com/docs/git-pull/fr Liens vers OpenClassRooms : https://openclassrooms.com/fr/courses/1233741-gerez-vos-codes-source-avec-git https://openclassrooms.com/fr/courses/5641721-utilisez-git-et-github-pour-vos-projets-de-developpement","title":"Utilisation de GIT"},{"location":"memo-python/","text":"Introduction au language Python # Qu'est-ce que Python ? # Multi-usage (WEB, application graphique, script, serveur etc) Programmation Orient\u00e9e Objet (POO) Tout est objet Interpr\u00e9t\u00e9 Centr\u00e9 sur la lecture et la productivit\u00e9 Syntaxe du code simple Grosse communaut\u00e9 De nombreux packages disponibles sur internet https://pypi.org/ 1 2 3 4 5 6 7 8 # D\u00e9claration d'une variable de type entier x = 5 # D\u00e9claration d'une variable cha\u00eene de caract\u00e8re info = 'X est compris entre 0 et 10' if 0 < x < 10 : print ( info ) Versions # Python 2 Sortie en 2000 Il est encore tr\u00e8s utilis\u00e9, notamment sur les tutoriels sur internet et quelques projets qui tardent \u00e0 se mettre \u00e0 jour Une adoption massive (QGIS 2) Derni\u00e8re version le 1 janvier 2020 ! Python 3 Sortie en 2008, mais il s'agit d'une adoption tr\u00e8s lente, tellement Python 2 a \u00e9t\u00e9 massivement adopt\u00e9. Derni\u00e8re version 3.9.0 du 5 octobre 2020 QGIS 3 requi\u00e8re Python 3.5 minimum for QGIS < 3.18 Python 3.6 >= 3.18 Rappel de base sur Python # Un m\u00e9mo Python plus important : https://www.w3schools.com/python/ Les types de donn\u00e9es : # Une variable peut contenir un entier, un bool\u00e9en ( True ou False ), cha\u00eene de caract\u00e8res, nombre d\u00e9cimal, un objet... Il y a un faible typage des variables, c'est-\u00e0-dire qu'une variable peut changer de type au cours de l'ex\u00e9cution du programme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 mon_compteur = 0 type ( mon_compteur ) < class ' int '> mon_compteur = False type ( mon_compteur ) < class ' bool '> mon_compteur = 'oui' type ( mon_compteur ) < class ' str '> mon_compteur = \"non\" type ( mon_compteur ) < class ' str '> mon_compteur = 3.5 type ( mon_compteur ) < class ' float '> mon_compteur = None type ( mon_compteur ) < class ' NoneType '> Les structures de donn\u00e9es # Il existe quatre types de structure de donn\u00e9es : les variables simples (ci-dessus) les tuples (non modifiables) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_vide = () liste = ( 1 , 2 , 3 , 'bonjour' ) type ( liste ) < class ' tuple '> len ( liste ) 4 liste [ 0 ] 1 liste [ 0 : 2 ] ( 1 , 2 ) liste [ 2 :] ( 3 , 'bonjour' ) liste [ 5 ] Traceback ( most recent call last ): File \"/usr/lib/python3.7/code.py\" , line 90 , in runcode exec ( code , self . locals ) File \"<input>\" , line 1 , in < module > IndexError : tuple index out of range * les listes (modifiables) 1 2 3 4 5 6 7 nombres = [] type ( nombres ) < class ' list '> nombres . append ( 1 ) nombres . extend ([ 2 , 3 , 4 ]) nombres [ 1 , 2 , 3 , 4 ] les dictionnaires Attention , les dictionnaires ne sont pas ordonn\u00e9s ! Si vraiment il y a besoin, il existe une classe OrderedDict , mais ce n'est pas un structure de donn\u00e9es natif dans Python. C'est un objet. 1 2 3 4 5 6 7 personne = {} type ( personne ) # <class 'dict'> personne [ 'prenom' ] = 'etienne' personne [ 'nom' ] = 'trimaille' personne [ 'est_majeur' ] = True personne [ 'age' ] = 30 Les commentaires # Pour commenter le code dans un script, pas dans la console : 1 2 3 4 5 6 7 8 # Ceci est un commentaire sur une ligne /* Ceci est un commentaire sur plusieurs lignes */ \"\"\" Ces lignes sont r\u00e9serv\u00e9s pour la documentation de l'API et ne doivent pas \u00eatre des lignes de commentaires. \"\"\" Arithm\u00e9tique # 1 2 3 4 5 6 7 8 9 a = 10 a += 1 a -= 1 b = a + 1 c = a - 1 d = a * 2 e = a / 2 f = a % 3 # 1 g = a ** 2 # 100 Concat\u00e9ner des cha\u00eenes et des variables # Concat\u00e9ner, c'est assembler des assembler des cha\u00eenes de caract\u00e8res dans une seule et m\u00eame sortie. On peut concat\u00e9ner des variables entre elles ou du textes. Il existe plein de mani\u00e8res de faire, mais certaines sont plus pratiques que d'autres 1 2 3 4 5 6 7 # Non recommand\u00e9 a = 'bon' b = 'jour' a + b # 'bonjour' c = 1 a + c # Erreur a + str ( c ) # Marche \u00c0 l'ancienne avec % 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour %s !' % prenom bienvenue = 'Bonjour %s , nous sommes le %s novembre' % ( prenom , numero_jour ) Nouveau avec {} et format 1 2 3 4 5 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour {} !' . format ( prenom ) bienvenue = 'Bonjour {} , nous sommes le {} novembre' . format ( prenom , numero_jour ) bienvenue = 'Bonjour {prenom} , nous sommes le {jour} novembre' . format ( prenom = prenom , jour = numero_jour ) Encore plus moderne avec Python 3.6 et fstring 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = f 'Bonjour { prenom } !' bienvenue = f 'Bonjour { prenom } , nous sommes le { numero_jour } novembre' Op\u00e9rateurs logiques # 1 2 3 4 5 6 7 8 9 10 a > b a >= b a < b a <= b a == b a != b a is b a is not b a in b 0 < a < 10 Condition # Important , Python oblige l'indentation sinon il y a une erreur. Par convention, il s'agit de 4 espaces. 1 2 3 4 5 6 7 8 9 10 11 12 note = 13 if note >= 16 : if note == 20 : print ( 'Toutes mes f\u00e9licitations' ) else : print ( 'F\u00e9licitations' ) elif 14 <= note < 16 : print ( 'Tr\u00e8s bien' ) elif 12 <= note < 14 : print ( 'Bien' ) else : print ( 'Peu mieux faire' ) Boucle for # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 for x in range ( 10 ): print ( x ) countries = [ 'Allemagne' , 'Espagne' , 'France' ] for country in countries : print ( 'Pays : {} ' . format ( country )) regions = { 'Auvergne-Rh\u00f4ne-Alpes' : 'Lyon' , 'Bourgogne-Franche-Comt\u00e9' : 'Dijon' , 'Bretagne' : 'Rennes' , 'Centre-Val de Loire' : 'Orl\u00e9ans' , } for region in regions : print ( region ) for region in regions . keys (): print ( region ) for city in regions . values (): print ( city ) for region , city in regions . items (): print ( 'R\u00e9gion {} dont le chef lieu est {} ' . format ( region , city )) Recherche d'un \u00e9l\u00e9ment # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 countries = [ 'Allemagne' , 'Espagne' , 'France' ] # Solution simple if 'Allemagne' in countries : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Plus complexe, avec une fonction pour les minuscules present = False for country in countries : if country . lower () == 'allemagne' : present = True if present : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Le plus pythonique for country in countries : if country . lower () == 'allemagne' : print ( 'Pr\u00e9sent' ) break else : print ( 'Non pr\u00e9sent' ) Boucle while # 1 2 3 4 x = 0 while x < 10 : print ( x ) x += 1 En Python, il n'y a pas de boucle do ... while , \u00e0 la place, on peut faire ainsi : 1 2 3 executer_une_fonction () while not conditon_echec : executer_une_fonction () List Comprehensions # C'est une fa\u00e7on tr\u00e8s pythonique et tr\u00e8s utilis\u00e9e de cr\u00e9er des listes. Par exemple, cr\u00e9er une liste des nombres impaires entre 1 et 9 : 1 2 3 4 5 6 7 8 # Non pythonique impair = [] for x in range ( 10 ): if x % 2 : impair . append ( x ) # Pythonique impair = [ x for x in range ( 10 ) if x % 2 ] Autre exemple en transformant une liste : 1 2 countries = [ 'Allemagne' , 'Espagne' , 'France' ] countries = [ c . upper () for c in countries ] Il existe aussi les Dict Comprehensions (moins utilis\u00e9) Manipulation sur les cha\u00eenes de caract\u00e8res # Pour information, les cha\u00eenes de caract\u00e8res sont des listes et on peut faire du slicing sur des listes : 1 2 3 4 5 6 7 8 9 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' len ( alphabet ) ',' . join ( alphabet ) alphabet . lower () alphabet [ 1 ] # B alphabet [ 1 : 3 ] # BC alphabet [ - 1 ] # Z alphabet [ - 3 :] # XYZ alphabet [: 6 ] # ABCDEF Fonctions # Voici des exemples de fonction Python. Encore une fois , attention \u00e0 l'indentation ! 1 2 3 4 5 6 7 8 9 10 def ajouter ( x , y ): \"\"\"Ajouter deux nombres.\"\"\" return x + y def crier ( phrase = 'bonjour' ): print ( phrase . upper ()) def discuter ( texte , personnage = 'Charles' ): \"\"\"Un personnage discute.\"\"\" print ( ' {} : \" {} \"' . format ( personnage , texte )) Une fonction peut retourner plusieurs valeurs : 1 2 3 4 5 def decomposer ( entier , diviser_par ): \"\"\"Retourne la partie enti\u00e8re et le reste d'une division.\"\"\" partie_entiere = entier / diviser_par reste = entier % diviser_par return partie_entiere , reste Il se peut que l'on ne connaisse pas \u00e0 l'avance le nombre pr\u00e9cis d'arguments dans une fonction. args est utilis\u00e9 pour passer un nombre ind\u00e9termin\u00e9 d'argument \u00e0 la fonction kwargs est utilis\u00e9 pour un nombre ind\u00e9termin\u00e9 d'arguments nomm\u00e9s 1 2 3 4 5 6 7 8 9 def une_fonction ( * args , ** kwargs ): print ( 'Les arguments' ) for arg in args : print ( arg ) print ( 'Les arguments non nomm\u00e9s' ) for key , value in kwargs . items (): print ( ' {} -> {} ' . format ( key , value )) une_fonction ( 1 , 2 , 3 , text = 'Ma phrase' ) Truc et astuces # Attention au passage par r\u00e9f\u00e9rence : 1 2 3 4 5 ma_liste_1 = [ 1 , 2 , 3 ] ma_liste_2 = ma_liste_1 ma_liste_2 . append ( 4 ) print ( ma_liste_2 ) print ( ma_liste_1 ) Avoir un compteur lors de l'it\u00e9ration d'une liste : 1 2 3 users = [ 'Tom' , 'James' , 'John' ] for i , user in enumerate ( users ): print ( ' {} -> {} ' . format ( i + 1 , user ))","title":"M\u00e9mo Python"},{"location":"memo-python/#introduction-au-language-python","text":"","title":"Introduction au language Python"},{"location":"memo-python/#quest-ce-que-python","text":"Multi-usage (WEB, application graphique, script, serveur etc) Programmation Orient\u00e9e Objet (POO) Tout est objet Interpr\u00e9t\u00e9 Centr\u00e9 sur la lecture et la productivit\u00e9 Syntaxe du code simple Grosse communaut\u00e9 De nombreux packages disponibles sur internet https://pypi.org/ 1 2 3 4 5 6 7 8 # D\u00e9claration d'une variable de type entier x = 5 # D\u00e9claration d'une variable cha\u00eene de caract\u00e8re info = 'X est compris entre 0 et 10' if 0 < x < 10 : print ( info )","title":"Qu'est-ce que Python ?"},{"location":"memo-python/#versions","text":"Python 2 Sortie en 2000 Il est encore tr\u00e8s utilis\u00e9, notamment sur les tutoriels sur internet et quelques projets qui tardent \u00e0 se mettre \u00e0 jour Une adoption massive (QGIS 2) Derni\u00e8re version le 1 janvier 2020 ! Python 3 Sortie en 2008, mais il s'agit d'une adoption tr\u00e8s lente, tellement Python 2 a \u00e9t\u00e9 massivement adopt\u00e9. Derni\u00e8re version 3.9.0 du 5 octobre 2020 QGIS 3 requi\u00e8re Python 3.5 minimum for QGIS < 3.18 Python 3.6 >= 3.18","title":"Versions"},{"location":"memo-python/#rappel-de-base-sur-python","text":"Un m\u00e9mo Python plus important : https://www.w3schools.com/python/","title":"Rappel de base sur Python"},{"location":"memo-python/#les-types-de-donnees","text":"Une variable peut contenir un entier, un bool\u00e9en ( True ou False ), cha\u00eene de caract\u00e8res, nombre d\u00e9cimal, un objet... Il y a un faible typage des variables, c'est-\u00e0-dire qu'une variable peut changer de type au cours de l'ex\u00e9cution du programme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 mon_compteur = 0 type ( mon_compteur ) < class ' int '> mon_compteur = False type ( mon_compteur ) < class ' bool '> mon_compteur = 'oui' type ( mon_compteur ) < class ' str '> mon_compteur = \"non\" type ( mon_compteur ) < class ' str '> mon_compteur = 3.5 type ( mon_compteur ) < class ' float '> mon_compteur = None type ( mon_compteur ) < class ' NoneType '>","title":"Les types de donn\u00e9es :"},{"location":"memo-python/#les-structures-de-donnees","text":"Il existe quatre types de structure de donn\u00e9es : les variables simples (ci-dessus) les tuples (non modifiables) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_vide = () liste = ( 1 , 2 , 3 , 'bonjour' ) type ( liste ) < class ' tuple '> len ( liste ) 4 liste [ 0 ] 1 liste [ 0 : 2 ] ( 1 , 2 ) liste [ 2 :] ( 3 , 'bonjour' ) liste [ 5 ] Traceback ( most recent call last ): File \"/usr/lib/python3.7/code.py\" , line 90 , in runcode exec ( code , self . locals ) File \"<input>\" , line 1 , in < module > IndexError : tuple index out of range * les listes (modifiables) 1 2 3 4 5 6 7 nombres = [] type ( nombres ) < class ' list '> nombres . append ( 1 ) nombres . extend ([ 2 , 3 , 4 ]) nombres [ 1 , 2 , 3 , 4 ] les dictionnaires Attention , les dictionnaires ne sont pas ordonn\u00e9s ! Si vraiment il y a besoin, il existe une classe OrderedDict , mais ce n'est pas un structure de donn\u00e9es natif dans Python. C'est un objet. 1 2 3 4 5 6 7 personne = {} type ( personne ) # <class 'dict'> personne [ 'prenom' ] = 'etienne' personne [ 'nom' ] = 'trimaille' personne [ 'est_majeur' ] = True personne [ 'age' ] = 30","title":"Les structures de donn\u00e9es"},{"location":"memo-python/#les-commentaires","text":"Pour commenter le code dans un script, pas dans la console : 1 2 3 4 5 6 7 8 # Ceci est un commentaire sur une ligne /* Ceci est un commentaire sur plusieurs lignes */ \"\"\" Ces lignes sont r\u00e9serv\u00e9s pour la documentation de l'API et ne doivent pas \u00eatre des lignes de commentaires. \"\"\"","title":"Les commentaires"},{"location":"memo-python/#arithmetique","text":"1 2 3 4 5 6 7 8 9 a = 10 a += 1 a -= 1 b = a + 1 c = a - 1 d = a * 2 e = a / 2 f = a % 3 # 1 g = a ** 2 # 100","title":"Arithm\u00e9tique"},{"location":"memo-python/#concatener-des-chaines-et-des-variables","text":"Concat\u00e9ner, c'est assembler des assembler des cha\u00eenes de caract\u00e8res dans une seule et m\u00eame sortie. On peut concat\u00e9ner des variables entre elles ou du textes. Il existe plein de mani\u00e8res de faire, mais certaines sont plus pratiques que d'autres 1 2 3 4 5 6 7 # Non recommand\u00e9 a = 'bon' b = 'jour' a + b # 'bonjour' c = 1 a + c # Erreur a + str ( c ) # Marche \u00c0 l'ancienne avec % 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour %s !' % prenom bienvenue = 'Bonjour %s , nous sommes le %s novembre' % ( prenom , numero_jour ) Nouveau avec {} et format 1 2 3 4 5 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour {} !' . format ( prenom ) bienvenue = 'Bonjour {} , nous sommes le {} novembre' . format ( prenom , numero_jour ) bienvenue = 'Bonjour {prenom} , nous sommes le {jour} novembre' . format ( prenom = prenom , jour = numero_jour ) Encore plus moderne avec Python 3.6 et fstring 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = f 'Bonjour { prenom } !' bienvenue = f 'Bonjour { prenom } , nous sommes le { numero_jour } novembre'","title":"Concat\u00e9ner des cha\u00eenes et des variables"},{"location":"memo-python/#operateurs-logiques","text":"1 2 3 4 5 6 7 8 9 10 a > b a >= b a < b a <= b a == b a != b a is b a is not b a in b 0 < a < 10","title":"Op\u00e9rateurs logiques"},{"location":"memo-python/#condition","text":"Important , Python oblige l'indentation sinon il y a une erreur. Par convention, il s'agit de 4 espaces. 1 2 3 4 5 6 7 8 9 10 11 12 note = 13 if note >= 16 : if note == 20 : print ( 'Toutes mes f\u00e9licitations' ) else : print ( 'F\u00e9licitations' ) elif 14 <= note < 16 : print ( 'Tr\u00e8s bien' ) elif 12 <= note < 14 : print ( 'Bien' ) else : print ( 'Peu mieux faire' )","title":"Condition"},{"location":"memo-python/#boucle-for","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 for x in range ( 10 ): print ( x ) countries = [ 'Allemagne' , 'Espagne' , 'France' ] for country in countries : print ( 'Pays : {} ' . format ( country )) regions = { 'Auvergne-Rh\u00f4ne-Alpes' : 'Lyon' , 'Bourgogne-Franche-Comt\u00e9' : 'Dijon' , 'Bretagne' : 'Rennes' , 'Centre-Val de Loire' : 'Orl\u00e9ans' , } for region in regions : print ( region ) for region in regions . keys (): print ( region ) for city in regions . values (): print ( city ) for region , city in regions . items (): print ( 'R\u00e9gion {} dont le chef lieu est {} ' . format ( region , city ))","title":"Boucle for"},{"location":"memo-python/#recherche-dun-element","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 countries = [ 'Allemagne' , 'Espagne' , 'France' ] # Solution simple if 'Allemagne' in countries : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Plus complexe, avec une fonction pour les minuscules present = False for country in countries : if country . lower () == 'allemagne' : present = True if present : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Le plus pythonique for country in countries : if country . lower () == 'allemagne' : print ( 'Pr\u00e9sent' ) break else : print ( 'Non pr\u00e9sent' )","title":"Recherche d'un \u00e9l\u00e9ment"},{"location":"memo-python/#boucle-while","text":"1 2 3 4 x = 0 while x < 10 : print ( x ) x += 1 En Python, il n'y a pas de boucle do ... while , \u00e0 la place, on peut faire ainsi : 1 2 3 executer_une_fonction () while not conditon_echec : executer_une_fonction ()","title":"Boucle while"},{"location":"memo-python/#list-comprehensions","text":"C'est une fa\u00e7on tr\u00e8s pythonique et tr\u00e8s utilis\u00e9e de cr\u00e9er des listes. Par exemple, cr\u00e9er une liste des nombres impaires entre 1 et 9 : 1 2 3 4 5 6 7 8 # Non pythonique impair = [] for x in range ( 10 ): if x % 2 : impair . append ( x ) # Pythonique impair = [ x for x in range ( 10 ) if x % 2 ] Autre exemple en transformant une liste : 1 2 countries = [ 'Allemagne' , 'Espagne' , 'France' ] countries = [ c . upper () for c in countries ] Il existe aussi les Dict Comprehensions (moins utilis\u00e9)","title":"List Comprehensions"},{"location":"memo-python/#manipulation-sur-les-chaines-de-caracteres","text":"Pour information, les cha\u00eenes de caract\u00e8res sont des listes et on peut faire du slicing sur des listes : 1 2 3 4 5 6 7 8 9 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' len ( alphabet ) ',' . join ( alphabet ) alphabet . lower () alphabet [ 1 ] # B alphabet [ 1 : 3 ] # BC alphabet [ - 1 ] # Z alphabet [ - 3 :] # XYZ alphabet [: 6 ] # ABCDEF","title":"Manipulation sur les cha\u00eenes de caract\u00e8res"},{"location":"memo-python/#fonctions","text":"Voici des exemples de fonction Python. Encore une fois , attention \u00e0 l'indentation ! 1 2 3 4 5 6 7 8 9 10 def ajouter ( x , y ): \"\"\"Ajouter deux nombres.\"\"\" return x + y def crier ( phrase = 'bonjour' ): print ( phrase . upper ()) def discuter ( texte , personnage = 'Charles' ): \"\"\"Un personnage discute.\"\"\" print ( ' {} : \" {} \"' . format ( personnage , texte )) Une fonction peut retourner plusieurs valeurs : 1 2 3 4 5 def decomposer ( entier , diviser_par ): \"\"\"Retourne la partie enti\u00e8re et le reste d'une division.\"\"\" partie_entiere = entier / diviser_par reste = entier % diviser_par return partie_entiere , reste Il se peut que l'on ne connaisse pas \u00e0 l'avance le nombre pr\u00e9cis d'arguments dans une fonction. args est utilis\u00e9 pour passer un nombre ind\u00e9termin\u00e9 d'argument \u00e0 la fonction kwargs est utilis\u00e9 pour un nombre ind\u00e9termin\u00e9 d'arguments nomm\u00e9s 1 2 3 4 5 6 7 8 9 def une_fonction ( * args , ** kwargs ): print ( 'Les arguments' ) for arg in args : print ( arg ) print ( 'Les arguments non nomm\u00e9s' ) for key , value in kwargs . items (): print ( ' {} -> {} ' . format ( key , value )) une_fonction ( 1 , 2 , 3 , text = 'Ma phrase' )","title":"Fonctions"},{"location":"memo-python/#truc-et-astuces","text":"Attention au passage par r\u00e9f\u00e9rence : 1 2 3 4 5 ma_liste_1 = [ 1 , 2 , 3 ] ma_liste_2 = ma_liste_1 ma_liste_2 . append ( 4 ) print ( ma_liste_2 ) print ( ma_liste_1 ) Avoir un compteur lors de l'it\u00e9ration d'une liste : 1 2 3 users = [ 'Tom' , 'James' , 'John' ] for i , user in enumerate ( users ): print ( ' {} -> {} ' . format ( i + 1 , user ))","title":"Truc et astuces"},{"location":"python-qgis/","text":"Le python dans QGIS # QGIS permet d'utiliser du Python dans divers emplacement que nous allons voir ci-dessous. Python poss\u00e8de de tr\u00e8s nombreux packages/modules disponibles sur internet qui fournissent des fonctions d\u00e9j\u00e0 \u00e9crites. Console # La console est accessible par le menu Extension -> Console Python . Elle permet l'\u00e9criture de commande simple, une par une. On ne peut pas enregistrer les commandes dans un fichier. Script Python # L'\u00e9diteur de script Python est accessible depuis l'ic\u00f4ne d\u00e9di\u00e9e dans la console Python. Il permet un prototypage rapide d'un script. On peut y \u00e9crire du code plus complexe en faisant intervenir des librairies ou des classes. Script Processing # Le menu Traitement dans QGIS donne acc\u00e8s a plusieurs algorithmes d'analyse. Ces algorithms proviennent soient de QGIS, GDAL ou encore de plugins. La bo\u00eete \u00e0 outils de traitements ainsi que le modeleur graphique utilisent le \"framework\" Processing propre \u00e0 QGIS. Ce framework permet de d\u00e9finir les entr\u00e9es et les sorties d'un algorithme. Les algorithms sont donc normalis\u00e9s en suivant tous le m\u00eame mod\u00e8le. Processing impose la fa\u00e7on d'\u00e9crire les scripts. \u00c9crire un script compatible QGIS Processing permet l'int\u00e9gration dans ce menu, permet \u00e9galement l'utilisation de ce-dernier dans un mod\u00e8le ou encore l'utilisation en mode traitement par lot. Le framework peut aussi g\u00e9n\u00e9rer automatiquement l'interface graphique de l'algorithme et le code est optimis\u00e9. Il existe un mod\u00e8le par d\u00e9faut que l'on peut utiliser pour d\u00e9marrer l'\u00e9criture d'un script Processing. Depuis la barre d'outils traitements, Cr\u00e9er un nouveau script depuis un mod\u00e8le. Ce mod\u00e8le utilise la syntaxe Programmation Orient\u00e9e Objet. Depuis QGIS 3.6, on peut \u00e9galement utiliser la syntaxe par d\u00e9corateur @alg . Voir la documentation https://docs.qgis.org/testing/en/docs/user_manual/processing/scripts.html#the-alg-decorator Un mod\u00e8le Processing en Python # Depuis QGIS 3.6, on peut d\u00e9sormais exporter un mod\u00e8le de traitement Processing en Python. Il faut faire un clic droit sur un mod\u00e8le dans la bo\u00eete \u00e0 outils puis choisir \"Exporter le mod\u00e8le comme un algorithme Python\". On peut donc modifier ensuite ce fichier Python afin de rajouter de la logique suppl\u00e9mentaire. Extension (plugin) # Extension c\u00f4t\u00e9 bureautique et m\u00eame c\u00f4t\u00e9 QGIS Serveur. La plupart des plugins sont disponibles sur https://plugins.qgis.org pour le t\u00e9l\u00e9chargement, ou sinon ils peuvent \u00eatre install\u00e9s par un dossier ZIP. Afin de d\u00e9velopper une extension : Utilisation du Plugin Builder ou squelette minimum : https://github.com/wonder-sk/qgis-minimal-plugin Plugin Reloader permet de simplifier le d\u00e9veloppement en \u00e9vitant de recharger QGIS Documentation plugin QGIS Serveur : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/server.html Fournisseur Processing dans une extension (Processing Provider) # Similaire au script Processing, une extension QGIS peut aussi avoir son propre fournisseur d'algorithme. On peut remarquer les plugins DataPlotly , QuickOSM etc. Ajout de Processing \u00e0 un plugin QGIS : * soit lors du plugin builder * ou manuellement en suivant la documentation pour l'ajout \u00e0 un plugin existant : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/processing.html Il se peut que certaines extensions ne soient que des fournisseurs Processing. Expressions # Les expressions sont souvent pr\u00e9sentes dans QGIS. On peut les utiliser dans nombreux endroits, pour faire des s\u00e9lections, des conditions, etc. On peut \u00e9galement les utiliser \u00e0 chaque fois que vous pouvez voir ce symbole : Un plugin, ou m\u00eame simplement un utilisateur, peut enregistrer ses propres expressions. Ci-dessous, le plugin InaSAFE : Exemple de code d'une expression : 1 2 3 4 5 6 7 8 9 10 11 @qgsfunction ( args = 'auto' , group = 'Custom' ) def my_sum ( value1 , value2 , feature , parent ): \"\"\" Calculates the sum of the two parameters value1 and value2. <h2>Example usage:</h2> <ul> <li>my_sum(5, 8) -> 13</li> <li>my_sum(\"field1\", \"field2\") -> 42</li> </ul> \"\"\" return value1 + value2 Macros # Accessible depuis les propri\u00e9t\u00e9s du projet, dans l'onglet Macros . On peut lancer du code Python automatiquement soit : * \u00e0 l'ouverture du projet * lors de l'enregistrement du projet * ou lors de sa fermeture Actions # Les actions sont des petits traitements que l'on peut lancer soit depuis la table attributaire ou depuis le canevas. Par exemple, on peut ouvrir un lien WEB ou un PDF en fonction d'un attribut d'une entit\u00e9. Il est possible d'\u00e9crire les actions en Python. Formulaire # On peut personnaliser un formulaire par l'ajout de logique Python. Cependant, dans QGIS 3, l'utilisation de Python n'est plus forc\u00e9ment n\u00e9cessaire, on peut d\u00e9sormais utiliser des expressions (recommand\u00e9) . Application/script ind\u00e9pendant # Sans lancer QGIS graphiquement, on peut utiliser la librairie QGIS dans nos scripts Python. On peut donc cr\u00e9er notre propre application graphique ou notre propre ex\u00e9cutable et ainsi utiliser les fonctions de QGIS. On peut donc faire un programme en ligne de commande qui effectue une certaine op\u00e9ration dans un r\u00e9pertoire donn\u00e9. Depuis QGIS 3.16 , nous pouvons lancer un mod\u00e8le ou un script Processing depuis la ligne de commande depuis l'outil qgis_process . Le fichier \"startup.py\" # Si l'on place un fichier nomm\u00e9 startup.py dans le dossier Python du profil de l'utilisateur, QGIS va le lancer automatiquement \u00e0 chaque ouverture de QGIS.","title":"Python dans QGIS"},{"location":"python-qgis/#le-python-dans-qgis","text":"QGIS permet d'utiliser du Python dans divers emplacement que nous allons voir ci-dessous. Python poss\u00e8de de tr\u00e8s nombreux packages/modules disponibles sur internet qui fournissent des fonctions d\u00e9j\u00e0 \u00e9crites.","title":"Le python dans QGIS"},{"location":"python-qgis/#console","text":"La console est accessible par le menu Extension -> Console Python . Elle permet l'\u00e9criture de commande simple, une par une. On ne peut pas enregistrer les commandes dans un fichier.","title":"Console"},{"location":"python-qgis/#script-python","text":"L'\u00e9diteur de script Python est accessible depuis l'ic\u00f4ne d\u00e9di\u00e9e dans la console Python. Il permet un prototypage rapide d'un script. On peut y \u00e9crire du code plus complexe en faisant intervenir des librairies ou des classes.","title":"Script Python"},{"location":"python-qgis/#script-processing","text":"Le menu Traitement dans QGIS donne acc\u00e8s a plusieurs algorithmes d'analyse. Ces algorithms proviennent soient de QGIS, GDAL ou encore de plugins. La bo\u00eete \u00e0 outils de traitements ainsi que le modeleur graphique utilisent le \"framework\" Processing propre \u00e0 QGIS. Ce framework permet de d\u00e9finir les entr\u00e9es et les sorties d'un algorithme. Les algorithms sont donc normalis\u00e9s en suivant tous le m\u00eame mod\u00e8le. Processing impose la fa\u00e7on d'\u00e9crire les scripts. \u00c9crire un script compatible QGIS Processing permet l'int\u00e9gration dans ce menu, permet \u00e9galement l'utilisation de ce-dernier dans un mod\u00e8le ou encore l'utilisation en mode traitement par lot. Le framework peut aussi g\u00e9n\u00e9rer automatiquement l'interface graphique de l'algorithme et le code est optimis\u00e9. Il existe un mod\u00e8le par d\u00e9faut que l'on peut utiliser pour d\u00e9marrer l'\u00e9criture d'un script Processing. Depuis la barre d'outils traitements, Cr\u00e9er un nouveau script depuis un mod\u00e8le. Ce mod\u00e8le utilise la syntaxe Programmation Orient\u00e9e Objet. Depuis QGIS 3.6, on peut \u00e9galement utiliser la syntaxe par d\u00e9corateur @alg . Voir la documentation https://docs.qgis.org/testing/en/docs/user_manual/processing/scripts.html#the-alg-decorator","title":"Script Processing"},{"location":"python-qgis/#un-modele-processing-en-python","text":"Depuis QGIS 3.6, on peut d\u00e9sormais exporter un mod\u00e8le de traitement Processing en Python. Il faut faire un clic droit sur un mod\u00e8le dans la bo\u00eete \u00e0 outils puis choisir \"Exporter le mod\u00e8le comme un algorithme Python\". On peut donc modifier ensuite ce fichier Python afin de rajouter de la logique suppl\u00e9mentaire.","title":"Un mod\u00e8le Processing en Python"},{"location":"python-qgis/#extension-plugin","text":"Extension c\u00f4t\u00e9 bureautique et m\u00eame c\u00f4t\u00e9 QGIS Serveur. La plupart des plugins sont disponibles sur https://plugins.qgis.org pour le t\u00e9l\u00e9chargement, ou sinon ils peuvent \u00eatre install\u00e9s par un dossier ZIP. Afin de d\u00e9velopper une extension : Utilisation du Plugin Builder ou squelette minimum : https://github.com/wonder-sk/qgis-minimal-plugin Plugin Reloader permet de simplifier le d\u00e9veloppement en \u00e9vitant de recharger QGIS Documentation plugin QGIS Serveur : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/server.html","title":"Extension (plugin)"},{"location":"python-qgis/#fournisseur-processing-dans-une-extension-processing-provider","text":"Similaire au script Processing, une extension QGIS peut aussi avoir son propre fournisseur d'algorithme. On peut remarquer les plugins DataPlotly , QuickOSM etc. Ajout de Processing \u00e0 un plugin QGIS : * soit lors du plugin builder * ou manuellement en suivant la documentation pour l'ajout \u00e0 un plugin existant : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/processing.html Il se peut que certaines extensions ne soient que des fournisseurs Processing.","title":"Fournisseur Processing dans une extension (Processing Provider)"},{"location":"python-qgis/#expressions","text":"Les expressions sont souvent pr\u00e9sentes dans QGIS. On peut les utiliser dans nombreux endroits, pour faire des s\u00e9lections, des conditions, etc. On peut \u00e9galement les utiliser \u00e0 chaque fois que vous pouvez voir ce symbole : Un plugin, ou m\u00eame simplement un utilisateur, peut enregistrer ses propres expressions. Ci-dessous, le plugin InaSAFE : Exemple de code d'une expression : 1 2 3 4 5 6 7 8 9 10 11 @qgsfunction ( args = 'auto' , group = 'Custom' ) def my_sum ( value1 , value2 , feature , parent ): \"\"\" Calculates the sum of the two parameters value1 and value2. <h2>Example usage:</h2> <ul> <li>my_sum(5, 8) -> 13</li> <li>my_sum(\"field1\", \"field2\") -> 42</li> </ul> \"\"\" return value1 + value2","title":"Expressions"},{"location":"python-qgis/#macros","text":"Accessible depuis les propri\u00e9t\u00e9s du projet, dans l'onglet Macros . On peut lancer du code Python automatiquement soit : * \u00e0 l'ouverture du projet * lors de l'enregistrement du projet * ou lors de sa fermeture","title":"Macros"},{"location":"python-qgis/#actions","text":"Les actions sont des petits traitements que l'on peut lancer soit depuis la table attributaire ou depuis le canevas. Par exemple, on peut ouvrir un lien WEB ou un PDF en fonction d'un attribut d'une entit\u00e9. Il est possible d'\u00e9crire les actions en Python.","title":"Actions"},{"location":"python-qgis/#formulaire","text":"On peut personnaliser un formulaire par l'ajout de logique Python. Cependant, dans QGIS 3, l'utilisation de Python n'est plus forc\u00e9ment n\u00e9cessaire, on peut d\u00e9sormais utiliser des expressions (recommand\u00e9) .","title":"Formulaire"},{"location":"python-qgis/#applicationscript-independant","text":"Sans lancer QGIS graphiquement, on peut utiliser la librairie QGIS dans nos scripts Python. On peut donc cr\u00e9er notre propre application graphique ou notre propre ex\u00e9cutable et ainsi utiliser les fonctions de QGIS. On peut donc faire un programme en ligne de commande qui effectue une certaine op\u00e9ration dans un r\u00e9pertoire donn\u00e9. Depuis QGIS 3.16 , nous pouvons lancer un mod\u00e8le ou un script Processing depuis la ligne de commande depuis l'outil qgis_process .","title":"Application/script ind\u00e9pendant"},{"location":"python-qgis/#le-fichier-startuppy","text":"Si l'on place un fichier nomm\u00e9 startup.py dans le dossier Python du profil de l'utilisateur, QGIS va le lancer automatiquement \u00e0 chaque ouverture de QGIS.","title":"Le fichier \"startup.py\""},{"location":"script-processing/","text":"Processing # Processing est un framework pour faire des algorithmes dans QGIS. Toute la boite \u00e0 outils Traitement dans QGIS sont des bas\u00e9s sur \"Processing\". Note , depuis QGIS 3.6, il existe d\u00e9sormais une autre syntaxe pour \u00e9crire script Processing \u00e0 l'aide des d\u00e9corateurs Python. Notion sur la POO en Python # Le framework Processing utilise le concept de la P rogrammation O rient\u00e9e O bjet. Il existe un tutoriel sur le site d'OpenClassRooms sur le sujet. Mais depuis le d\u00e9but de la formation, nous l'utilisons sans trop le savoir. Les objets Qgs* , comme QgsMapLayer utilisent le principe de la POO. Nous allons faire un \"tr\u00e8s\" petit exemple rapide. \u00c9crivons notre premier jeu vid\u00e9o en console ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from time import sleep MAX_ENERGIE = 20 class Personnage : def __init__ ( self , nom , energie = MAX_ENERGIE ): self . nom = nom self . energie = energie def marcher ( self ): cout = 5 if self . energie >= cout : print ( f \" { self . nom } marche.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas marcher car il n'a pas assez d'\u00e9nergie.\" ) def courir ( self ): cout = 10 if self . energie >= cout : print ( f \" { self . nom } court.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas courir car il n \\' a pas assez d \\' \u00e9nergie.\" ) def dormir ( self ): print ( f \" { self . nom } dort et fait le plein d'\u00e9nergie.\" ) for i in range ( 2 ): print ( '...' ) sleep ( 1 ) self . energie = MAX_ENERGIE def manger ( self ): energie = 10 print ( f \" { self . nom } mange et r\u00e9cup\u00e8re { energie } points d'\u00e9nergie.\" ) if self . energie <= MAX_ENERGIE - energie : self . energie += energie else : self . energie = MAX_ENERGIE def __str__ ( self ): return f \"Je suis { self . nom } et j'ai { self . energie } points d'\u00e9nergie\" a = Personnage ( 'Bob' ) a . courir () a . dormir () a . manger () print ( a ) Documentation # Pour l'\u00e9criture d'un script Processing, tant en utilisant la POO ou la version avec les d\u00e9corateurs, il y a une page sur la documentation . Utiliser Processing en Python avec un algorithme existant # Sur une couche en EPSG:2154, faire un buffer de 10 m\u00e8tres par exemple. Cliquer sur la petite horloge dans le panneau de Processing/Traitement en haut Cliquer sur le dernier traitement en haut, puis copier/coller la ligne de Python On peut appeler un traitement en ligne de commande Python : 1 2 3 4 5 6 7 8 9 10 11 12 13 processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/CANALISATION_EAU.shp' , 'DISTANCE' : 10 , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) **Pour obtenir l'identifiant de l'algorithme, laissez la souris sur le nom de l'algorithme pour avoir son info-bulle dans le panneau traitement. Lien vers la documentation : https://docs.qgis.org/testing/en/docs/user_manual/processing/console.html Pour obtenir la description d'un algorithme : 1 processing . algorithmHelp ( \"native:buffer\" ) Exercice , faire une 3 tampons sur la m\u00eame couche vecteur, distance 10, 20 et 30 m\u00e8tres, avec une fonction. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def tampon ( distance ): result = processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/BARRAGE.shp' , 'DISTANCE' : distance , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) QgsProject . instance () . addMapLayer ( result [ 'OUTPUT' ]) for x in [ 10 , 20 , 30 ]: tampon ( x ) Notre propre script Processing # Nous souhaitons pouvoir cr\u00e9er plusieurs tables vides assez facilement \u00e0 l'aide des fichiers CSV. Nous avons un dossier avec plusieurs fichiers CSV repr\u00e9sentant chacun une table. Le nom du fichier CSV repr\u00e9sente le nom de la table. La premi\u00e8re ligne repr\u00e9sente l'ent\u00eate des colonnes. La deuxi\u00e8me ligne, si elle s'appelle geom , repr\u00e9sente le type de g\u00e9om\u00e9trie et sa projection. Exemple de fichier csv canalisation.csv : name type length precision alias geom polygon 2154 id 2 3 0 ID n 10 10 0 Nom d 2 3 0 Diam\u00e8tre l 2 3 0 Longueur Pr\u00e9paration # Cr\u00e9er un dossier processing_canalisation \u00e0 c\u00f4t\u00e9 du projet avec des fichiers CSV \u00e0 l'int\u00e9rieur : canalisation.csv 1 2 3 4 5 6 name,type,length,precision,alias geom,line,2154,'','' id,2,3,0,ID n,10,10,0,Nom d,2,3,0,Diam\u00e8tre l,2,3,0,Longueur regard.csv : 1 2 3 4 name,type,length,precision,alias geom,point,2154,'','' id,2,3,0,ID n,10,10,0,Nom rue Cr\u00e9ation du coeur de notre script # Commen\u00e7ons par \u00e9crire le script en console Il nous faut une fonction qui liste les CSV dans un dossier. 1 2 3 def liste_csv ( folder ): \"\"\" Liste les CSV disponibles dans le dossier. \"\"\" pass Correction du script Python (et non la correction du script Processing) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import os import csv def liste_csv ( folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csv_file : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer # Appel des fonctions folder = os . path . join ( QgsProject . instance () . homePath (), 'processing_canalisation' ) csv_files = liste_csv ( folder ) for csv_file in csv_files : layer = lire_csv ( csv_file ) QgsProject . instance () . addMapLayer ( layer ) Nous avons le coeur de notre algorithme, qui fonctionne dans la console Python. Si l'utilisateur souhaite changer de th\u00e9matique pour la g\u00e9n\u00e9ration des couches (ne pas utiliser processing_canalisation mais plut\u00f4t processing_fibre_optique ou processing_plu ), il faut qu'il modifie \u00e0 la main la ligne de Python, ce n'est pas tr\u00e8s ergonomique. Nous allons d\u00e9sormais le transformer en Script Processing afin de rajouter une interface graphique. Partons de l'algorithme d'exemple : Panneau Traitement Python en haut Cr\u00e9er un nouveau script depuis un mod\u00e8le Modifions les fonctions une par une : name() displayName() ... Pour le initAlgorithm() , nous devons modifier le param\u00e8tre pour afficher un s\u00e9lecteur de dossier : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def initAlgorithm ( self , config = None ): self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT_LAYERS , self . tr ( 'Couches de sorties' ) ) ) Ajoutons les fonctions liste_csv et lire_csv mais : Ajoutons self comme premier param\u00e8tre dans la signature de la fonction : def lire_csv(self, ...): Ajoutons self lors de l'appel \u00e0 la fonction : self.liste_csv(...) Pour le processAlgorithm , nous allons incorporer le code que l'on a fait avant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Il faut aussi ajouter les imports manquants. Solution finale : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 \"\"\" *************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU General Public License as published by * * the Free Software Foundation; either version 2 of the License, or * * (at your option) any later version. * * * *************************************************************************** \"\"\" import os import csv from qgis.PyQt.QtCore import QCoreApplication from qgis.core import ( edit , QgsField , QgsProcessingContext , QgsProcessingAlgorithm , QgsProcessingParameterFile , QgsProcessingOutputMultipleLayers , QgsVectorLayer , ) class ExampleProcessingAlgorithm ( QgsProcessingAlgorithm ): \"\"\" This is an example algorithm that takes a vector layer and creates a new identical one. It is meant to be used as an example of how to create your own algorithms and explain methods and variables used to do it. An algorithm like this will be available in all elements, and there is not need for additional work. All Processing algorithms should extend the QgsProcessingAlgorithm class. \"\"\" # Constants used to refer to parameters and outputs. They will be # used when calling the algorithm from another algorithm, or when # calling from the QGIS console. INPUT = 'INPUT' OUTPUT = 'OUTPUT' def tr ( self , string ): \"\"\" Returns a translatable string with the self.tr() function. \"\"\" return QCoreApplication . translate ( 'Processing' , string ) def createInstance ( self ): return ExampleProcessingAlgorithm () def name ( self ): \"\"\" Returns the algorithm name, used for identifying the algorithm. This string should be fixed for the algorithm, and must not be localised. The name should be unique within each provider. Names should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'myscript' def displayName ( self ): \"\"\" Returns the translated algorithm name, which should be used for any user-visible display of the algorithm name. \"\"\" return self . tr ( 'My Script' ) def group ( self ): \"\"\" Returns the name of the group this algorithm belongs to. This string should be localised. \"\"\" return self . tr ( 'Example scripts' ) def groupId ( self ): \"\"\" Returns the unique ID of the group this algorithm belongs to. This string should be fixed for the algorithm, and must not be localised. The group id should be unique within each provider. Group id should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'examplescripts' def shortHelpString ( self ): \"\"\" Returns a localised short helper string for the algorithm. This string should provide a basic description about what the algorithm does and the parameters and outputs associated with it.. \"\"\" return self . tr ( \"Example algorithm short description\" ) def initAlgorithm ( self , config = None ): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT , self . tr ( 'Couches de sorties' ) ) ) def liste_csv ( self , folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( self , csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csvfile : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Nous avons d\u00e9sormais un nouveau algorithme dans la bo\u00eete \u00e0 outils pour g\u00e9n\u00e9rer un mod\u00e8le de donn\u00e9es suivant une th\u00e9matique. Introduction aux d\u00e9corateurs # Comme mentionn\u00e9 au d\u00e9but de ce chapitre, il est possible de ne pas utiliser la POO pour \u00e9crire un Script Processing mais plut\u00f4t les d\u00e9corateurs. Reprenons l'exemple de la documentation. Le code suivant utilise le d\u00e9corateur @alg pour : utiliser une couche vectorielle comme entr\u00e9e compter le nombre d'entit\u00e9s faire une op\u00e9ration buffer cr\u00e9er une couche raster \u00e0 partir du r\u00e9sultat de l\u2019op\u00e9ration de tampon renvoyer la couche tampon, la couche raster et le nombre d\u2019entit\u00e9s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from qgis import processing from qgis.processing import alg @alg ( name = 'bufferrasteralg' , label = 'Buffer and export to raster (alg)' , group = 'examplescripts' , group_label = 'Example scripts' ) # 'INPUT' is the recommended name for the main input parameter @alg . input ( type = alg . SOURCE , name = 'INPUT' , label = 'Input vector layer' ) # 'OUTPUT' is the recommended name for the main output parameter @alg . input ( type = alg . RASTER_LAYER_DEST , name = 'OUTPUT' , label = 'Raster output' ) @alg . input ( type = alg . VECTOR_LAYER_DEST , name = 'BUFFER_OUTPUT' , label = 'Buffer output' ) @alg . input ( type = alg . DISTANCE , name = 'BUFFERDIST' , label = 'BUFFER DISTANCE' , default = 1.0 ) @alg . input ( type = alg . DISTANCE , name = 'CELLSIZE' , label = 'RASTER CELL SIZE' , default = 10.0 ) @alg . output ( type = alg . NUMBER , name = 'NUMBEROFFEATURES' , label = 'Number of features processed' ) def bufferrasteralg ( instance , parameters , context , feedback , inputs ): \"\"\" Description of the algorithm. (If there is no comment here, you will get an error) \"\"\" input_featuresource = instance . parameterAsSource ( parameters , 'INPUT' , context ) numfeatures = input_featuresource . featureCount () bufferdist = instance . parameterAsDouble ( parameters , 'BUFFERDIST' , context ) rastercellsize = instance . parameterAsDouble ( parameters , 'CELLSIZE' , context ) if feedback . isCanceled (): return {} params = { 'INPUT' : parameters [ 'INPUT' ], 'OUTPUT' : parameters [ 'BUFFER_OUTPUT' ], 'DISTANCE' : bufferdist , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 } buffer_result = processing . run ( 'native:buffer' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} params = { 'LAYER' : buffer_result [ 'OUTPUT' ], 'EXTENT' : buffer_result [ 'OUTPUT' ], 'MAP_UNITS_PER_PIXEL' : rastercellsize , 'OUTPUT' : parameters [ 'OUTPUT' ] } rasterized_result = processing . run ( 'qgis:rasterize' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} results = { 'OUTPUT' : rasterized_result [ 'OUTPUT' ], 'BUFFER_OUTPUT' : buffer_result [ 'OUTPUT' ], 'NUMBEROFFEATURES' : numfeatures , } return results Convertir un mod\u00e8le Processing en python # Il est possible de convertir un mod\u00e8le Processing en script Python. On peut alors le modifier avec plus de finesse. On ne peut pas reconvertir un script Python en mod\u00e8le . Depuis un mod\u00e8le, cliquer sur le bouton \"Convertir en script Processing\".","title":"Script Processing"},{"location":"script-processing/#processing","text":"Processing est un framework pour faire des algorithmes dans QGIS. Toute la boite \u00e0 outils Traitement dans QGIS sont des bas\u00e9s sur \"Processing\". Note , depuis QGIS 3.6, il existe d\u00e9sormais une autre syntaxe pour \u00e9crire script Processing \u00e0 l'aide des d\u00e9corateurs Python.","title":"Processing"},{"location":"script-processing/#notion-sur-la-poo-en-python","text":"Le framework Processing utilise le concept de la P rogrammation O rient\u00e9e O bjet. Il existe un tutoriel sur le site d'OpenClassRooms sur le sujet. Mais depuis le d\u00e9but de la formation, nous l'utilisons sans trop le savoir. Les objets Qgs* , comme QgsMapLayer utilisent le principe de la POO. Nous allons faire un \"tr\u00e8s\" petit exemple rapide. \u00c9crivons notre premier jeu vid\u00e9o en console ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from time import sleep MAX_ENERGIE = 20 class Personnage : def __init__ ( self , nom , energie = MAX_ENERGIE ): self . nom = nom self . energie = energie def marcher ( self ): cout = 5 if self . energie >= cout : print ( f \" { self . nom } marche.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas marcher car il n'a pas assez d'\u00e9nergie.\" ) def courir ( self ): cout = 10 if self . energie >= cout : print ( f \" { self . nom } court.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas courir car il n \\' a pas assez d \\' \u00e9nergie.\" ) def dormir ( self ): print ( f \" { self . nom } dort et fait le plein d'\u00e9nergie.\" ) for i in range ( 2 ): print ( '...' ) sleep ( 1 ) self . energie = MAX_ENERGIE def manger ( self ): energie = 10 print ( f \" { self . nom } mange et r\u00e9cup\u00e8re { energie } points d'\u00e9nergie.\" ) if self . energie <= MAX_ENERGIE - energie : self . energie += energie else : self . energie = MAX_ENERGIE def __str__ ( self ): return f \"Je suis { self . nom } et j'ai { self . energie } points d'\u00e9nergie\" a = Personnage ( 'Bob' ) a . courir () a . dormir () a . manger () print ( a )","title":"Notion sur la POO en Python"},{"location":"script-processing/#documentation","text":"Pour l'\u00e9criture d'un script Processing, tant en utilisant la POO ou la version avec les d\u00e9corateurs, il y a une page sur la documentation .","title":"Documentation"},{"location":"script-processing/#utiliser-processing-en-python-avec-un-algorithme-existant","text":"Sur une couche en EPSG:2154, faire un buffer de 10 m\u00e8tres par exemple. Cliquer sur la petite horloge dans le panneau de Processing/Traitement en haut Cliquer sur le dernier traitement en haut, puis copier/coller la ligne de Python On peut appeler un traitement en ligne de commande Python : 1 2 3 4 5 6 7 8 9 10 11 12 13 processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/CANALISATION_EAU.shp' , 'DISTANCE' : 10 , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) **Pour obtenir l'identifiant de l'algorithme, laissez la souris sur le nom de l'algorithme pour avoir son info-bulle dans le panneau traitement. Lien vers la documentation : https://docs.qgis.org/testing/en/docs/user_manual/processing/console.html Pour obtenir la description d'un algorithme : 1 processing . algorithmHelp ( \"native:buffer\" ) Exercice , faire une 3 tampons sur la m\u00eame couche vecteur, distance 10, 20 et 30 m\u00e8tres, avec une fonction. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def tampon ( distance ): result = processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/BARRAGE.shp' , 'DISTANCE' : distance , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) QgsProject . instance () . addMapLayer ( result [ 'OUTPUT' ]) for x in [ 10 , 20 , 30 ]: tampon ( x )","title":"Utiliser Processing en Python avec un algorithme existant"},{"location":"script-processing/#notre-propre-script-processing","text":"Nous souhaitons pouvoir cr\u00e9er plusieurs tables vides assez facilement \u00e0 l'aide des fichiers CSV. Nous avons un dossier avec plusieurs fichiers CSV repr\u00e9sentant chacun une table. Le nom du fichier CSV repr\u00e9sente le nom de la table. La premi\u00e8re ligne repr\u00e9sente l'ent\u00eate des colonnes. La deuxi\u00e8me ligne, si elle s'appelle geom , repr\u00e9sente le type de g\u00e9om\u00e9trie et sa projection. Exemple de fichier csv canalisation.csv : name type length precision alias geom polygon 2154 id 2 3 0 ID n 10 10 0 Nom d 2 3 0 Diam\u00e8tre l 2 3 0 Longueur","title":"Notre propre script Processing"},{"location":"script-processing/#preparation","text":"Cr\u00e9er un dossier processing_canalisation \u00e0 c\u00f4t\u00e9 du projet avec des fichiers CSV \u00e0 l'int\u00e9rieur : canalisation.csv 1 2 3 4 5 6 name,type,length,precision,alias geom,line,2154,'','' id,2,3,0,ID n,10,10,0,Nom d,2,3,0,Diam\u00e8tre l,2,3,0,Longueur regard.csv : 1 2 3 4 name,type,length,precision,alias geom,point,2154,'','' id,2,3,0,ID n,10,10,0,Nom rue","title":"Pr\u00e9paration"},{"location":"script-processing/#creation-du-coeur-de-notre-script","text":"Commen\u00e7ons par \u00e9crire le script en console Il nous faut une fonction qui liste les CSV dans un dossier. 1 2 3 def liste_csv ( folder ): \"\"\" Liste les CSV disponibles dans le dossier. \"\"\" pass Correction du script Python (et non la correction du script Processing) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import os import csv def liste_csv ( folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csv_file : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer # Appel des fonctions folder = os . path . join ( QgsProject . instance () . homePath (), 'processing_canalisation' ) csv_files = liste_csv ( folder ) for csv_file in csv_files : layer = lire_csv ( csv_file ) QgsProject . instance () . addMapLayer ( layer ) Nous avons le coeur de notre algorithme, qui fonctionne dans la console Python. Si l'utilisateur souhaite changer de th\u00e9matique pour la g\u00e9n\u00e9ration des couches (ne pas utiliser processing_canalisation mais plut\u00f4t processing_fibre_optique ou processing_plu ), il faut qu'il modifie \u00e0 la main la ligne de Python, ce n'est pas tr\u00e8s ergonomique. Nous allons d\u00e9sormais le transformer en Script Processing afin de rajouter une interface graphique. Partons de l'algorithme d'exemple : Panneau Traitement Python en haut Cr\u00e9er un nouveau script depuis un mod\u00e8le Modifions les fonctions une par une : name() displayName() ... Pour le initAlgorithm() , nous devons modifier le param\u00e8tre pour afficher un s\u00e9lecteur de dossier : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def initAlgorithm ( self , config = None ): self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT_LAYERS , self . tr ( 'Couches de sorties' ) ) ) Ajoutons les fonctions liste_csv et lire_csv mais : Ajoutons self comme premier param\u00e8tre dans la signature de la fonction : def lire_csv(self, ...): Ajoutons self lors de l'appel \u00e0 la fonction : self.liste_csv(...) Pour le processAlgorithm , nous allons incorporer le code que l'on a fait avant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Il faut aussi ajouter les imports manquants. Solution finale : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 \"\"\" *************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU General Public License as published by * * the Free Software Foundation; either version 2 of the License, or * * (at your option) any later version. * * * *************************************************************************** \"\"\" import os import csv from qgis.PyQt.QtCore import QCoreApplication from qgis.core import ( edit , QgsField , QgsProcessingContext , QgsProcessingAlgorithm , QgsProcessingParameterFile , QgsProcessingOutputMultipleLayers , QgsVectorLayer , ) class ExampleProcessingAlgorithm ( QgsProcessingAlgorithm ): \"\"\" This is an example algorithm that takes a vector layer and creates a new identical one. It is meant to be used as an example of how to create your own algorithms and explain methods and variables used to do it. An algorithm like this will be available in all elements, and there is not need for additional work. All Processing algorithms should extend the QgsProcessingAlgorithm class. \"\"\" # Constants used to refer to parameters and outputs. They will be # used when calling the algorithm from another algorithm, or when # calling from the QGIS console. INPUT = 'INPUT' OUTPUT = 'OUTPUT' def tr ( self , string ): \"\"\" Returns a translatable string with the self.tr() function. \"\"\" return QCoreApplication . translate ( 'Processing' , string ) def createInstance ( self ): return ExampleProcessingAlgorithm () def name ( self ): \"\"\" Returns the algorithm name, used for identifying the algorithm. This string should be fixed for the algorithm, and must not be localised. The name should be unique within each provider. Names should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'myscript' def displayName ( self ): \"\"\" Returns the translated algorithm name, which should be used for any user-visible display of the algorithm name. \"\"\" return self . tr ( 'My Script' ) def group ( self ): \"\"\" Returns the name of the group this algorithm belongs to. This string should be localised. \"\"\" return self . tr ( 'Example scripts' ) def groupId ( self ): \"\"\" Returns the unique ID of the group this algorithm belongs to. This string should be fixed for the algorithm, and must not be localised. The group id should be unique within each provider. Group id should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'examplescripts' def shortHelpString ( self ): \"\"\" Returns a localised short helper string for the algorithm. This string should provide a basic description about what the algorithm does and the parameters and outputs associated with it.. \"\"\" return self . tr ( \"Example algorithm short description\" ) def initAlgorithm ( self , config = None ): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT , self . tr ( 'Couches de sorties' ) ) ) def liste_csv ( self , folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( self , csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csvfile : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Nous avons d\u00e9sormais un nouveau algorithme dans la bo\u00eete \u00e0 outils pour g\u00e9n\u00e9rer un mod\u00e8le de donn\u00e9es suivant une th\u00e9matique.","title":"Cr\u00e9ation du coeur de notre script"},{"location":"script-processing/#introduction-aux-decorateurs","text":"Comme mentionn\u00e9 au d\u00e9but de ce chapitre, il est possible de ne pas utiliser la POO pour \u00e9crire un Script Processing mais plut\u00f4t les d\u00e9corateurs. Reprenons l'exemple de la documentation. Le code suivant utilise le d\u00e9corateur @alg pour : utiliser une couche vectorielle comme entr\u00e9e compter le nombre d'entit\u00e9s faire une op\u00e9ration buffer cr\u00e9er une couche raster \u00e0 partir du r\u00e9sultat de l\u2019op\u00e9ration de tampon renvoyer la couche tampon, la couche raster et le nombre d\u2019entit\u00e9s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from qgis import processing from qgis.processing import alg @alg ( name = 'bufferrasteralg' , label = 'Buffer and export to raster (alg)' , group = 'examplescripts' , group_label = 'Example scripts' ) # 'INPUT' is the recommended name for the main input parameter @alg . input ( type = alg . SOURCE , name = 'INPUT' , label = 'Input vector layer' ) # 'OUTPUT' is the recommended name for the main output parameter @alg . input ( type = alg . RASTER_LAYER_DEST , name = 'OUTPUT' , label = 'Raster output' ) @alg . input ( type = alg . VECTOR_LAYER_DEST , name = 'BUFFER_OUTPUT' , label = 'Buffer output' ) @alg . input ( type = alg . DISTANCE , name = 'BUFFERDIST' , label = 'BUFFER DISTANCE' , default = 1.0 ) @alg . input ( type = alg . DISTANCE , name = 'CELLSIZE' , label = 'RASTER CELL SIZE' , default = 10.0 ) @alg . output ( type = alg . NUMBER , name = 'NUMBEROFFEATURES' , label = 'Number of features processed' ) def bufferrasteralg ( instance , parameters , context , feedback , inputs ): \"\"\" Description of the algorithm. (If there is no comment here, you will get an error) \"\"\" input_featuresource = instance . parameterAsSource ( parameters , 'INPUT' , context ) numfeatures = input_featuresource . featureCount () bufferdist = instance . parameterAsDouble ( parameters , 'BUFFERDIST' , context ) rastercellsize = instance . parameterAsDouble ( parameters , 'CELLSIZE' , context ) if feedback . isCanceled (): return {} params = { 'INPUT' : parameters [ 'INPUT' ], 'OUTPUT' : parameters [ 'BUFFER_OUTPUT' ], 'DISTANCE' : bufferdist , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 } buffer_result = processing . run ( 'native:buffer' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} params = { 'LAYER' : buffer_result [ 'OUTPUT' ], 'EXTENT' : buffer_result [ 'OUTPUT' ], 'MAP_UNITS_PER_PIXEL' : rastercellsize , 'OUTPUT' : parameters [ 'OUTPUT' ] } rasterized_result = processing . run ( 'qgis:rasterize' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} results = { 'OUTPUT' : rasterized_result [ 'OUTPUT' ], 'BUFFER_OUTPUT' : buffer_result [ 'OUTPUT' ], 'NUMBEROFFEATURES' : numfeatures , } return results","title":"Introduction aux d\u00e9corateurs"},{"location":"script-processing/#convertir-un-modele-processing-en-python","text":"Il est possible de convertir un mod\u00e8le Processing en script Python. On peut alors le modifier avec plus de finesse. On ne peut pas reconvertir un script Python en mod\u00e8le . Depuis un mod\u00e8le, cliquer sur le bouton \"Convertir en script Processing\".","title":"Convertir un mod\u00e8le Processing en python"},{"location":"selection-parcours-entites/","text":"Boucler sur les entit\u00e9s d'une couche sans expression # On peut parcourir les entit\u00e9s d'une couche QgsVectorLayer \u00e0 l'aide de getFeatures() : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): print ( feature ) print ( feature [ 'NOM' ]) Utilisation des expressions QGIS # Les expressions sont tr\u00e8s pr\u00e9sentes dans QGIS, tant dans l'interface graphique que dans l'utilisation en Python. Nous partons de la couche des COMMUNES uniquement charg\u00e9 dans QGIS. S\u00e9lection d'entit\u00e9 # Nous souhaitons s\u00e9lectionner les entit\u00e9s dont le code INSEE commence par 77 . Commen\u00e7ons par faire cela graphiquement dans QGIS Desktop. \u00c0 l'aide d'une expression QGIS, s\u00e9lectionner les codes INSEE qui commencent par 77 (\u00e0 choisir un code INSEE propre au jeu de donn\u00e9es). Solution en mode graphique : 1 \"CODE_INSEE\" LIKE '77%' Nous allons faire la m\u00eame chose, mais en utilisant Python. Pensez \u00e0 d\u00e9s\u00e9lectionner les entit\u00e9s. 1 2 3 4 5 layer = iface . activeLayer () layer . removeSelection () layer . selectByExpression ( \" \\\" CODE_INSEE \\\" LIKE ' {} %'\" . format ( 77 )) layer . invertSelection () layer . removeSelection () Boucler sur les entit\u00e9s \u00e0 l'aide d'une expression # L'objectif est d'afficher dans la console le nom des communes dont la population ne contient pas NC . Note , en PyQGIS, on peut acc\u00e9der aux attributs d'une QgsFeature simplement avec l'op\u00e9rateur [] sur l'objet courant comme s'il s'agissait d'une liste Python : L'exemple \u00e0 ne pas faire, m\u00eame si cela fonctionne : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): if feature [ 'POPUL' ] != 'NC' : print ( feature [ 'NOM' ]) Dans la documentation, observez bien la signature de la fonction getFeatures . Que remarquez-vous ? Utilisons donc une expression pour limiter les r\u00e9sultats. 1 2 3 request = QgsFeatureRequest ( QgsExpression ( '\"POPUL\" != \\' NC \\' ' )) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants pour' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Nous pouvons accessoirement ordonner les r\u00e9sultats et surtout encore optimiser la requ\u00eate en : Ne demandant pas de charger la g\u00e9om\u00e9trie Ne demandant pas de charger tous les attributs 1 2 3 4 5 6 7 request = QgsFeatureRequest () request . setFilterExpression ( '\"POPUL\" != \\' NC \\' ' ) request . addOrderBy ( 'NOM' ) request . setFlags ( QgsFeatureRequest . NoGeometry ) request . setSubsetOfAttributes ([ 1 , 4 ]) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Faire le test en affichant un champ qui n'est pas dans la requ\u00eate. Rajoutons une intersection spatiale avec l'emprise suivante : 1 request . setFilterRect ( QgsRectangle ( 662737 , 6807733 , 717144 , 6853979 )) Si l'on souhaite \"enregistrer\" le r\u00e9sultat de cette expression QGIS, on peut la mat\u00e9rialiser dans une nouvelle couche : 1 2 memory_layer = layer . materialize ( request ) QgsProject . instance () . addMapLayer ( memory_layer ) Regardons le r\u00e9sultat et corrigeons ce probl\u00e8me d'export afin d'obtenir les g\u00e9om\u00e9tries et les attributs : 1 request . setFlags ( QgsFeatureRequest . NoFlags ) Avant-dernier exercice, afficher une liste des communes dont la population est inf\u00e9rieur \u00e0 1000 habitants en incluant la densit\u00e9 de population. Les exceptions en Python # Avant de traiter cet exercice, nous devons voir ce qu'est une exception en Python. \u00c0 plusieurs reprises depuis le d\u00e9but de la formation, il est fort \u00e0 parier que nous ayons des messages en rouges dans la console de temps en temps. Ce sont des exceptions. C'est une notion de programmation qui existe dans beaucoup de languages. Dans le language informatique, une exception peut-\u00eatre : lev\u00e9 (raise en anglais) pour d\u00e9clencher une erreur attrap\u00e9 (catch en anglais) pour traiter l'erreur Essayons dans la console de faire une l'op\u00e9ration 10 / 2 : 1 10 / 2 Essayons cette fois-ci 10 / 0, ce qui est math\u00e9matiquement impossible : 1 10 / 0 On peut \"attraper\" cette erreur Python \u00e0 l'aide d'un try ... except... : 1 2 3 4 try : 10 / 2 except ZeroDivisionError : print ( 'Ceci est une division par z\u00e9ro !' ) Le try permet d'essayer le code qui suit. Le except permet d'attraper en filtrant s'il y a des exceptions et de traiter l'erreur si besoin. Toutes les exceptions h\u00e9ritent de Exception donc le code ci-dessous fonctionne, mais n'est pas recommand\u00e9 car il masque d'autres erreurs : 1 2 3 4 try : 10 / 2 except Exception : print ( 'Ceci est une division par z\u00e9ro !' ) On peut imaginer faire une fonction qui divise deux nombres et affiche le r\u00e9sultat dans la QgsMessageBar de QGIS, sans tenir compte de la division par z\u00e9ro : 1 2 3 4 5 def diviser ( a , b ): result = a / b iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 0 ) En tenant compte d'une possible erreur lors de l'op\u00e9ration math\u00e9matique : 1 2 3 4 5 6 7 8 9 def diviser ( a , b ): try : result = a / b except ZeroDivisionError : iface . messageBar () . pushMessage ( 'Division par 0' , f ' { a } / { b } est impossible' , Qgis . Warning ) else : iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 2 ) \u00c9videment, on peut v\u00e9rifier la valeur de b en amont si c'est \u00e9gal \u00e0 0. Mais ceci est pour pr\u00e9senter le concept des exceptions en Python. Retour \u00e0 l'exercice # On souhaite donc savoir si un nombre est transformable en entier, dans le cas de la population (s'il y a NC par exemple) : 1 2 int ( '10' ) int ( 'NC' ) Correction possible de l'exercice : 1 2 3 4 5 6 7 8 9 10 11 12 layer = iface . activeLayer () request = QgsFeatureRequest () # request.setFilterExpression('to_int( \"POPUL\" ) < 1000') request . addOrderBy ( 'NOM' ) request . setSubsetOfAttributes ([ 1 , 4 ]) for feature in layer . getFeatures ( request ): area = feature . geometry () . area () / 1000000 try : population = int ( feature [ 'POPUL' ]) except ValueError : population = 0 print ( ' {commune} : {densite} habitants/km\u00b2' . format ( commune = feature [ 'NOM' ], densite = population / area )) Nous souhaitons enregistrer ces informations dans une vraie table avec un nouveau champ densite_population . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): field = QgsField ( 'densite_population' , QVariant . Double ) petites_communes . addAttribute ( field ) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) QgsProject . instance () . addMapLayer ( petites_communes ) Manipulons d\u00e9sormais la g\u00e9om\u00e9trie en ajoutant le centro\u00efde de la commune dans une colonne latitude et longitude en degr\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): petites_communes . addAttribute ( QgsField ( 'densite_population' , QVariant . Double )) # /!\\ Ajouter les 2 lignes ci-dessous petites_communes . addAttribute ( QgsField ( 'longitude' , QVariant . Double )) petites_communes . addAttribute ( QgsField ( 'latitude' , QVariant . Double )) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) # /!\\ Ajouter les 2 lignes ci-dessous \u00e0 propos de la transformation transform = QgsCoordinateTransform ( QgsCoordinateReferenceSystem ( 2154 ), QgsCoordinateReferenceSystem ( 4326 ), QgsProject . instance ()) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) # /!\\ Ajouter les lignes ci-dessous geom = feature . geometry () # La transformation affecte directement l'objet Python en cours, mais pas l'entit\u00e9 dans la couche geom . transform ( transform ) centroid = geom . centroid () . asPoint () petites_communes . changeAttributeValue ( feature . id (), 6 , centroid . x ()) petites_communes . changeAttributeValue ( feature . id (), 7 , centroid . y ()) QgsProject . instance () . addMapLayer ( petites_communes )","title":"S\u00e9lection & Parcours"},{"location":"selection-parcours-entites/#boucler-sur-les-entites-dune-couche-sans-expression","text":"On peut parcourir les entit\u00e9s d'une couche QgsVectorLayer \u00e0 l'aide de getFeatures() : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): print ( feature ) print ( feature [ 'NOM' ])","title":"Boucler sur les entit\u00e9s d'une couche sans expression"},{"location":"selection-parcours-entites/#utilisation-des-expressions-qgis","text":"Les expressions sont tr\u00e8s pr\u00e9sentes dans QGIS, tant dans l'interface graphique que dans l'utilisation en Python. Nous partons de la couche des COMMUNES uniquement charg\u00e9 dans QGIS.","title":"Utilisation des expressions QGIS"},{"location":"selection-parcours-entites/#selection-dentite","text":"Nous souhaitons s\u00e9lectionner les entit\u00e9s dont le code INSEE commence par 77 . Commen\u00e7ons par faire cela graphiquement dans QGIS Desktop. \u00c0 l'aide d'une expression QGIS, s\u00e9lectionner les codes INSEE qui commencent par 77 (\u00e0 choisir un code INSEE propre au jeu de donn\u00e9es). Solution en mode graphique : 1 \"CODE_INSEE\" LIKE '77%' Nous allons faire la m\u00eame chose, mais en utilisant Python. Pensez \u00e0 d\u00e9s\u00e9lectionner les entit\u00e9s. 1 2 3 4 5 layer = iface . activeLayer () layer . removeSelection () layer . selectByExpression ( \" \\\" CODE_INSEE \\\" LIKE ' {} %'\" . format ( 77 )) layer . invertSelection () layer . removeSelection ()","title":"S\u00e9lection d'entit\u00e9"},{"location":"selection-parcours-entites/#boucler-sur-les-entites-a-laide-dune-expression","text":"L'objectif est d'afficher dans la console le nom des communes dont la population ne contient pas NC . Note , en PyQGIS, on peut acc\u00e9der aux attributs d'une QgsFeature simplement avec l'op\u00e9rateur [] sur l'objet courant comme s'il s'agissait d'une liste Python : L'exemple \u00e0 ne pas faire, m\u00eame si cela fonctionne : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): if feature [ 'POPUL' ] != 'NC' : print ( feature [ 'NOM' ]) Dans la documentation, observez bien la signature de la fonction getFeatures . Que remarquez-vous ? Utilisons donc une expression pour limiter les r\u00e9sultats. 1 2 3 request = QgsFeatureRequest ( QgsExpression ( '\"POPUL\" != \\' NC \\' ' )) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants pour' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Nous pouvons accessoirement ordonner les r\u00e9sultats et surtout encore optimiser la requ\u00eate en : Ne demandant pas de charger la g\u00e9om\u00e9trie Ne demandant pas de charger tous les attributs 1 2 3 4 5 6 7 request = QgsFeatureRequest () request . setFilterExpression ( '\"POPUL\" != \\' NC \\' ' ) request . addOrderBy ( 'NOM' ) request . setFlags ( QgsFeatureRequest . NoGeometry ) request . setSubsetOfAttributes ([ 1 , 4 ]) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Faire le test en affichant un champ qui n'est pas dans la requ\u00eate. Rajoutons une intersection spatiale avec l'emprise suivante : 1 request . setFilterRect ( QgsRectangle ( 662737 , 6807733 , 717144 , 6853979 )) Si l'on souhaite \"enregistrer\" le r\u00e9sultat de cette expression QGIS, on peut la mat\u00e9rialiser dans une nouvelle couche : 1 2 memory_layer = layer . materialize ( request ) QgsProject . instance () . addMapLayer ( memory_layer ) Regardons le r\u00e9sultat et corrigeons ce probl\u00e8me d'export afin d'obtenir les g\u00e9om\u00e9tries et les attributs : 1 request . setFlags ( QgsFeatureRequest . NoFlags ) Avant-dernier exercice, afficher une liste des communes dont la population est inf\u00e9rieur \u00e0 1000 habitants en incluant la densit\u00e9 de population.","title":"Boucler sur les entit\u00e9s \u00e0 l'aide d'une expression"},{"location":"selection-parcours-entites/#les-exceptions-en-python","text":"Avant de traiter cet exercice, nous devons voir ce qu'est une exception en Python. \u00c0 plusieurs reprises depuis le d\u00e9but de la formation, il est fort \u00e0 parier que nous ayons des messages en rouges dans la console de temps en temps. Ce sont des exceptions. C'est une notion de programmation qui existe dans beaucoup de languages. Dans le language informatique, une exception peut-\u00eatre : lev\u00e9 (raise en anglais) pour d\u00e9clencher une erreur attrap\u00e9 (catch en anglais) pour traiter l'erreur Essayons dans la console de faire une l'op\u00e9ration 10 / 2 : 1 10 / 2 Essayons cette fois-ci 10 / 0, ce qui est math\u00e9matiquement impossible : 1 10 / 0 On peut \"attraper\" cette erreur Python \u00e0 l'aide d'un try ... except... : 1 2 3 4 try : 10 / 2 except ZeroDivisionError : print ( 'Ceci est une division par z\u00e9ro !' ) Le try permet d'essayer le code qui suit. Le except permet d'attraper en filtrant s'il y a des exceptions et de traiter l'erreur si besoin. Toutes les exceptions h\u00e9ritent de Exception donc le code ci-dessous fonctionne, mais n'est pas recommand\u00e9 car il masque d'autres erreurs : 1 2 3 4 try : 10 / 2 except Exception : print ( 'Ceci est une division par z\u00e9ro !' ) On peut imaginer faire une fonction qui divise deux nombres et affiche le r\u00e9sultat dans la QgsMessageBar de QGIS, sans tenir compte de la division par z\u00e9ro : 1 2 3 4 5 def diviser ( a , b ): result = a / b iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 0 ) En tenant compte d'une possible erreur lors de l'op\u00e9ration math\u00e9matique : 1 2 3 4 5 6 7 8 9 def diviser ( a , b ): try : result = a / b except ZeroDivisionError : iface . messageBar () . pushMessage ( 'Division par 0' , f ' { a } / { b } est impossible' , Qgis . Warning ) else : iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 2 ) \u00c9videment, on peut v\u00e9rifier la valeur de b en amont si c'est \u00e9gal \u00e0 0. Mais ceci est pour pr\u00e9senter le concept des exceptions en Python.","title":"Les exceptions en Python"},{"location":"selection-parcours-entites/#retour-a-lexercice","text":"On souhaite donc savoir si un nombre est transformable en entier, dans le cas de la population (s'il y a NC par exemple) : 1 2 int ( '10' ) int ( 'NC' ) Correction possible de l'exercice : 1 2 3 4 5 6 7 8 9 10 11 12 layer = iface . activeLayer () request = QgsFeatureRequest () # request.setFilterExpression('to_int( \"POPUL\" ) < 1000') request . addOrderBy ( 'NOM' ) request . setSubsetOfAttributes ([ 1 , 4 ]) for feature in layer . getFeatures ( request ): area = feature . geometry () . area () / 1000000 try : population = int ( feature [ 'POPUL' ]) except ValueError : population = 0 print ( ' {commune} : {densite} habitants/km\u00b2' . format ( commune = feature [ 'NOM' ], densite = population / area )) Nous souhaitons enregistrer ces informations dans une vraie table avec un nouveau champ densite_population . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): field = QgsField ( 'densite_population' , QVariant . Double ) petites_communes . addAttribute ( field ) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) QgsProject . instance () . addMapLayer ( petites_communes ) Manipulons d\u00e9sormais la g\u00e9om\u00e9trie en ajoutant le centro\u00efde de la commune dans une colonne latitude et longitude en degr\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): petites_communes . addAttribute ( QgsField ( 'densite_population' , QVariant . Double )) # /!\\ Ajouter les 2 lignes ci-dessous petites_communes . addAttribute ( QgsField ( 'longitude' , QVariant . Double )) petites_communes . addAttribute ( QgsField ( 'latitude' , QVariant . Double )) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) # /!\\ Ajouter les 2 lignes ci-dessous \u00e0 propos de la transformation transform = QgsCoordinateTransform ( QgsCoordinateReferenceSystem ( 2154 ), QgsCoordinateReferenceSystem ( 4326 ), QgsProject . instance ()) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) # /!\\ Ajouter les lignes ci-dessous geom = feature . geometry () # La transformation affecte directement l'objet Python en cours, mais pas l'entit\u00e9 dans la couche geom . transform ( transform ) centroid = geom . centroid () . asPoint () petites_communes . changeAttributeValue ( feature . id (), 6 , centroid . x ()) petites_communes . changeAttributeValue ( feature . id (), 7 , centroid . y ()) QgsProject . instance () . addMapLayer ( petites_communes )","title":"Retour \u00e0 l'exercice"}]}