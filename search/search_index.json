{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Formation PyQGIS","text":""},{"location":"#pre-requis","title":"Pr\u00e9-requis","text":"<p>Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent apprendre l'API Python de QGIS :</p> <ul> <li>Ajout de fonctionnalit\u00e9s \u00e0 QGIS</li> <li>Automatisation de certains traitements</li> <li>Cr\u00e9ation de script</li> <li>Cr\u00e9ation d'algorithme Processing</li> </ul> <p>Pour suivre la formation, il faut :</p> <ul> <li>Avoir QGIS LTR minimum</li> <li>Avoir des connaissances en QGIS bureautique</li> <li>Avoir quelques bases en programmation</li> <li>Avoir un jeu de donn\u00e9es, par exemple :<ul> <li>BD Topo du d\u00e9partement </li> </ul> </li> </ul> <p>Si n\u00e9cessaire, il peut \u00eatre utile d'avoir en plus :</p> <ul> <li>qgis_process</li> <li>QtDesigner pour la partie sur les formulaires ou une extension graphique</li> </ul>"},{"location":"#plan","title":"Plan","text":"<ul> <li>Pr\u00e9sentation<ul> <li>Python dans QGIS</li> <li>Documentation</li> <li>M\u00e9mo Python, sans PyQGIS</li> </ul> </li> <li>Premier pas avec l'API PyQGIS<ul> <li>Console</li> <li>Fonctions &amp; Scripts</li> <li>S\u00e9lection &amp; Parcours</li> </ul> </li> <li>Utilisation simple<ul> <li>Action</li> <li>Expression</li> <li>Formulaire </li> </ul> </li> <li>Utilisation avanc\u00e9e<ul> <li>\u00c9criture de notre classe en POO</li> <li>Script Processing</li> <li>Extension g\u00e9n\u00e9rique</li> <li>Extension graphique</li> <li>Extension Processing</li> <li>Application standalone</li> </ul> </li> <li>Sujets PyQGIS th\u00e9matiques<ul> <li>Migration majeure au sein d'un code Python</li> <li>Interroger une base PostGIS</li> <li>Symbologie</li> </ul> </li> <li>Outils annexes<ul> <li>D\u00e9ploiement d'une extension</li> <li>IDE Python &amp; Git</li> </ul> </li> </ul>"},{"location":"action/","title":"Les actions","text":"<ul> <li>Pour conna\u00eetre le principe des actions dans QGIS, il faut se r\u00e9f\u00e9rer au manuel de QGIS :<ul> <li>https://docs.qgis.org/latest/fr/docs/user_manual/working_with_vector/vector_properties.html#actions-properties</li> </ul> </li> <li>On souhaite pouvoir faire notre propre action pour inverser le sens d'une ligne, par exemple une rivi\u00e8re.</li> <li>Pour la couche lin\u00e9aire :</li> <li>Nous allons utiliser le script ci-dessous pour cr\u00e9er une couche tr\u00e8s simple, mais qui permet de voir la construction     d'une ligne en partant de z\u00e9ro</li> <li>Sinon, pour aller beaucoup plus vite, ajouter la couche <code>HYDROGRAPHIE/COURS_D_EAU.shp</code>     mais on ne voit pas comment construire la g\u00e9om\u00e9trie en partant de rien.</li> <li>Faire un style rapide pour mettre en \u00e9vidence le sens de la ligne \u00e0 l'aide d'une <code>Ligne de symbole</code> dans   l'onglet <code>Symbologie</code> de la couche en question.</li> </ul> <p>Info</p> <p>La couche <code>HYDROGRAPHIE/COURS_D_EAU.shp</code> est de type multilinestring. Nous allons donc prendre en compte ce cas par d\u00e9faut dans la suite de ce tutoriel.</p> <pre><code># Notation pour ajouter des attributs en cr\u00e9ant une couche m\u00e9moire\n# https://docs.qgis.org/latest/fr/docs/pyqgis_developer_cookbook/vector.html#from-an-instance-of-qgsvectorlayer\nriver = QgsVectorLayer('MultiLineString?crs=epsg:2154&amp;field=id:integer&amp;field=name:string(20)&amp;index=yes', 'Rivers', 'memory')\n\nQgsProject.instance().addMapLayer(river)\n\nwith edit(river):\n    # Cette fonction permet de faire des v\u00e9rifications sur les contraintes si n\u00e9cessaires contrairement \u00e0 QgsFeature(fields)\n    feature = QgsVectorLayerUtils.createFeature(river)\n    feature.setAttribute('id', 0)\n    feature.setAttribute('name', 'Une rivi\u00e8re')\n    geom = QgsGeometry.fromMultiPolylineXY(\n    [\n        [QgsPointXY(1, 1), QgsPointXY(2, 2), QgsPointXY(3, 2), QgsPointXY(4, 1)]\n    ])\n    feature.setGeometry(geom)\n    river.addFeature(feature)\n\nextent = river.extent()\ncanvas = iface.mapCanvas()\ncanvas.setExtent(extent)\ncanvas.refresh()\n</code></pre>"},{"location":"action/#les-actions-par-defaut","title":"Les actions par d\u00e9faut","text":"<ul> <li>Dans la fen\u00eatre des propri\u00e9t\u00e9s d'une couche vecteur, aller dans l'onglet <code>Actions</code>.</li> <li>Cliquer sur le bouton <code>Cr\u00e9er les actions par d\u00e9faut</code>.</li> <li>Observons quelques actions pour comprendre le fonctionnement ainsi que les scopes/champs d'application   des actions.</li> </ul> <p>Info</p> <p>Selon le champ d'application de l'action, il y a plus ou moins de variables. Il faut regarder les infobulles.</p>"},{"location":"action/#notre-propre-action","title":"Notre propre action","text":"<ul> <li>Commen\u00e7ons un nouveau par un script Python classique, laissons de c\u00f4t\u00e9 le concept des actions pour le moment.</li> <li>\u00c9crire une fonction qui se charge d'inverser une ligne. Cette fonction prend en param\u00e8tre la couche   vecteur et une liste d'ID des entit\u00e9s.</li> <li>Il faut penser \u00e0 v\u00e9rifier le type exact de g\u00e9om\u00e9trie de nos lignes, dans les propri\u00e9t\u00e9s de la couche.</li> </ul> <pre><code>def reverse_geom(layer: QgsVectorLayer, ids: int):\n    \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer.\n\n    ids est l'identifiant d'une entit\u00e9 qu'il faut inverser.\n    \"\"\"\n    pass\n</code></pre> <p>Le mot-cl\u00e9 <code>pass</code> est juste une instruction Python qui ne fait strictement rien, mais qui permet de rendre une ligne de code valide en respectant l'indentation. Vous pouvez la supprimer d\u00e8s qu'il y a du code.</p> <p>Il faut :</p> <ul> <li>R\u00e9cup\u00e9rer la g\u00e9om\u00e9trie, tenir compte qu'il s'agit d'une multi-ligne</li> <li>Appliquer la fonction <code>reverse</code> en Python pour inverser une liste</li> <li>Utiliser une session d'\u00e9dition</li> <li>Utiliser <code>QgsVectorLayer.changeGeometry()</code> pour changer la g\u00e9om\u00e9trie d'un objet existant !</li> </ul> <p>On peut appeler notre nouvelle fonction \u00e0 l'aide du code suivant :</p> <pre><code>layer = iface.activeLayer()\n# Une action ne s'effectuant que sur une seule entit\u00e9, on peut utiliser [0]\nids = layer.selectedFeatureIds()[0]\n\nreverse_geom(layer, ids)\n</code></pre> Afficher la solution <pre><code>def reverse_geom(layer, ids):\n    \"\"\" Inverser le sens d'une entit\u00e9 dans la couche layer.\n\n    ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser.\n    \"\"\"\n    feature = layer.getFeature(ids)\n    geom = feature.geometry()\n    lines = geom.asMultiPolyline()\n    for line in lines:\n        line.reverse()\n    new_geom = QgsGeometry.fromMultiPolylineXY(lines)\n    with edit(layer):\n        layer.changeGeometry(feature.id(), new_geom)\n\nlayer = iface.activeLayer()\nids = layer.selectedFeatureIds()[0]\n\nreverse_geom(layer, ids)\n</code></pre> <p>Incorporons ce code dans une action et adaptons-le l\u00e9g\u00e8rement :</p> <p></p> <pre><code>def reverse_geom(layer, ids):\n    \"\"\" Inverser le sens d'une entit\u00e9 dans la couche layer.\n\n    ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser.\n    \"\"\"\n    feature = layer.getFeature(ids)\n    geom = feature.geometry()\n    lines = geom.asMultiPolyline()\n    for line in lines:\n        line.reverse()\n    new_geom = QgsGeometry.fromMultiPolylineXY(lines)\n    with edit(layer):\n        layer.changeGeometry(feature.id(), new_geom)\n\nlayer = QgsProject.instance().mapLayer('[% @layer_id %]')\nreverse_geom(layer, [% @id %])\n</code></pre> <p>On peut d\u00e9sormais cliquer sur une ligne pour automatiquement inverser une ligne.</p> <p>Le code de l'action est enregistr\u00e9 dans le style QML de la couche vecteur. Il peut donc \u00eatre partag\u00e9 avec  d'autres utilisateurs qui ne connaissent pas Python.</p>"},{"location":"action/#informer-lutilisateur","title":"Informer l'utilisateur","text":"<p>Si on souhaite informer l'utilisateur que cela s'est bien pass\u00e9, on peut utiliser la \"message bar\" :</p> <pre><code>from qgis.utils import iface\n\niface.messageBar().pushMessage('Inversion', 'La rivi\u00e8re est invers\u00e9e', Qgis.Success)\n</code></pre> <p>Note, contrairement \u00e0 la console o\u00f9 QGIS importait pour nous directement la variable <code>iface</code>, dans ce contexte, il faut le faire manuellement.</p>"},{"location":"action/#astuce-pour-stocker-le-code-dune-action-dans-une-extension-qgis","title":"Astuce pour stocker le code d'une action dans une extension QGIS","text":"<p>Tip</p> <p>Pour suivre cette partie, il faut la plupart du temps une extension par exemple, voir l'autre chapitre, afin de stocker le code Python.</p> <p>Pour \u00e9viter d'avoir du code les propri\u00e9t\u00e9s de la couche QGIS, on peut r\u00e9duire le code Python au minimum en faisant dans le c\u0153ur de l'action uniquement l'import d'une fonction et de lancer son ex\u00e9cution.</p> <p>Exemple du code d'une action dans l'extension QuickOSM lors de l'ex\u00e9cution d'une requ\u00eate rapide :</p> <pre><code>from QuickOSM.core.actions import Actions\nActions.run(\"josm\",\"[% \"full_id\" %]\")\n</code></pre> <p>Ou alors l'extension RAEPA :</p> <pre><code>from qgis.utils import plugins\nplugins['raepa'].run_action(\"nom_de_laction\", params)\n</code></pre>"},{"location":"action/#avec-processing","title":"Avec Processing","text":"<p>Dans le chapitre Processing, nous verrons comment int\u00e9grer un algorithme Processing dans une action.</p>"},{"location":"console/","title":"Introduction \u00e0 la console Python","text":""},{"location":"console/#donnees","title":"Donn\u00e9es","text":"<p>Nous allons utiliser un d\u00e9partement de la BDTopo.</p> <p>Tip</p> <p>Les DROM-COM ou le Territoire de Belfort (90) sont assez l\u00e9gers.</p> <ol> <li>Renommer le dossier <code>BDT_3-3_SHP_LAMB93_D0ZZ-EDYYYY-MM-DD</code> en <code>BD_TOPO</code> afin de simplifier les corrections.</li> </ol>"},{"location":"console/#configurer-le-projet","title":"Configurer le projet","text":"<ul> <li>Commencer un nouveau projet et enregistrer le dans un dossier.</li> <li>\u00c0 c\u00f4t\u00e9 du projet <code>qgs</code> ou <code>qgz</code>, ajouter le dossier provenant de la BDTopo, le dossier <code>BD_TOPO</code> ci-dessus.</li> </ul> <pre><code>.\n\u251c\u2500\u2500 BD_TOPO\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ADMINISTRATIF\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ADRESSES\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 BATI\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 HYDROGRAPHIE\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LIEUX_NOMMES\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 OCCUPATION_DU_SOL\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SERVICES_ET_ACTIVITES\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 TRANSPORT\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ZONES_REGLEMENTEES\n\u2514\u2500\u2500 formation.qgs\n</code></pre>"},{"location":"console/#manipulation-dans-la-console","title":"Manipulation dans la console","text":""},{"location":"console/#rappel-sur-la-poo","title":"Rappel sur la POO","text":"<p>La Programmation Orient\u00e9e Objet, POO :</p> <ul> <li>la POO permet de mieux mod\u00e9liser la r\u00e9alit\u00e9 en concevant des mod\u00e8les d'objets, les classes</li> <li>les objets sont cr\u00e9\u00e9s ind\u00e9pendamment les uns des autres, gr\u00e2ce \u00e0 l'encapsulation, m\u00e9canisme qui permet d'embarquer leurs propri\u00e9t\u00e9s</li> <li>les classes permettent d'\u00e9viter au maximum l'emploi des variables globales</li> </ul> <p>Imaginons le cas d'une voiture.</p> <p>Une voiture est un objet, on peut en cr\u00e9er une instance. Sur cette instance, on a des \"propri\u00e9t\u00e9s\" comme :</p> <ul> <li>la couleur de la voiture</li> <li>le nombre de chevaux</li> <li>le nombre de portes</li> <li>la marque</li> <li>le propri\u00e9taire (qui peut \u00eatre un autre objet \"Personne\")</li> </ul> <p>Sur cette instance, on a des \"m\u00e9thodes\" :</p> <ul> <li>avancer</li> <li>reculer</li> <li>tourner \u00e0 gauche</li> <li>verrouiller les portes</li> <li>activer les clignotants</li> </ul> classDiagram class Voiture{     +Color Couleur     +Int NbPuissance     +Int NbPortes     +String Marque     +Personne Proprietaire     +avancer() bool     +reculer(amount) int     +tourner(direction) bool } <p>On peut continuer en \u00e9crivant une classe qui va contenir une Personne :</p> classDiagram class Personne{     +String Nom     +String Prenom     +Date DateNaissance     +Date DatePermisB }"},{"location":"console/#pratique","title":"Pratique","text":""},{"location":"console/#documentation","title":"Documentation","text":"<ul> <li>Dans QGIS, <code>Plugins</code> -&gt; <code>Console Python</code></li> <li> <p>QGIS nous donne acc\u00e8s au projet actuel via la classe <code>QgsProject</code></p> <ul> <li>https://qgis.org/api/classQgsProject.html</li> <li>https://qgis.org/pyqgis/3.34/core/QgsProject.html</li> </ul> </li> <li> <p>Dans la documentation (en C++ surtout), on remarque plusieurs sections :</p> <ul> <li>Public types</li> <li>Public slots</li> <li>Signals</li> <li>Public Member Functions</li> <li>Static Public Member Functions</li> </ul> </li> <li>Nous verrons progressivement ces diff\u00e9rentes sections.</li> <li>En haut de la documentation, il y a une explication sur le cas particulier de <code>QgsProject.instance()</code>.</li> <li>Afin de trouver le chemin de notre projet, recherchons <code>filepath</code>, afin de trouver une m\u00e9thode <code>absoluteFilePath</code>: <pre><code>project = QgsProject.instance()\nproject.absoluteFilePath()\n</code></pre></li> <li>Ajoutons un titre \u00e0 notre projet. Dans l'interface graphique, cela se passe dans les propri\u00e9t\u00e9s de notre projet.   Il y a donc des chances que cela soit aussi dans la classe QgsProject</li> <li>Recherchons donc <code>title</code> dans la page : <code>setTitle</code> dans la classe   QgsProject.</li> </ul> <p>Warning</p> <p>Il est important de bien pouvoir lire la signature des m\u00e9thodes :</p> <ul> <li>La m\u00e9thode <code>title</code> retourne une QString (<code>str</code> en Python) et ne prend pas de param\u00e8tre.</li> <li>La m\u00e9thode <code>setTitle</code> retourne rien, (<code>void</code>, en CPP et <code>None</code> en Python) mais elle prend un param\u00e8tre, une str.</li> </ul> <ul> <li>Nous souhaitons d\u00e9sormais changer la couleur de fond du projet.<ul> <li>Recherchons <code>background</code></li> <li>Nous allons devoir utiliser aussi la classe QColor CPP, QColor PySide2.</li> </ul> </li> </ul> Afficher la solution <pre><code>color = QColor(\"#00A2FF\")\nQgsProject.instance().setBackgroundColor(color)\n</code></pre>"},{"location":"console/#manipulation-en-console-pour-ajouter-une-couche-shapefile","title":"Manipulation en console pour ajouter une couche Shapefile","text":"<ul> <li>Objectif, ajouter une couche vecteur contenu dans un dossier fils :<ul> <li>Exemple <code>BD_TOPO/ADMINISTRATIF/COMMUNE.shp</code> :</li> <li>Recherchons dans l'API de <code>QgsProject</code> le fichier actuel du projet, \u00e0 l'aide <code>filepath</code>.</li> <li>L'utilisation de <code>home</code> est un peu diff\u00e9rente, dans QGIS on peut d\u00e9finir un r\u00e9pertoire diff\u00e9rent pour la racine des donn\u00e9es.</li> <li>Nous allons utiliser l'objet <code>Path</code> pour manipuler les fichiers/dossiers.</li> <li>Objet Path</li> </ul> </li> </ul> <p>Note</p> <p>L'utilisation de l'objet <code>Path</code> est tr\u00e8s habituelle, mais on rencontre aussi l'utilisation des fonctions du module <code>os.path</code> comme <code>os.path.join</code>... On rencontre son utilisation dans plusieurs tutoriels/solutions/forums.</p>"},{"location":"console/#solution-etape-par-etape","title":"Solution \u00e9tape par \u00e9tape","text":"<p>Pour r\u00e9cup\u00e9rer le projet en cours <pre><code>project = QgsProject.instance()\n</code></pre></p> <p>Pour passer du chemin <code>str</code> de QGIS \u00e0 un objet <code>Path</code> et directement appeler la propri\u00e9t\u00e9 <code>parent</code> pour obtenir le dossier : <pre><code>racine = Path(project.absoluteFilePath()).parent\n</code></pre></p> <p>On peut joindre notre BDTopo, en donnant plusieurs param\u00e8tres \u00e0 <code>joinpath</code> : <pre><code>chemin = racine.joinpath('BD_TOPO', 'ADMINISTRATIF')\nfichier_shape = chemin.joinpath('COMMUNE.shp')\n</code></pre></p> <p>Il ne faut pas h\u00e9siter \u00e0 v\u00e9rifier au fur et \u00e0 mesure avec des <code>print</code> :</p> <pre><code>print(racine)\nprint(racine.is_dir())\nprint(racine.is_file())\nprint(fichier_shape.exists())\nprint(fichier_shape.is_file())\n</code></pre> <p>Tip</p> <p>Tant que l'on est en console, on n'a pas besoin de faire <code>print</code>, la console le fait pour nous automatiquement. On peut se contenter de <code>fichier_shape.exists()</code>.</p> <p>Si tout est bon pour le chemin, charger la couche vecteur \u00e0 l'aide de <code>iface</code> qui est une instance de <code>QgisInterface</code> CPP/PyQGIS (et non pas QgsInterface), en utilisant la m\u00e9thode <code>addVectorLayer</code>.</p> <p>Attention, QGIS, \u00e9tant \u00e9crit en C++, ne connait pas l'usage de <code>Path</code>, il faut repasser par une cha\u00eene de caract\u00e8re avec l'aide de <code>str</code> :</p> <pre><code>communes = iface.addVectorLayer(str(fichier_shape), 'communes', 'ogr')\nprint(communes)\n</code></pre> <p>Charger la couche autrement \u00e0 l'aide du constructeur <code>QgsVectorLayer</code> (conseill\u00e9)</p> <pre><code>communes = QgsVectorLayer(str(fichier_shape), 'communes', 'ogr')\n# communes.isValid()\nQgsProject.instance().addMapLayer(communes)\n</code></pre> Afficher la solution compl\u00e8te avec <code>pathlib</code> <pre><code>from pathlib import Path\nproject = QgsProject.instance()\nracine = Path(project.absoluteFilePath()).parent\nchemin = racine.joinpath('BD_TOPO', 'ADMINISTRATIF')\nfichier_shape = chemin.joinpath('COMMUNE.shp')\n# fichier_shape.is_file()\ncommunes = QgsVectorLayer(str(fichier_shape), 'communes', 'ogr')\n# communes.isValid()\nQgsProject.instance().addMapLayer(communes)\n</code></pre> Afficher \"l'ancienne\" solution compl\u00e8te avec <code>os.path</code> <pre><code>from os.path import join, isfile, isdir\n\nproject = QgsProject.instance()\n\nracine = project.homePath()\nchemin = join(racine, 'BD_TOPO', 'ADMINISTRATIF')\nfichier_shape = join(chemin, 'COMMUNE.shp')\ncommunes = QgsVectorLayer(fichier_shape, 'communes', 'ogr')\ncommunes.isValid()\nQgsProject.instance().addMapLayer(communes)\n</code></pre> <p>Success</p> <p>Bien jou\u00e9 si vous avez votre couche des communes !</p>"},{"location":"console/#decouverte-des-methodes-sur-notre-objet-communes","title":"D\u00e9couverte des m\u00e9thodes sur notre objet <code>communes</code>","text":"<p>Notre variable <code>communes</code> est une instance de <code>QgsVectorLayer</code>.</p> <p>API QgsVectorLayer C++, API QgsVectorLayer Python</p> <p>\u00c0 l'aide de la documentation, recherchons :</p> <ul> <li>le nombre d'entit\u00e9s, (indice : <code>count</code>, <code>feature</code>, <code>featureCount</code>)</li> <li>comment ouvrir et fermer une session d'\u00e9dition (indice : <code>editing</code>, <code>start</code> et ne pas h\u00e9siter \u00e0 lire la docstring)</li> <li>le type de g\u00e9om\u00e9trie, mot cl\u00e9 <code>geometry</code>, <code>type</code>, <code>geometryType</code></li> </ul> <p>Info</p> <p>L'API est en train de changer depuis QGIS 3.30 environ, concernant l'usage et l'affichage des \u00e9num\u00e9rations. Par exemple pour <code>geometryType</code>.</p> <pre><code>communes.geometryType() == QgsWkbTypes.PolygonGeometry\ncommunes.geometryType() == QgsWkbTypes.PointGeometry\n</code></pre> <p>Pour la g\u00e9om\u00e9trie, toujours utiliser l'\u00e9num\u00e9ration et non pas le chiffre, ce n'est pas compr\u00e9hensible (QGIS &lt; 3.30)</p> <ul> <li>Essayons d\u00e9sormais de chercher :<ul> <li>son nom : <code>name</code></li> <li>les seuils de visibilit\u00e9 de la couche min et max (<code>scale</code>, <code>minimum</code>, <code>maximum</code>)</li> </ul> </li> </ul> <p>On ne les trouve pas dans la page <code>QgsVectorLayer</code> ! Pour cela, il faut faire r\u00e9f\u00e9rence \u00e0 la notion d'h\u00e9ritage en Programmation Orient\u00e9e Objet.</p>"},{"location":"console/#heritage","title":"H\u00e9ritage","text":"<p>Il faut bien regarder les diagrammes en haut de la documentation :</p> <p>API QgsVectorLayer C++, API QgsVectorLayer Python</p> classDiagram class QgsMapLayer{     +name() str     +id() str     +crs() QgsCoordinateReferenceSystem     +maximumScale() double     +minimumScale() double     +autreFonctionsPourToutesLesCouches() }  class QgsVectorLayer{     +featureCount() int     +startEditing() bool     +commitChanges() bool     +autreFonctionsPourUneCoucheVecteur() }  class QgsRasterLayer{     +bandCount() int     +largeur int     +hauteur int     +autreFonctionsPourUneCoucheRaster() }  QgsMapLayer &lt;-- QgsVectorLayer QgsMapLayer &lt;-- QgsRasterLayer <p>L'objet <code>QgsVectorLayer</code> h\u00e9rite de <code>QgsMapLayer</code> qui est une classe commune avec <code>QgsRasterLayer</code>.</p> <p>API QgsMapLayer C++, API QgsMapLayer Python</p> <p>Tip</p> <p>On peut d\u00e9sormais regarder la documentation CPP de QGIS et Qt pour voir l'ensemble des membres, y compris les membres h\u00e9rit\u00e9s. QgsVectorLayer CPP ou QComboBox</p> <p>Regardons la fonction <code>isinstance</code> qui permet de tester si un objet est une instance d'une classe :</p> <pre><code>isinstance(communes, QgsVectorLayer)\nTrue\nisinstance(communes, QgsRasterLayer)\nFalse\nisinstance(communes, QgsMapLayer)\nTrue\n</code></pre> <ul> <li>Objectif, ne pas afficher la couche commune pour une \u00e9chelle plus petite que le <code>1:2 000 000</code>.</li> </ul> <pre><code>communes.setMinimumScale(2000000)\ncommunes.setMaximumScale(500000)\ncommunes.setScaleBasedVisibility(True)\n# communes.triggerRepaint()\n</code></pre> <p>Important</p> <p>Un raccourci \u00e0 savoir, dans la console : <pre><code>iface.activeLayer()\n</code></pre></p> <p>Cela retourne la couche <code>QgsMapLayer</code> active dans la l\u00e9gende !</p>"},{"location":"console/#code","title":"Code","text":"<p>Petit r\u00e9capitulatif \u00e0 tester pour voir si cela fonctionne correctement !</p> <pre><code>from pathlib import Path\ndossier = 'BD_TOPO'\nthematique = 'ADMINISTRATIF'\ncouche = 'COMMUNE'\n\nproject = QgsProject.instance()\nracine = Path(project.absoluteFilePath()).parent\nchemin = racine.joinpath(dossier, thematique)\nfichier_shape = chemin.joinpath(f'{couche}.shp')\n\nprint(layer.featureCount())\nprint(layer.crs().authid())\nprint('Est en m\u00e8tre : {}'.format(layer.crs().mapUnits() ==  QgsUnitTypes.DistanceMeters))\nprint(layer.name())\nlayer.setScaleBasedVisibility(True)\nlayer.setMaximumScale(500000)\nlayer.setMinimumScale(2000000)\nlayer.triggerRepaint()\n</code></pre>"},{"location":"console/#transition-vers-le-script-avec-le-parcourir-des-entites","title":"Transition vers le script, avec le parcourir des entit\u00e9s","text":"<p>Ajouter \u00e9galement la couche <code>ARRONDISSEMENT</code> et s\u00e9lectionner l\u00e0.</p> <p>On souhaite d\u00e9sormais it\u00e9rer sur les polygones et les faire clignoter depuis la console. Nous allons donc avoir besoin de la m\u00e9thode <code>getFeatures()</code> qui fait partie de <code>QgsVectorLayer</code>.</p> <pre><code>layer = iface.activeLayer()\nfeatures = layer.getFeatures()\nfeatures\nfeature = QgsFeature()\nfeatures.nextFeature(feature)\niface.mapCanvas().flashFeatureIds(layer, [feature.id()])\n</code></pre> <p>Note, nous pouvons concat\u00e9ner les deux derni\u00e8res lignes \u00e0 l'aide du caract\u00e8re <code>;</code> pour que cela soit plus pratique.</p> <p>Ce code est plus pour la partie \"amusante\" pour montrer les limites de la console. Nous allons d\u00e9sormais utiliser un script Python dans le prochain chapitre.</p> <p>Petite chose suppl\u00e9mentaire avant de passer aux scripts, on souhaite d\u00e9sormais afficher le nom des arrondissements \u00e0 l'aide d'une boucle <code>for</code>.</p> <pre><code>layer = iface.activeLayer()\nfor feature in layer.getFeatures():\n    # On peut traiter l'entit\u00e9 courante gr\u00e2ce \u00e0 la variable \"feature\".\n    # Pour acc\u00e9der \u00e0 un attribut en particulier, on peut y acc\u00e9der avec des crochets.\n    pass\n</code></pre> <p>Noter l'apparition de <code>...</code> au lieu de <code>&gt;&gt;&gt;</code> apr\u00e8s avoir \u00e9crit la premi\u00e8re ligne du <code>for</code>. Il faut faire une indentation obligatoire !</p> <p>Pour afficher un attribut, on peut faire <code>print(feature['NOM_ARR'])</code> pour afficher le contenu de l'attribut <code>NOM_ARR</code>.</p>"},{"location":"documentation/","title":"Documentation et liens utiles","text":"<ul> <li>QGIS est compos\u00e9 de plusieurs centaines de classes \u00e9crites en C++. La plupart de ces classes (et donc des fonctions) sont accessibles \u00e0 travers un API en Python. Comme il n'est pas possible de m\u00e9moriser enti\u00e8rement l'API de QGIS, il est n\u00e9cessaire de conna\u00eetre la documentation et comment rechercher des informations.</li> <li>QGIS 3 repose sur la librairie Qt version 5 pour l'interface graphique et sur Python version 3.</li> <li>Toutes les classes QGIS commencent par <code>Qgs</code> et toutes les classes Qt commencent par <code>Q</code>.</li> </ul> <p>Tip</p> <p>QGIS est en train de migrer vers la librairie Qt version 6. QGIS 3.42 va certainement avoir un support pour Qt6 et pouvoir faire des premiers tests PyQGIS. Lire le chapitre sur les migrations majeures de PyQGIS.</p> <p>Voici une liste de liens pour la documentation, tous en anglais, sauf le cookbook :</p> <ul> <li>https://docs.qgis.org qui regroupe :<ul> <li>Le Python Cookbook https://docs.qgis.org/latest/fr/docs/pyqgis_developer_cookbook (recette de cuisine)</li> <li>L'API C++ https://qgis.org/api/3.34/</li> <li>L'API Python https://qgis.org/pyqgis/3.34/</li> </ul> </li> <li>Documentation de l'API Qt</li> <li>Documentation de Python<ul> <li>Le module Pathlib, \"nouveau\" module pour manipuler des chemins</li> <li>Le module os.path, module \"historique\" pour manipuler des chemins</li> </ul> </li> </ul> <p>Voici une liste non exhaustive de blog-post utiles pour manipuler PyQGIS, tous en anglais :</p> <ul> <li>Cours PyQGIS de SpatialThoughts</li> <li>Optimisation des couches vecteurs</li> <li>Parcourir la l\u00e9gende en 3 parties</li> <li>Plugin Processing</li> <li>Workshop sur les expressions en Python</li> </ul> <p>Autre lien pour l'apprentissage de Python (sans QGIS) en fran\u00e7ais :</p> <ul> <li>Docteur Python avec son propre m\u00e9mo, tr\u00e8s complet</li> <li>https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python</li> </ul> <p>Tip</p> <p>QGIS 3.42 va int\u00e9grer un outil pour avoir l'aide d'une classe directement depuis une variable. Voir la d\u00e9mo de QGIS 3.42.</p>"},{"location":"ecriture-classe-poo/","title":"\u00c9criture de notre classe en POO","text":""},{"location":"ecriture-classe-poo/#notion-sur-la-poo-en-python","title":"Notion sur la POO en Python","text":"<p>Le framework Processing utilise le concept de la Programmation Orient\u00e9e Objet. Il existe un tutoriel sur le site d'OpenClassRooms sur le sujet.</p> <p>Mais depuis le d\u00e9but de la formation, nous l'utilisons sans trop le savoir. Les objets <code>Qgs*</code>, comme <code>QgsVectorLayer</code> utilisent le principe de la POO.</p> <p>On a pu cr\u00e9er des objets QgsVectorLayer en appelant son constructeur :</p> <pre><code>from qgis.core import QgsVectorLayer\n\nlayer = QgsVectorLayer(\"C:/chemin/vers/un/fichier.gpkg|layername=communes\", \"communes\", \"ogr\")\n</code></pre> <p>et ensuite, on a pu appeler des m\u00e9thodes sur cet objet, comme :</p> <pre><code>layer.setName(\"Communes\")\nlayer.name()  # Retourne \"Communes\"\n</code></pre> <p>Tip</p> <p>Vous pouvez relire le passage sur la POO en d\u00e9but de formation.</p>"},{"location":"ecriture-classe-poo/#exemple","title":"Exemple","text":"<p>Nous allons faire un \"tr\u00e8s\" petit exemple rapide. \u00c9crivons notre premier jeu vid\u00e9o en console ! \ud83c\udfae</p> <pre><code>from time import sleep\n\nMAX_ENERGIE = 20\n\n\nclass Personnage:\n\n    \"\"\" Classe repr\u00e9sentant un personnage du jeu vid\u00e9o. \"\"\"\n\n    def __init__(self, un_nom, energie=MAX_ENERGIE):\n        \"\"\" Constructeur. \"\"\"\n        self.nom = un_nom\n        self.energie = energie\n\n    def marcher(self):\n        \"\"\" Permet au personnage de marcher.\n\n        Cela d\u00e9pense de l'\u00e9nergie.\n        \"\"\"\n        cout = 5\n        if self.energie &gt;= cout:\n            print(f\"{self.nom} marche.\")\n            self.energie -= cout\n        else:\n            print(f\"{self.nom} ne peut pas marcher car il n'a pas assez d'\u00e9nergie.\")\n\n    def courir(self):\n        \"\"\" Permet au personnage de courir.\n\n        Cela d\u00e9pense de l'\u00e9nergie.\n        \"\"\"\n        cout = 10\n        if self.energie &gt;= cout:\n            print(f\"{self.nom} court.\")\n            self.energie -= cout\n        else:\n            print(f\"{self.nom} ne peut pas courir car il n\\'a pas assez d\\'\u00e9nergie.\")\n\n    def dormir(self):\n        \"\"\" Permet au personnage de dormir et restaurer le niveau maximum d'\u00e9nergie.\"\"\"\n        print(f\"{self.nom} dort et fait le plein d'\u00e9nergie.\")\n        for i in range(2):\n            print('...')\n            sleep(1)\n        self.energie = MAX_ENERGIE\n\n    def manger(self):\n        \"\"\" Permet au personnage de manger et d'augmenter de 10 points le niveau d'\u00e9nergie.\"\"\"\n        energie = 10\n        print(f\"{self.nom} mange et r\u00e9cup\u00e8re {energie} points d'\u00e9nergie.\")\n        if self.energie &lt;= MAX_ENERGIE - energie:\n            self.energie += energie\n        else:\n            self.energie = MAX_ENERGIE\n\n    def __repr__(self):\n        return f\"&lt;Personnage: '{self.nom}' avec {self.energie} points d'\u00e9nergie&gt;\"\n</code></pre>"},{"location":"ecriture-classe-poo/#utilisation-de-notre-classe","title":"Utilisation de notre classe","text":"<ul> <li><code>dir(a)</code> est une fonction indique les \"membres\" de notre variable Personnage.</li> <li><code>help(a)</code> affiche la documentation de notre classe</li> <li><code>__dict__</code> est une propri\u00e9t\u00e9 qui donne les valeurs des attributs de l'instance.</li> </ul> <pre><code>a = Personnage('Dark Vador')\ndir(a)\nhelp(a)\n</code></pre> <p>Que remarquons-nous ?</p> Solution <pre><code>a = Personnage('Dark Vador')\na.courir()\na.dormir()\na.manger()\nprint(a)\n</code></pre> <p>Afficher le nom du personnage (et juste son nom, pas la phrase de pr\u00e9sentation)</p>"},{"location":"ecriture-classe-poo/#ajouter-dautres-methodes","title":"Ajouter d'autres m\u00e9thodes","text":"<p>Ajoutons une m\u00e9thode <code>dialoguer</code> pour discuter avec un autre personnage.</p> <p>Tip</p> <pre><code>def dialoguer(self, autre_personnage):\n    \"\"\" Permet de dialoguer avec un autre personnage. \"\"\"\n    pass\n</code></pre> <ol> <li>\u00c9crire le code la fonction \u00e0 l'aide d'un <code>print</code> pour commencer disant que <code>X dialogue avec Y</code>.</li> <li>V\u00e9rifier le niveau d'\u00e9nergie avant de dialoguer ! Difficile de discuter si on n'a plus d'\u00e9nergie \ud83d\ude09</li> <li>Garder son code \u00e0 gauche, on peut utiliser une instruction <code>return</code></li> </ol> <p>Nous pouvons d\u00e9sormais utiliser le constructeur afin de cr\u00e9er deux instances de notre classe.</p> <pre><code>b = Personnage('Luke')\nb.dialoguer(a)\n</code></pre> Solution pour la m\u00e9thode <code>dialoguer()</code> <pre><code>def dialoguer(self, autre_personnage):\n    if self.energie &lt;= 0:\n        print(f\"{self.nom} ne peut pas dialoguer car il n'a pas assez d'\u00e9nergie.\")\n        return\n\n    print(f\"{self.nom} dialogue avec {autre_personnage.nom} et ils \u00e9changent des informations secr\u00e8tes\")\n</code></pre> <p>Continuons notre classe pour la gestion de son inventaire. Admettons que notre personnage puisse ramasser des objets afin de les mettre dans son sac \u00e0 dos.</p> <ol> <li>Il va falloir ajouter une nouvelle propri\u00e9t\u00e9 \u00e0 notre classe de type <code>list</code> que l'on peut nommer <code>inventaire</code>. Par    d\u00e9faut, son inventaire sera vide.</li> <li>Ajoutons 3 m\u00e9thodes : <code>ramasser</code>, <code>deposer</code> et <code>utiliser</code>. Pour le moment, pour faciliter l'exercice, utilisons une    cha\u00eene de caract\u00e8re pour d\u00e9signer l'objet. Ces m\u00e9thodes vont interagir avec notre <code>inventaire</code> \u00e0 l'aide des m\u00e9thodes    <code>remove()</code>, <code>append()</code> que l'on trouve sur une liste.</li> <li>Pour les m\u00e9thodes <code>deposer</code> et <code>utiliser</code>, nous pouvons avoir \u00e0 cr\u00e9er une autre m\u00e9thode priv\u00e9e afin de v\u00e9rifier    l'existence de l'objet dans l'inventaire. Par convention, nous pr\u00e9fixons la m\u00e9thode par <code>_</code> comme <code>_est_dans_inventaire</code>    afin de signaler que c'est une m\u00e9thode dite priv\u00e9e. L'utilisation de cette m\u00e9thode priv\u00e9e est uniquement \u00e0 titre    p\u00e9dagogique, on peut vouloir exposer la m\u00e9thode <code>est_dans_inventaire</code>. Cette m\u00e9thode doit renvoyer un bool\u00e9en.</li> <li>Ajoutons des commentaires et/ou des docstrings, CF m\u00e9mo Python. On peut utiliser la m\u00e9thode <code>help</code>.</li> <li> <p>Pensons aussi annotations Python</p> </li> <li> <p>Refaire la commande <code>help(a)</code> pour voir le r\u00e9sultat final \ud83d\ude09</p> </li> </ol> <p>Info</p> <p>Il est important de comprendre que la POO permet de construire une sorte de bo\u00eete opaque du point de vue de l'utilisateur de la classe. Un peu comme une voiture, elles ont toutes un capot et une p\u00e9dale d'acc\u00e9l\u00e9ration. L'appui sur l'acc\u00e9l\u00e9rateur d\u00e9clenche plusieurs m\u00e9canismes \u00e0 l'int\u00e9rieur de la voiture, mais du point de vue utilisateur, c'est plut\u00f4t simple.</p> <p>Tip</p> <p>On peut vite imaginer d'autres classes, comme <code>Arme</code>, car ramasser un bout de bois ou un sabre laser n'a pas le m\u00eame impact lors de son utilisation dans un combat. Le d\u00e9g\u00e2t qu'inflige une arme sur le niveau d'\u00e9nergie de l'autre personnage est une propri\u00e9t\u00e9 de l'arme en question et du niveau du personnage.</p>"},{"location":"ecriture-classe-poo/#des-idees-pour-continuer-plus-loin","title":"Des id\u00e9es pour continuer plus loin","text":"<p>Des jeux en Python dans QGIS :</p> <ul> <li>Une vid\u00e9o du jeu morpion</li> <li>Le jeu Snake</li> </ul> <p>Ou pour le fun avec des expressions :</p> <ul> <li>Faire un \"dessin anim\u00e9\"</li> <li>Faire un graphique anim\u00e9</li> </ul>"},{"location":"ecriture-classe-poo/#solution","title":"Solution","text":"<p>Sur la classe Personnage ci-dessus :</p> <pre><code>def _est_dans_inventaire(self, un_objet: str) -&gt; bool:\n    \"\"\" Fonction \"interne\" pour tester si un objet est dans l'inventaire. \"\"\"\n    # On ne souhaite pas qu'un autre personnage puis v\u00e9rifier le contenu d'un inventaire d'un autre.\n    # Il faut plut\u00f4t lui demander :)\n    # Note cette m\u00e9thode n'est pas dans le help()\n    return un_objet in self.inventaire\n\ndef ramasser(self, un_objet: str) -&gt; bool:\n    \"\"\" Ramasser un objet et le mettre dans l'inventaire.\n\n    Retourne True si l'action est OK\n    \"\"\"\n    print(f\"{self.nom} ramasse {un_objet} et le met dans son inventaire.\")\n    self.inventaire.append(un_objet)\n    return True\n\ndef utiliser(self, un_objet: str) -&gt; bool:\n    \"\"\" Utiliser un objet s'il est disponible avant dans l'inventaire.\n\n    Retourne True si l'action est OK\n    \"\"\"\n    if self._est_dans_inventaire(un_objet):\n        print(f\"{self.nom} utilise {un_objet}\")\n        return True\n\n    print(f\"{self.nom} ne poss\u00e8de pas {un_objet}\")\n    return False\n\ndef deposer(self, un_objet: str) -&gt; bool:\n    \"\"\" Retirer un objet de l'inventaire.\n\n    Retourne True si l'action est OK\n    \"\"\"\n    if not self._est_dans_inventaire(un_objet):\n        return False\n\n    print(f\"{self.nom} d\u00e9pose {un_objet}\")\n    self.inventaire.remove(un_objet)\n    return True\n\ndef donner(self, autre_personnage, un_objet: str) -&gt; bool:\n    \"\"\" Donner un objet \u00e0 un autre personnage.\n\n    Retourne True si l'action est OK\n    \"\"\"\n    if not self._est_dans_inventaire(un_objet):\n        return False\n    self.inventaire.remove(un_objet)\n    autre_personnage.inventaire.append(un_objet)\n    print(f\"{autre_personnage.nom} re\u00e7oit {un_objet} de la part de {self.nom} et le remercie \ud83d\udc4d\")\n    return True\n</code></pre>"},{"location":"expression/","title":"Expression","text":"<p>On peut d\u00e9finir sa propre expression QGIS \u00e0 l'aide de Python. Il existe un chapitre dans le  Python cookbook</p> <p>Dans la fen\u00eatre des expressions QGIS, on peut observer la fonction d\u00e9j\u00e0 existante.</p> <p><code>feature</code>, <code>parent</code> et <code>context</code> sont des param\u00e8tres particuliers dans la signature de la fonction. Si QGIS trouve le mot-cl\u00e9, il assigne l'objet correspondant :</p> <ul> <li><code>feature</code> : QgsFeature pour l'entit\u00e9 en cours</li> <li><code>parent</code> : QgsExpression l'expression QGIS en cours</li> <li><code>context</code> : QgsExpressionContext pour le contexte d'ex\u00e9cution   de l'expression</li> </ul>"},{"location":"expression/#exemple","title":"Exemple","text":"<p>On souhaite utiliser l'API de Wikip\u00e9dia afin de r\u00e9cup\u00e9rer la description d'un terme.</p> <p></p> <p>Par exemple, si on cherche le terme <code>Montpellier</code> avec l'API Wikip\u00e9dia :</p> <p>https://fr.wikipedia.org/w/api.php?action=query&amp;titles=Montpellier&amp;prop=description&amp;format=json</p> <p>Il existe plusieurs moyens de faire des requ\u00eates HTTP en Python et/ou PyQGIS. Utilisons la technique Processing avec l'algorithme \"T\u00e9l\u00e9chargeur de fichier\" (graphiquement, il n'est disponible que dans le modeleur) :</p> <pre><code>search = \"montpellier\"\nresults = processing.run(\n    \"native:filedownloader\",\n    {\n        \"URL\": f\"https://fr.wikipedia.org/w/api.php?action=query&amp;titles={search}&amp;prop=description&amp;format=json\",\n        \"OUTPUT\": \"TEMPORARY_OUTPUT\"\n    }\n)\n</code></pre> <p>Tip</p> <p>On peut afficher le panneau de d\u00e9bogage et d\u00e9veloppement de QGIS afin de voir les requ\u00eates HTTP. Il se trouve dans le menu Vue \u25b6 Panneau  \u25b6 D\u00e9bogage et d\u00e9veloppement</p> <p>On va d\u00e9sormais parser le fichier JSON que l'on obtient avec la libraire <code>json</code> afin de r\u00e9cup\u00e9rer la <code>description</code>.</p>"},{"location":"expression/#memo","title":"M\u00e9mo","text":"<p>Pour lire un fichier \u00e0 l'aide d'un \"contexte Python\" qui va ouvrir et fermer le fichier :</p> <pre><code>import json\n\nwith open(\"/mon/fichier.json\") as f:\n    data = json.load(f)\nprint(data)\n</code></pre> <p>Une m\u00e9thode pour r\u00e9cup\u00e9rer la bonne cl\u00e9, dynamiquement :</p> <pre><code>pages = data['query']['pages']\nkey = list(pages.keys())[0]\ndescription = pages[key]['description']\nprint(description)\n</code></pre> <p>Peut-\u00eatre surement plus simple \u00e0 comprendre, avec l'usage d'une boucle <code>for</code></p> <pre><code>description = \"\"\nfor page in pages.values():\n    description = page.get('description')\n\nprint(description)\n</code></pre> Une solution compl\u00e8te pour l'expression QGIS <pre><code>import json\nimport processing\n\n@qgsfunction(args='auto', group='Formation PyQGIS')\ndef wiki_description(search, feature, parent):\n    \"\"\"Permet de r\u00e9cup\u00e9rer la description Wikipedia\n\n    wiki_description('Paris') \u27a1 'capitale de la France'\n    \"\"\"\n    results = processing.run(\n        \"native:filedownloader\",\n        {\n            \"URL\": f\"https://fr.wikipedia.org/w/api.php?action=query&amp;titles={search}&amp;prop=description&amp;format=json\",\n            \"OUTPUT\": \"TEMPORARY_OUTPUT\"\n        }\n    )\n\n    with open(results['OUTPUT']) as f:\n        data = json.load(f)\n\n    pages = data['query']['pages']\n    # Only the first page will be used\n    for page_id, page in pages.items():\n        description = page.get('description')\n        if page_id == \"-1\":\n            error = page.get('invalidReason')\n            if description:\n                return f'Pas de page, {description}'\n            if not error:\n                return 'Pas de page'\n            else:\n                return f\"Pas de page, erreur {error}\"\n        return description\n</code></pre>"},{"location":"expression/#fournir-une-expression-depuis-une-extension","title":"Fournir une expression depuis une extension","text":"<p>Pour le moment, cette expression est dans le dossier de l'utilisateur, dans <code>python \u2192 expressions</code>.</p> <p>Mais une fois que nous avons une extension g\u00e9n\u00e9rique, nous pouvons l'int\u00e9grer dans un fichier Python de l'extension.</p> <p>Exemple sur StackExchange</p>"},{"location":"extension-deploiement/","title":"Comment d\u00e9ployer son extension","text":"<p>Comme vu dans le chapitre concernant la cr\u00e9ation d'une extension g\u00e9n\u00e9rique, une extension QGIS est un dossier comportant : </p> <ul> <li>un dossier qui est <code>nom_du_module</code>:<ul> <li><code>metadata.txt</code></li> <li><code>__init__.py</code> avec <code>classFactory</code></li> <li>d'autres fichiers Python</li> <li>des fichiers QtDesigner UI, SVG, couches etc</li> </ul> </li> </ul> <p>Ce dossier doit \u00eatre zipp\u00e9.</p> <p>Pour du d\u00e9ploiement, nous recommandons l'usage de QGIS-Plugin-CI qui peut faire du packaging, la g\u00e9n\u00e9ration du <code>plugins.xml</code>, envoyer sur plugins.qgis.org etc.</p>"},{"location":"extension-deploiement/#en-interne","title":"En interne","text":"<p>Si on souhaite publier en interne, on peut d\u00e9poser son dossier zip sur un serveur et on recommande l'utilisation du fichier <code>plugins.xml</code> qui permet de renseigner \u00e0 QGIS la disponibilit\u00e9 d'une extension.</p> <p>Exemple avec l'installation de PgMetadata et son fichier plugins.xml</p> <p>Il est possible de prot\u00e9ger son d\u00e9p\u00f4t avec un login/mot de passe.</p>"},{"location":"extension-deploiement/#tutoriel-pour-installer-un-depot","title":"Tutoriel pour installer un d\u00e9p\u00f4t","text":"<p>Notre tutoriel pour l'installation d'un d\u00e9p\u00f4t, avec ou sans mot de passe.</p>"},{"location":"extension-deploiement/#pluginsqgisorg","title":"plugins.qgis.org","text":"<p>Plus simple pour le d\u00e9ploiement, car le d\u00e9p\u00f4t plugins.qgis.org est par d\u00e9faut dans les installations de QGIS. Il faut cependant que le code source soit disponible sur internet.</p> <p>Lire les recommandations pour la publication sur ce d\u00e9p\u00f4t :</p> <ul> <li>Code source disponible</li> <li><code>metadata.txt</code> avec les bonnes informations et des liens HTTP valides</li> </ul>"},{"location":"extension-generique/","title":"La base pour cr\u00e9er une extension","text":""},{"location":"extension-generique/#une-extension-nest-quun-zip-pour-fournir-du-code-python","title":"Une extension n'est qu'un ZIP pour fournir du code Python","text":"<p>Comme vu dans Le Python dans QGIS, une extension peut \u00eatre sous diff\u00e9rente forme :</p> <ul> <li>fournir une interface graphique (voir ci-dessous)</li> <li>\u00eatre un fournisseur d'algorithme Processing (voir ci-dessous)</li> <li>fournir une expression, comme dans le TP Wikip\u00e9dia</li> <li>fournir un outil de recherche dans le \"locator\" (taper pour trouver)</li> <li>...</li> </ul>"},{"location":"extension-generique/#modele-de-base","title":"Mod\u00e8le de base","text":"<p>Pour cr\u00e9er une extension dans QGIS, il existe deux fa\u00e7ons de d\u00e9marrer : </p> <ul> <li>Utilisation de l'extension \"Plugin Builder\" :<ul> <li>Disponible depuis le gestionnaire des extensions de QGIS</li> <li>Assistant de cr\u00e9ation</li> <li>Tr\u00e8s (trop) complet, il y a squelette pour :<ul> <li>Du code avec des actions, ...</li> <li>G\u00e9n\u00e9rer de la documentation Sphinx</li> <li>Des tests unitaires</li> <li>Les traductions (multilingue)</li> </ul> </li> <li>Tr\u00e8s historique, moins mis \u00e0 jour ces derni\u00e8res ann\u00e9es, derni\u00e8re version de 2019</li> <li>https://github.com/g-sherman/Qgis-Plugin-Builder/</li> </ul> </li> <li>QGIS Minimal plugin :<ul> <li>Id\u00e9e originale https://github.com/wonder-sk/qgis-minimal-plugin</li> <li>\"Fork\" pour la formation https://github.com/Gustry/qgis_minimal_plugin</li> <li>ZIP \u00e0 t\u00e9l\u00e9charger et \u00e0 extraire</li> <li>Tr\u00e8s l\u00e9ger</li> <li>Besoin de tout refaire depuis z\u00e9ro</li> </ul> </li> </ul> <p></p> <ol> <li>T\u00e9l\u00e9charger le ZIP</li> <li>Installer le depuis le gestionnaire des extensions, \u00e0 l'aide du ZIP</li> </ol> <p>Tip</p> <p>Pour trouver le profil courant, dans QGIS, <code>Pr\u00e9f\u00e9rences</code> -&gt; <code>Profils Utilisateurs</code> -&gt; <code>Ouvrir le dossier du profil actif</code>.</p>"},{"location":"extension-generique/#le-fichier-metadatatxt","title":"Le fichier <code>metadata.txt</code>","text":"<p>Liste des valeurs possibles dans un fichier <code>metadata.txt</code></p>"},{"location":"extension-generique/#exemple-dune-extension-processing-et-graphique","title":"Exemple d'une extension Processing et graphique","text":"<p>Exemple d'utilisation d'un panneau qui pr\u00e9sentent les algorithmes \"Processing\" :</p> <p></p>"},{"location":"extension-generique/#extensions-utiles","title":"Extensions utiles","text":""},{"location":"extension-generique/#plugin-reloader","title":"Plugin reloader","text":"<p>Indispensable</p> <p>Le \"Plugin Reloader\" est une extension indispensable pour d\u00e9velopper une extension pour recharger son  extension. Elle est disponible dans le gestionnaire des extensions.</p>"},{"location":"extension-generique/#pyqgis-resource-browser","title":"PyQGIS Resource Browser","text":"<p>Utile pour l'ergonomie</p> <p>Permet d'aller chercher des ic\u00f4nes d\u00e9j\u00e0 existantes dans la libraire QGIS et Qt</p>"},{"location":"extension-generique/#first-aid","title":"First aid","text":"<p>Utile pour aller plus loin</p> <p>Extension pour d\u00e9bugger en cas d'une erreur Python</p>"},{"location":"extension-generique/#apprendre-dune-autre-extension","title":"Apprendre d'une autre extension","text":"<p>Comme les extensions sur qgis.org sont disponibles sur internet, on peut regarder le code source pour comprendre.</p> <p>Pensez \u00e0 ouvrir le dossier de votre profil QGIS en suivant l'astuce ci-dessus puis dans <code>python/plugins</code>.</p>"},{"location":"extension-graphique/","title":"Cr\u00e9er une extension QGIS avec une interface graphique","text":"<p>Pour faire ce chapitre, il faut d'abord avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent.</p>"},{"location":"extension-graphique/#qtdesigner","title":"QtDesigner","text":""},{"location":"extension-graphique/#mise-en-page","title":"Mise en page","text":"<p>Cr\u00e9ons un fichier QtDesigner comme-ceci : </p> <p></p> <p>et y ajouter des \"widgets\" :</p> <p>Important</p> <p>Ne tenez pas compte de l'alignement des widgets pour le moment. On fait juste un placement \"rapide\" vertical des widgets.</p> <p>Dans l'ordre vertical, ce sont ces classes :</p> Classe <code>QLabel</code> <code>QLineEdit</code> <code>QgsMapLayerComboBox</code> <code>QPlainTextEdit</code> Vertical spacer <code>QDialogButtonBox</code> <p></p> <p>Une fois que l'ensemble des \"widgets\" sont pr\u00e9sents, on peut faire un clic droit \u00e0 droite sur notre <code>QDialog</code>, puis <code>Mise en page</code> et enfin <code>Verticalement</code> \ud83d\ude80</p>"},{"location":"extension-graphique/#ajout-dun-bouton-dans-notre-buttonbox-en-bas","title":"Ajout d'un bouton dans notre \"ButtonBox\" en bas","text":"<p>Ajoutons le bouton d'aide, dans les propri\u00e9t\u00e9s de notre widget <code>QDialogButtonBox</code>.</p>"},{"location":"extension-graphique/#nommage-de-nos-widgets","title":"Nommage de nos \"widgets\"","text":"<p>Pour chacun de nos widgets, changeons le nom par d\u00e9faut de l'objet, propri\u00e9t\u00e9 <code>objectName</code> tout en haut :</p> Classe Nom par d\u00e9faut de <code>objectName</code> Nouveau nom pour <code>objectName</code> <code>QLineEdit</code> <code>lineEdit</code> <code>texte_prenom</code> <code>QgsMapLayerComboBox</code> <code>mMapLayerComboBox</code> <code>couche</code> <code>QPlainTextEdit</code> <code>plainTextEdit</code> <code>metadata</code> <code>QDialogButtonBox</code> <code>buttonBox</code> <code>button_box</code> <p>Cette propri\u00e9t\u00e9 <code>objectName</code> est tr\u00e8s importante, car elle d\u00e9termine l'appellation de notre propri\u00e9t\u00e9 dans l'objet <code>self</code> pour la suite du TP.</p>"},{"location":"extension-graphique/#astuces","title":"Astuces","text":"<ul> <li>Ouvrir la page des \"slots/signaux\" depuis la barre d'outils et supprimer ceux qui existent.</li> </ul> <p>Pourquoi supprimer les signaux de QtDesigner ?</p> <p>Un fichier QtDesigner est \"gros\" fichier XML. Il est difficile, dans le temps, de suivre ces modifications, changement\u2026</p> <p>Il est, \u00e0 mon avis, plus simple de garder le fichier XML le plus l\u00e9ger possible, et de garder la logique dans le code Python. Un signal en XML, c'est plusieurs lignes dans le fichier UI, alors que en Python, c'est une seule ligne.</p> <p>On peut t\u00e9l\u00e9charger la solution si besoin.</p> <ul> <li>Enregistrer le fichier en <code>dialog.ui</code> dans votre dossier contenant l'ensemble des fichiers.</li> </ul>"},{"location":"extension-graphique/#la-classe-qui-accompagne","title":"La classe qui accompagne","text":"<p>Cr\u00e9ons un fichier <code>dialog.py</code> avec le contenu suivant :</p> <pre><code>from qgis.core import Qgis\nfrom qgis.utils import iface\nfrom qgis.PyQt.QtWidgets import QDialog, QDialogButtonBox\nfrom qgis.PyQt import uic\nfrom pathlib import Path\n\nfolder = Path(__file__).resolve().parent\nui_file = folder.joinpath('dialog.ui')\nui_class, _ = uic.loadUiType(ui_file)\n\n\nclass MonDialog(ui_class, QDialog):\n\n    \"\"\" Classe qui repr\u00e9sente le dialogue de l'extension. \"\"\"\n\n    def __init__(self, parent: QDialog):\n        \"\"\" Constructeur. \"\"\"\n        super().__init__(parent)  # Appel du constructeur parent\n        self.parent = parent  # Stockage du parent dans self, on va l'utiliser plus tard, si besoin\n        self.setupUi(self)  # Fichier de QtDesigner\n\n        # Quelques propri\u00e9t\u00e9s facultatives\n        self.setWindowTitle(\"Notre super machine \u00e0 caf\u00e9\")\n        # self.setModal(False)  # Utile plus bas si on souhaite ouvrir une autre fen\u00eatre par-dessus\n</code></pre> <p>Modifions la m\u00e9thode <code>run</code> du fichier <code>__init__.py</code> en</p> <pre><code>    def run(self):\n        \"\"\" Lors du clic sur le bouton pour lancer la fen\u00eatre de l'extension. \"\"\"\n        from .dialog import MonDialog\n        dialog = MonDialog(self.iface.mainWindow())\n        dialog.show()\n</code></pre> <p>Relan\u00e7ons l'extension \u00e0 l'aide du \"plugin reloader\" et cliquons sur le bouton.</p>"},{"location":"extension-graphique/#les-signaux-et-les-slots","title":"Les signaux et les slots","text":""},{"location":"extension-graphique/#signaux-des-boutons-de-la-fenetre","title":"Signaux des boutons de la fen\u00eatre","text":"<p>Tip</p> <p>N'h\u00e9sitez pas \u00e0 relire le chapitre sur les signaux.</p> <p>Connectons le signal <code>clicked</code> du bouton \"Annuler\" dans le constructeur <code>__init__</code> : </p> <pre><code>self.button_box.button(QDialogButtonBox.StandardButton.Cancel).clicked.connect(self.close)\n</code></pre> <p>On dit que <code>clicked</code> est un signal, auquel on connecte le slot <code>close</code>.</p> <p>Connectons-le signal <code>clicked</code> du bouton \"Accepter\" \u00e0 notre propre slot (qui est une fonction) :</p> <pre><code>self.button_box.button(QDialogButtonBox.StandardButton.Ok).clicked.connect(self.click_ok)\n</code></pre> <p>Ensuite, ajoutons notre propre fonction <code>click_ok</code> pour quitter la fen\u00eatre et en affichant la saisie de l'utilisateur dans la QgsMessageBar de QGIS.</p> <p>Le widget de saisie est un QLineEdit : documentation Qt</p> <pre><code>def click_ok(self):\n    \"\"\" Clic sur le bouton OK afin de fermer la fen\u00eatre. \"\"\"\n    message = self.texte_prenom.text()\n    iface.messageBar().pushMessage('Notre extension', message, Qgis.Success)\n    self.accept()\n</code></pre> <p>Faire le test dans QGIS avec une saisie de l'utilisateur et fermer la fen\u00eatre.</p>"},{"location":"extension-graphique/#clic-sur-le-bouton-daide","title":"Clic sur le bouton d'aide","text":"<pre><code># Dans le constructeur :\nself.button_box.button(QDialogButtonBox.StandardButton.Help).clicked.connect(self.open_help)\n\n# Puis la fonction :\ndef open_help(self):\n    \"\"\" Open the online help. \"\"\"\n    from qgis.PyQt.QtGui import QDesktopServices\n    from qgis.PyQt.QtCore import QUrl\n    QDesktopServices.openUrl(QUrl('https://www.youtube.com/watch?v=AdQ3JDLlmPI'))\n</code></pre>"},{"location":"extension-graphique/#signaux-et-proprietes-du-formulaire-de-saisie","title":"Signaux et propri\u00e9t\u00e9s du formulaire de saisie","text":"<p>Continuons en rendant en lecture seule le gros bloc de texte et affichons \u00e0 l'int\u00e9rieur la description de la couche qui est s\u00e9lectionn\u00e9e dans le menu d\u00e9roulant.</p> <p>Documentation :</p> <ul> <li>QPlainTextEdit, on va utiliser <code>appendPlainText</code> et <code>clear</code>.</li> <li>QgsMapLayerComboBox, on va utiliser <code>currentLayer</code>.</li> </ul> <p>Dans la fonction <code>__init__</code> du fichier <code>dialog.py</code> :</p> <pre><code>self.metadata.setReadOnly(True)\nself.couche.layerChanged.connect(self.layer_changed)\n</code></pre> <p>Et la nouvelle fonction qui va se charger de mettre \u00e0 jour le texte :</p> <pre><code>def layer_changed(self):\n    \"\"\" Permet de mettre \u00e0 jour l'UI selon la couche dans le menu d\u00e9roulant. \"\"\"\n    self.metadata.clear()\n    layer = self.couche.currentLayer()\n    self.metadata.appendPlainText(f\"{layer.name()} : {layer.crs().authid()}\")\n</code></pre> La solution plus compl\u00e8te <pre><code>layer = self.couche.currentLayer()\nif layer:\n    self.metadata.appendPlainText(f\"{layer.name()} : {layer.crs().authid()}\")\nelse:\n    self.metadata.appendPlainText(\"Pas de couche\")\n</code></pre> <p>On peut donc d\u00e9sormais cumuler l'ensemble des chapitres pr\u00e9c\u00e9dents pour lancer des algorithmes, manipuler les donn\u00e9es, etc.</p> <p>Bonus</p> <p>Le texte actuel concernant les m\u00e9tadonn\u00e9es est \"limit\u00e9\". N'h\u00e9sitez pas \u00e0 compl\u00e9ter, un peu comme lors de l'exercice avec le fichier CSV, pour rappel :</p> <ul> <li>La source de la couche</li> <li>Le nombre d'entit\u00e9</li> <li>Des informations que l'on retrouve dans le panneau \"Informations\" des propri\u00e9t\u00e9s d'une couche</li> <li>\u2026</li> </ul>"},{"location":"extension-graphique/#solution","title":"Solution","text":"Afficher <pre><code>from qgis.core import Qgis\nfrom qgis.utils import iface\nfrom qgis.PyQt.QtWidgets import QDialog, QDialogButtonBox\nfrom qgis.PyQt import uic\nfrom pathlib import Path\n\nfolder = Path(__file__).resolve().parent\nui_file = folder.joinpath('dialog.ui')\nui_class, _ = uic.loadUiType(ui_file)\n\n\nclass MonDialog(ui_class, QDialog):\n\n    \"\"\" Classe qui repr\u00e9sente le dialogue de l'extension. \"\"\"\n\n    def __init__(self, parent=None):\n        \"\"\" Constructeur. \"\"\"\n        _ = parent\n        super().__init__()\n        self.setupUi(self)  # Fichier de QtDesigner\n\n        # Connectons les signaux\n        self.button_box.button(QDialogButtonBox.StandardButton.Ok).clicked.connect(self.click_ok)\n        self.button_box.button(QDialogButtonBox.StandardButton.Cancel).clicked.connect(self.close)\n\n        self.metadata.setReadOnly(True)\n        self.couche.layerChanged.connect(self.layer_changed)\n\n    def click_ok(self):\n        \"\"\" Clic sur le bouton OK afin de fermer la fen\u00eatre. \"\"\"\n        self.close()\n        message = self.texte_prenom.text()\n        iface.messageBar().pushMessage('Notre extension', message, Qgis.Success)\n\n    def layer_changed(self):\n        \"\"\" Permet de mettre \u00e0 jour l'UI selon la couche dans le menu d\u00e9roulant. \"\"\"\n        self.metadata.clear()\n        layer = self.couche.currentLayer()\n        if layer:\n            self.metadata.appendPlainText(f\"{layer.name()} : {layer.crs().authid()}\")\n        else:\n            self.metadata.appendPlainText(\"Pas de couche\")\n</code></pre>"},{"location":"extension-graphique/#organisation-du-code","title":"Organisation du code","text":"<p>Il ne faut pas h\u00e9siter \u00e0 cr\u00e9er des fichiers afin de s\u00e9parer le code.</p> <p>On peut aussi cr\u00e9er des dossiers afin d'y mettre plusieurs fichiers Python. Un dossier en Python se nomme un module. Pour faire un module compatible, il faut ajouter un fichier <code>__init__.py</code> m\u00eame s\u2019il n'y a rien dedans.</p> <p>Warning</p> <p>Il ne faut vraiment pas oublier le fichier <code>__init__.py</code>. Cela peut emp\u00eacher Python de fonctionner correctement. Un bon IDE peut signaler ce genre d'erreur.</p> <p>Dans l'exemple ci-dessus, on peut diviser le code du fichier <code>__init__.py</code> :</p> <pre><code>def classFactory(iface):\n    from minimal.plugin import MinimalPlugin\n    return MinimalPlugin(iface)\n</code></pre> <p>En faisant un couper/coller, enlever la classe <code>MinimalPlugin</code> du fichier <code>__init__.py</code>.</p> <p>Tip</p> <p>On essaie souvent d'avoir une classe par fichier en Python.</p> <p>Cr\u00e9er un fichier <code>plugin.py</code> et ajouter le contenu en collant. Il est bien de v\u00e9rifier les imports dans les deux fichiers.</p>"},{"location":"extension-graphique/#un-dossier-resources","title":"Un dossier \"resources\"","text":"<p>On peut cr\u00e9er un fichier <code>qgis_plugin_tools.py</code> \u00e0 la racine de notre extension afin d'y ajouter des outils :</p> <pre><code>\"\"\"Tools to work with resources files.\"\"\"\n\nfrom pathlib import Path\n\n\ndef plugin_path(*args) -&gt; Path:\n    \"\"\"Return the path to the plugin root folder.\"\"\"\n    path = Path(__file__).resolve().parent\n    for item in args:\n        path = path.joinpath(item)\n\n    return path\n\n\ndef resources_path(*args) -&gt; Path:\n    \"\"\"Return the path to the plugin resources folder.\"\"\"\n    return plugin_path(\"resources\", *args)\n\n# On peut ajouter ici une m\u00e9thode qui charge un fichier UI qui se trouve dans le dossier \"UI\"\n# et retourne la classe directement.\n</code></pre> <p>On peut ensuite cr\u00e9er un dossier <code>resources</code> puis <code>icons</code> afin d'y d\u00e9placer un fichier PNG, JPG, SVG.</p> <p>Warning</p> <p>Attention \u00e0 la taille de vos fichiers pour une petite ic\u00f4ne \ud83d\ude09</p>"},{"location":"extension-graphique/#dans-une-extension-graphique-pour-les-icones","title":"Dans une extension graphique pour les ic\u00f4nes","text":"<pre><code># En haut du fichier, on ajoute les imports n\u00e9cessaires\nfrom qgis.PyQt.QtGui import QIcon\nfrom .qgis_plugin_tools import resources_path\n\n# Plus bas dans le code\n# Quand n\u00e9cessaire, \u00e0 remplacer la QAction existante. Il s'agit du premier param\u00e8tre avec QIcon\nself.action = QAction(\n    QIcon(str(resources_path('icons', 'icon.svg'))),\n    'Go!',\n    self.iface.mainWindow())\n</code></pre> <p>Tip</p> <p>Ce qu'il faut retenir, c'est l'usage de <code>QIcon(str(resources_path('icons', 'icon.svg')))</code> si l'on souhaite utiliser une ic\u00f4ne dans autre endroit de l'extension.</p>"},{"location":"extension-graphique/#dans-une-extension-processing","title":"Dans une extension \"Processing\"","text":"<p>Dans le provider et les algorithmes :</p> <pre><code># En haut du fichier\nfrom ..qgis_plugin_tools import resources_path\n\n# Dans la classe, on ajoute/modifie la m\u00e9thode 'icon'\ndef icon(self) -&gt; QIcon:\n    return QIcon(str(resources_path(\"icons\", \"icon.png\")))\n</code></pre>"},{"location":"extension-graphique/#utilisation-dune-icone-provenant-de-qgis","title":"Utilisation d'une ic\u00f4ne provenant de QGIS","text":"<p>\u00c0 l'aide de l'extension \"PyQGIS Resource Browser\", rechercher une ic\u00f4ne concordant avec bouton :</p> <ul> <li><code>new</code> pour trouver les ic\u00f4nes ayant la petite \u00e9toile jaune</li> <li><code>select</code> pour trouver les ic\u00f4nes ayant la notion de s\u00e9lection, avec le fond jaune</li> <li><code>delete</code> ou <code>remove</code> pour la suppression</li> <li>\u2026</li> </ul> <p>On peut ensuite faire un clic-droit, puis coller son chemin.</p> <p>Ensuite, quand on souhaite utiliser l'ic\u00f4ne :</p> <pre><code># En haut\nfrom qgis.PyQt.QtGui import QIcon\n\n# Ensuite\nicon = QIcon(\":/images/themes/default/algorithms/mAlgorithmBuffer.svg\")\n\n# Par exemple sur un bouton QPushButton\nself.un_bouton.setIcon(QIcon(\":/images/themes/default/algorithms/mAlgorithmBuffer.svg\"))\n</code></pre>"},{"location":"extension-graphique/#ajouter-un-bouton-pour-lancer-processing","title":"Ajouter un bouton pour lancer Processing","text":"<p>Nous souhaitons ajouter 2 boutons :</p> <p></p> Classe <code>objectName</code> <code>QPushButton</code> <code>btn_traitement_1</code> <code>QPushButton</code> <code>btn_traitement_2</code> <p>On peut faire la mise en page vertical dans le <code>QGroupBox</code>.</p> <p>Ajoutons les ic\u00f4nes et infobulles si n\u00e9cessaires, dans le constructeur :</p> <pre><code>self.btn_traitement_1.setToolTip(\"Permet de lancer l'algorithme des tampons sur la couche ci-dessus avec un buffer de 2km\")\nself.btn_traitement_1.setIcon(QIcon(\":/images/themes/default/algorithms/mAlgorithmBuffer.svg\"))\nself.btn_traitement_1.clicked.connect(self.traitement_1_clicked)\n</code></pre>"},{"location":"extension-graphique/#lancer-le-dialogue-de-processing","title":"Lancer le dialogue de Processing","text":"<p>Pour les imports :</p> <pre><code>from qgis.core import QgsVectorLayer\nfrom qgis import processing\n</code></pre> <p>Pour le code dans la fonction :</p> <pre><code>def traitement_1_clicked(self):\n    \"\"\" Lancement de la fen\u00eatre de QGIS Processing. \"\"\"\n    layer = self.couche.currentLayer()\n\n    # Les pr\u00e9-requis pour continuer\n    # On sort de la fonction si on ne peut pas continuer\n    if not isinstance(layer, QgsVectorLayer):\n        return\n\n    if not layer.isSpatial():\n        return\n\n    dialog = processing.createAlgorithmDialog(\n        \"native:buffer\",\n        {\n            'INPUT': layer,\n            'DISTANCE': 2000,\n            'OUTPUT': 'TEMPORARY_OUTPUT'\n        }\n    )\n    dialog.show()\n</code></pre> <p>Pour rappel, nous ne sommes pas oblig\u00e9 d'ouvrir la fen\u00eatre de Processing, on peut directement faire <code>processing.run</code>, lire le chapitre pr\u00e9c\u00e9dent. Il ne faut pas oublier de donner la variable <code>layer</code> \u00e0 notre <code>INPUT</code> si vous copiez/coller le code de <code>processing.run</code> du chapitre pr\u00e9c\u00e9dent.</p>"},{"location":"extension-processing/","title":"Cr\u00e9er une extension QGIS pour Processing","text":"<p>Pour faire ce chapitre, il faut : </p> <ol> <li>Avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent</li> <li>Faire la mise \u00e0 jour en extension Processing \u00e0 l'aide de la    documentation QGIS</li> </ol>"},{"location":"fonctions-scripts/","title":"Organisation du code dans un script avec des fonctions","text":""},{"location":"fonctions-scripts/#communication-avec-lutilisateur-des-erreurs-et-des-logs","title":"Communication avec l'utilisateur des erreurs et des logs","text":"<p>Avant de commencer \u00e0 vraiment \u00e9crire un script avec des fonctions, regardons comment communiquer des  informations \u00e0 l'utilisateur.</p> <p>Cookbook</p> <p>Lien vers le Python cookbook qui pr\u00e9sente cette partie plus pr\u00e9cis\u00e9ment.</p>"},{"location":"fonctions-scripts/#la-barre-de-message","title":"La barre de message","text":"<p>On peut envoyer des messages vers l'utilisateur avec l'utilisation de la <code>messageBar</code> de la classe <code>QgisInterface</code> CPP/PyQGIS :</p> <pre><code>iface.messageBar().pushMessage('Erreur','On peut afficher une erreur', Qgis.Critical)\niface.messageBar().pushMessage('Avertissement','ou un avertissement', Qgis.Warning)\niface.messageBar().pushMessage('Information','ou une information', Qgis.Info)\niface.messageBar().pushMessage('Succ\u00e8s','ou un succ\u00e8s', Qgis.Success)\n</code></pre> <p>Cette fonction prend 3 param\u00e8tres :</p> <ol> <li>un titre</li> <li>un message</li> <li>un niveau d'alerte</li> </ol> <p>On peut voir dans la classe de QgsMessageBar qu'il existe aussi <code>pushSuccess</code> qui est une alternative par exemple.</p>"},{"location":"fonctions-scripts/#journal-des-logs","title":"Journal des logs","text":"<p>On peut aussi \u00e9crire des logs comme ceci (plus discret, mais plus verbeux) : <pre><code>QgsMessageLog.logMessage('Une erreur est survenue','Notre outil', Qgis.Critical)\nQgsMessageLog.logMessage('Un avertissement','Notre outil', Qgis.Warning)\nQgsMessageLog.logMessage('Une information','Notre outil', Qgis.Info)\nQgsMessageLog.logMessage('Un succ\u00e8s','Notre outil', Qgis.Success)\n</code></pre></p> <p>Cette fonction prend 3 param\u00e8tres :</p> <ul> <li>un message</li> <li>une cat\u00e9gorie, souvent le nom de l'extension ou de l'outil en question</li> <li>un niveau d'alerte</li> </ul>"},{"location":"fonctions-scripts/#des-fonctions-pour-simplifier-le-code","title":"Des fonctions pour simplifier le code","text":""},{"location":"fonctions-scripts/#une-fonction-pour-charger-une-couche","title":"Une fonction pour charger UNE couche","text":"<p>La console, c'est bien, mais c'est tr\u00e8s limitant. Passons \u00e0 l'\u00e9criture d'un script qui va nous faciliter  l'organisation du code.</p> <ol> <li>Red\u00e9marrer QGIS (afin de vider l'ensemble des variables que l'on a dans notre console)</li> <li>N'ouvrez pas le projet pr\u00e9c\u00e9dent !</li> <li>Ouvrer la console, puis cliquer sur <code>Afficher l'\u00e9diteur</code></li> <li>Copier/coller le script ci-dessous</li> <li>Ex\u00e9cuter le</li> </ol> <pre><code># En haut du script, ce sont souvent des variables \u00e0 modifier\nbd_topo = 'BD_TOPO'\nthematique = 'ADMINISTRATIF'\ncouche = 'COMMUNE'\n\n# Puis place au script\n# En th\u00e9orie, pas besoin de modification, en dessous pour un \"utilisateur final\" du script\n\nfrom pathlib import Path\n\nprojet_qgis = QgsProject.instance().absoluteFilePath()\nif not projet_qgis:\n    iface.messageBar().pushMessage('Erreur de chargement','Le projet n\\'est pas enregistr\u00e9', Qgis.Critical)\nelse:\n    racine = Path(projet_qgis).parent\n    fichier_shape = racine.joinpath(bd_topo, thematique, f'{couche}.shp')\n    if not fichier_shape.exists():\n        iface.messageBar().pushMessage('Erreur de chargement', f'Le chemin n\\'existe pas: \"{fichier_shape}\"', Qgis.Critical)\n    else:\n        layer = QgsVectorLayer(str(fichier_shape), couche, 'ogr')\n        if not layer.isValid():\n            iface.messageBar().pushMessage('Erreur de chargement','La couche n\\'est pas valide', Qgis.Critical)\n        else:\n            QgsProject.instance().addMapLayer(layer)\n            iface.messageBar().pushMessage('Bravo','Well done! \ud83d\udc4d', Qgis.Success)\n    print('Fin du script si on a un projet')\n</code></pre> <ul> <li>\u00c0 l'aide du m\u00e9mo Python :</li> <li>Essayons de faire une fonction qui prend 3 param\u00e8tres :<ul> <li>la <code>bd_topo</code></li> <li>la <code>thematique</code></li> <li>le nom du shapefile <code>couche</code></li> </ul> </li> <li>La fonction se chargera de faire le n\u00e9cessaire, par exemple: <code>charger_couche(bd_topo, 'ADMINISTRATIF', 'COMMUNE')</code></li> <li>La fonction peut \u00e9galement retourner <code>False</code> si la couche n'est pas charg\u00e9e (une erreur) ou sinon <code>True</code></li> </ul> <p>Tip</p> <p>Pour d\u00e9sindenter le code, <code>MAJ</code> + <code>TAB</code>.</p> <pre><code># Avec annotations Python\ndef charger_couche(bd_topo: str, thematique: str, couche: str):\n    ...\n\n# Sans annotations Python\ndef charger_couche(bd_topo, thematique, couche):\n    ...\n</code></pre> <p>Tip</p> <p>Le mot-cl\u00e9 <code>pass</code> (ou encore <code>...</code> qui est synonyme) ne sert \u00e0 rien. C'est un mot-cl\u00e9 Python pour rendre un bloc valide mais ne faisant rien. On peut le supprimer le bloc n'est pas vide.</p> <p>On peut ajouter une docstring \u00e0 notre fonction, juste en dessous du <code>def</code>, avec des indentations : <pre><code>\"\"\" Fonction qui charge une couche de la BD TOPO, selon une th\u00e9matique. \"\"\"\n</code></pre></p> Afficher la solution interm\u00e9diaire <pre><code># En haut du script, ce souvent des variables \u00e0 modifier\nbd_topo = 'BD_TOPO'\nthematique = 'ADMINISTRATIF'\ncouche = 'COMMUNE'\n\n# Puis place au script\n# En th\u00e9orie, pas besoin de modification, en dessous pour un \"utilisateur final\" du script\n\nfrom pathlib import Path\n\ndef charger_couche(bd_topo, thematique, couche):\n    \"\"\" Fonction qui charge une couche de la BD TOPO, selon une th\u00e9matique. \"\"\"\n    projet_qgis = QgsProject.instance().absoluteFilePath()\n    if not projet_qgis:\n        iface.messageBar().pushMessage('Erreur de chargement','Le projet n\\'est pas enregistr\u00e9', Qgis.Critical)\n    else:\n        racine = Path(projet_qgis).parent\n        fichier_shape = racine.joinpath(bd_topo, thematique, f'{couche}.shp')\n        if not fichier_shape.exists():\n            iface.messageBar().pushMessage('Erreur de chargement', f'Le chemin n\\'existe pas: \"{fichier_shape}\"', Qgis.Critical)\n        else:\n            layer = QgsVectorLayer(str(fichier_shape), couche, 'ogr')\n            if not layer.isValid():\n                iface.messageBar().pushMessage('Erreur de chargement','La couche n\\'est pas valide', Qgis.Critical)\n            else:\n                QgsProject.instance().addMapLayer(layer)\n                iface.messageBar().pushMessage('Bravo','Well done! \ud83d\udc4d', Qgis.Success)\n        print('Fin du script si on a un projet')\n\n# Appel de notre fonction\ncharger_couche(bd_topo, thematique, couche)\n</code></pre> <p>Am\u00e9liorons encore cette solution interm\u00e9diaire avec la gestion des erreurs avec l'instruction <code>return</code></p> <p>On peut garder le code le plus \u00e0 gauche possible gr\u00e2ce \u00e0 <code>return</code> qui ordonne la sortie de la fonction.</p> Afficher une des solutions finales <pre><code># En haut du script, ce souvent des variables \u00e0 modifier\nbd_topo = 'BD_TOPO'\n\n# Puis place au script\n# En th\u00e9orie, pas besoin de modification, en dessous pour un \"utilisateur final\" du script\n\nfrom pathlib import Path\n\ndef charger_couche(bd_topo, thematique, couche):\n    \"\"\" Fonction qui charge une couche de la BD TOPO, selon une th\u00e9matique. \"\"\"\n    projet_qgis = QgsProject.instance().absoluteFilePath()\n    if not projet_qgis:\n        iface.messageBar().pushMessage('Erreur de chargement','Le projet n\\'est pas enregistr\u00e9', Qgis.Critical)\n        return False\n\n    racine = Path(projet_qgis).parent\n    fichier_shape = racine.joinpath(bd_topo, thematique, f'{couche}.shp')\n    if not fichier_shape.exists():\n        iface.messageBar().pushMessage('Erreur de chargement','Le chemin n\\'existe pas: \"{fichier_shape}\"', Qgis.Critical)\n        return False\n\n    layer = QgsVectorLayer(str(fichier_shape), couche, 'ogr')\n    if not layer.isValid():\n        iface.messageBar().pushMessage('Erreur de chargement','La couche n\\'est pas valide', Qgis.Critical)\n        return False\n\n    QgsProject.instance().addMapLayer(layer)\n    iface.messageBar().pushMessage('Bravo','Well done! \ud83d\udc4d', Qgis.Success)\n    # return True\n    return layer\n\n# Appel de notre fonction\ncharger_couche(bd_topo, 'ADMINISTRATIF', 'COMMUNE')\ncharger_couche(bd_topo, 'ADMINISTRATIF', 'ARRONDISSEMENT')\n</code></pre>"},{"location":"fonctions-scripts/#une-fonction-pour-lister-les-couches-dune-thematique","title":"Une fonction pour lister LES couches d'UNE th\u00e9matique","text":"<p>Essayons de faire une fonction qui liste les shapefiles d'une certaine th\u00e9matique \ud83d\ude80</p> <p>Plus pr\u00e9cis\u00e9ment, on souhaite une liste de cha\u00eenes de caract\u00e8res : <code>['COMMUNE', 'EPCI']</code>.</p> <p>Dans l'objet <code>Path</code>, il existe une m\u00e9thode <code>iterdir()</code>. Par exemple, pour it\u00e9rer sur le dossier courant de l'utilisateur :</p> <pre><code>from pathlib import Path\n\ndossier = Path.home()\nfor fichier in dossier.iterdir():\n    print(fichier)\n</code></pre> <p>Tip</p> <p>Il faut se r\u00e9f\u00e9rer \u00e0 la documentation du module pathlib pour comprendre le fonctionnement de cette classe.</p> <p>Voici la signature de la fonction que l'on souhaite :</p> <pre><code>def liste_shapefiles(bd_topo: str, thematique: str):\n    \"\"\" Lister les shapefiles d'une th\u00e9matique dans la BDTopo. \"\"\"\n    ...\n</code></pre> <p>Petit m\u00e9mo pour cet exercice :</p> <ul> <li>L'extension d'un fichier de type <code>Path</code> : <code>fichier.suffix</code></li> <li>Obtenir le nom du fichier d'un objet <code>Path</code> : <code>fichier.stem</code></li> <li>Passer une cha\u00eene de caract\u00e8re en minuscule : <code>\"bONjouR\".lower()</code>, pratique pour v\u00e9rifier la casse \ud83d\ude09</li> <li>Cr\u00e9er une liste vide <code>shapes = []</code></li> <li>Ajouter un \u00e9l\u00e9ment dans une liste <code>shapes.append(\"Bonjour\")</code></li> <li>\u00c0 la fin, on peut retourner la liste <code>return shapes</code></li> </ul> Correction <pre><code>def liste_shapefiles(bd_topo: str, thematique: str):\n    \"\"\" Lister les shapefiles d'une th\u00e9matique dans la BDTopo. \"\"\"\n    racine = Path(QgsProject.instance().absoluteFilePath()).parent\n    dossier = racine.joinpath(bd_topo, thematique)\n    shapes = []\n    for file in dossier.iterdir():\n        if file.suffix.lower() == '.shp':\n            shapes.append(file.stem)\n    return shapes\n\nshapes = liste_shapefiles(bd_topo, 'ADMINISTRATIF')\nprint(shapes)\n</code></pre> <p>On a d\u00e9sormais deux fonctions : <code>liste_shapefiles</code> et <code>charger_couche</code>.</p> <p>Il est d\u00e9sormais simple de charger toutes une th\u00e9matique de notre BDTopo :</p> <pre><code>thematique = 'ADMINISTRATIF'\nshapes = liste_shapesfiles(bd_topo, thematique)\nfor shape in shapes:\n    charger_couche(bd_topo, thematique, shape)\n</code></pre> <p>Success</p> <p>On a termin\u00e9 avec ces deux fonctions, c'\u00e9tait pour manipuler les fonctions \ud83d\ude0e</p>"},{"location":"fonctions-scripts/#pour-les-curieux","title":"Pour les curieux \ud83e\udd2d","text":"<p>Zoomer sur l'emprise d'une couche, sans la charger dans la l\u00e9gende</p> Example <ol> <li>Modifions la signature de la fonction, en ajoutant un bool\u00e9en si on souhaite la couche dans la l\u00e9gende : <pre><code>def charger_couche(bd_topo, thematique, couche, ajouter_dans_legende = True):\n</code></pre> Puis dans cette m\u00eame fonction, utilisons cette variable : <pre><code>if ajouter_dans_legende:\n    QgsProject.instance().addMapLayer(layer)\n    iface.messageBar().pushMessage('Bravo','Well done! \ud83d\udc4d', Qgis.Success)\n# return True\nreturn layer\n</code></pre></li> </ol> <p>Puis on peut ordonner au <code>QgsMapCanvas</code> de zoomer sur une emprise : <pre><code>hydro = charger_couche(bd_topo, 'ZONES_REGLEMENTEES', 'PARC_OU_RESERVE', False)\niface.mapCanvas().setExtent(hydro.extent())\n</code></pre></p> <p>Ne pas oublier de tenir compte d'une projection diff\u00e9rente entre le canevas et la couche.</p> <p>TODO, \u00e0 adapter, mais le code est la pour faire une reprojection entre 2 CRS <pre><code>extent = iface.activeLayer().extent()\ncrs_layer = iface.activeLayer().crs()\ncrs = iface.mapCanvas().mapSettings().destinationCrs()\ntransformer = QgsCoordinateTransform(crs_layer, crs, QgsProject.instance())\nnew_extent = transformer.transform(extent)\niface.mapCanvas().setExtent(new_extent)\n</code></pre></p>"},{"location":"fonctions-scripts/#extraction-des-informations-sous-forme-dun-fichier-csv","title":"Extraction des informations sous forme d'un fichier CSV.","text":""},{"location":"fonctions-scripts/#introduction","title":"Introduction","text":"<p>On souhaite d\u00e9sormais r\u00e9aliser une fonction d'export des m\u00e9tadonn\u00e9es de nos couches au format CSV, avec des tabulations comme s\u00e9parateur et son CSVT.</p> <p>Il existe d\u00e9j\u00e0 un module CSV dans Python pour nous aider \u00e0 \u00e9crire un fichier de type CSV, mais nous n'allons pas l'utiliser.</p> <p>Nous allons plut\u00f4t utiliser l'API QGIS pour :</p> <ol> <li>Cr\u00e9er une nouvelle couche en m\u00e9moire comportant les diff\u00e9rentes informations que l'on souhaite exporter</li> <li>Puis, nous allons utiliser l'API pour exporter cette couche m\u00e9moire au format CSV (l'\u00e9quivalent dans QGIS de l'action <code>Exporter la couche</code>).</li> </ol> <p>Les diff\u00e9rents champs qui devront \u00eatre export\u00e9s sont :</p> <ul> <li>son nom</li> <li>son type de g\u00e9om\u00e9trie (format humain, lisible)</li> <li>la projection</li> <li>le nombre d'entit\u00e9</li> <li>l'encodage</li> <li>si le seuil de visibilit\u00e9 est activ\u00e9</li> <li>la source (le chemin) de la donn\u00e9e</li> </ul>"},{"location":"fonctions-scripts/#exemple-de-sortie","title":"Exemple de sortie","text":"nom type projection nombre_entite encodage source seuil_de_visibilite couche_1 Line EPSG:4326 5 UTF-8 /tmp/...geojson False couche_2 Tab No geometry 0 /tmp/...shp True"},{"location":"fonctions-scripts/#petit-memo-avec-des-exemples","title":"Petit m\u00e9mo avec des exemples","text":"<p>Pour cr\u00e9er une couche tabulaire en m\u00e9moire, code qui vient du cookbook : <pre><code>layer_info = QgsVectorLayer('None', 'info', 'memory')\n</code></pre></p> <p>La liste des couches : <pre><code>layers = QgsProject.instance().mapLayers()\n</code></pre></p> <p>Cr\u00e9er une entit\u00e9 ayant d\u00e9j\u00e0 les champs pr\u00e9configur\u00e9s d'une couche vecteur, et y affecter des valeurs : <pre><code>feature = QgsFeature(objet_qgsvectorlayer.fields())\nfeature['nom'] = \"NOM\"\n</code></pre></p> <p>Obtenir le dossier du projet actuel : <pre><code>projet_qgis = Path(QgsProject.instance().fileName())\ndossier_qgis = projet_qgis.parent\n</code></pre></p> <p>Afficher la g\u00e9om\u00e9trie, sous sa forme \"humaine\", en cha\u00eene de caract\u00e8re, avec l'aide de <code>QgsWkbTypes</code> : <pre><code>QgsWkbTypes.geometryDisplayString(vector_layer.geometryType())\n</code></pre></p> <p>Pour utiliser une session d'\u00e9dition, on peut faire : <pre><code>layer.startEditing()  # D\u00e9but de la session\nlayer.commitChanges()  # Fin de la session en enregistrant\nlayer.rollback()  # Fin de la session en annulant les modifications\n</code></pre></p>"},{"location":"fonctions-scripts/#les-contextes-python","title":"Les contextes Python","text":"<p>On peut \u00e9galement faire une session d'\u00e9dition avec un \"contexte Python\" :</p> <pre><code>from qgis.core import edit\n\nwith edit(layer):\n    # Faire une \u00e9dition sur la couche\n    pass\n\n# \u00c0 la fin du bloc d'indentation, la session d'\u00e9dition est automatiquement close, m\u00eame en cas d'erreur Python\n</code></pre> Exemple de l'utilisation d'un contexte Python avec la session d'\u00e9dition <p>Sans contexte, la couche reste en mode \u00e9dition en cas d'erreur fatale Python</p> <pre><code>layer = iface.activeLayer()\n\nlayer.startEditing()\nprint(\"D\u00e9but de la session\")\n# Code inutile, mais qui va volontairement faire une exception Python\na = 10 / 0\n\nprint(\"Fin de la session\")\nlayer.commitChanges()\nprint(\"Fin du script\")\n</code></pre> <p>Mais utilisons d\u00e9sormais un contexte Python \u00e0 l'aide de<code>with</code>, sur une couche qui n'est pas en \u00e9dition :</p> <pre><code>layer = iface.activeLayer()\n\nwith edit(layer):\n    print(\"D\u00e9but de la session\")\n    # Code inutile, mais qui va volontairement faire une exception Python\n    a = 10 / 0\n\nprint(\"Fin du script\")\n</code></pre> <p>On peut lire le code comme <code>En \u00e9ditant la couche \"layer\", faire :</code>.</p>"},{"location":"fonctions-scripts/#petit-memo-des-classes","title":"Petit m\u00e9mo des classes","text":"<p>Nous allons avoir besoin de plusieurs classes dans l'API QGIS : </p> <ul> <li><code>QgsProject</code> : PyQGIS / CPP</li> <li><code>QgsVectorLayer</code> : PyQGIS / CPP</li> <li>Enregistrer un fichier avec <code>QgsVectorFileWriter</code> : PyQGIS / CPP, lire la correction pour voir son usage.</li> <li>Un champ dans une couche vecteur : <code>QgsField</code> (PyQGIS / CPP),   attention \u00e0 ne pas confondre avec <code>QgsFields</code> (PyQGIS / CPP)   qui lui repr\u00e9sente un ensemble de champs.</li> <li>Une entit\u00e9 <code>QgsFeature</code> PyQGIS / CPP</li> <li>Pour le type de g\u00e9om\u00e9trie : Utiliser <code>QgsVectorLayer</code> <code>geometryType()</code> et \u00e9galement la m\u00e9thode <code>QgsWkbTypes.geometryDisplayString()</code> pour sa conversion en cha\u00eene \"lisible\"<ul> <li>PyQGIS / CPP</li> </ul> </li> </ul> <p>Pour le type de champ, on va avoir besoin de l'API Qt \u00e9galement :</p> <ul> <li>Documentation Qt5 sur QMetaType</li> <li>Remplacer <code>QMetaType</code> par <code>QVariant</code> et aussi exception <code>QString</code> par <code>String</code></li> <li>Par exemple :<ul> <li>Pour cr\u00e9er un nouveau champ de type string : <code>QgsField('nom', QVariant.String)</code></li> <li>Pour cr\u00e9er un nouveau champ de type entier : <code>QgsField('nombre_entit\u00e9', QVariant.Int)</code></li> </ul> </li> </ul> <p>Note</p> <p>Note perso, je pense qu'avec la migration vers Qt6, cela va pouvoir se simplifier un peu pour les <code>QVariant</code>...</p>"},{"location":"fonctions-scripts/#etapes","title":"\u00c9tapes","text":"<p>Il va y avoir plusieurs \u00e9tapes dans ce script :</p> <ol> <li>Cr\u00e9er une couche en m\u00e9moire</li> <li>Ajouter des champs \u00e0 cette couche en utilisant une session d'\u00e9dition</li> <li>R\u00e9cup\u00e9rer la liste des couches pr\u00e9sentes dans la l\u00e9gende</li> <li>It\u00e9rer sur les couches pour ajouter ligne par ligne les m\u00e9tadonn\u00e9es dans une session d'\u00e9dition</li> <li>Enregistrer en CSV la couche m\u00e9moire</li> </ol> <p>Tip</p> <p>Pour d\u00e9boguer, on peut afficher la couche m\u00e9moire en question avec <code>QgsProject.instance().addMapLayer(layer_info)</code></p>"},{"location":"fonctions-scripts/#solution-possible","title":"Solution possible","text":"<pre><code>from qgis.core import edit\n\n# Cr\u00e9ation de la couche m\u00e9moire\nlayer_info = QgsVectorLayer('None', 'info', 'memory')\n# QgsProject.instance().addMapLayer(layer_info)\n\n# Ajout des champs\nwith edit(layer_info):\n    layer_info.addAttribute(QgsField('nom', QVariant.String))\n    layer_info.addAttribute(QgsField('type', QVariant.String))\n    layer_info.addAttribute(QgsField('projection', QVariant.String))\n    layer_info.addAttribute(QgsField('nombre_entit\u00e9', QVariant.Int))\n    layer_info.addAttribute(QgsField('encodage', QVariant.String))\n    layer_info.addAttribute(QgsField('seuil', QVariant.Bool))\n    layer_info.addAttribute(QgsField('source', QVariant.String))\n\nlayers = QgsProject.instance().mapLayers()\nif not layers:\n    iface.messageBar().pushMessage('Pas de couche', \"Attention, il n'a pas de couche\", Qgis.Warning)\n\n# It\u00e9ration sur l'ensemble des couches du projet\nfor layer in layers.values():\n    feature = QgsFeature(layer_info.fields())\n    feature['nom'] = layer.name()\n    feature['type'] = QgsWkbTypes.geometryDisplayString(layer.geometryType())\n    feature['nombre_entit\u00e9'] = layer.featureCount()\n    feature['encodage'] = layer.dataProvider().encoding()\n    feature['projection'] = layer.crs().authid()\n    feature['seuil'] = layer.hasScaleBasedVisibility()\n    feature['source'] = layer.publicSource()\n\n    with edit(layer_info):\n        layer_info.addFeature(feature)\n\n# Export de la couche m\u00e9moire au format CSV\noptions = QgsVectorFileWriter.SaveVectorOptions()\noptions.driverName = 'CSV'\noptions.fileEncoding = 'UTF-8'\noptions.layerOptions = ['CREATE_CSVT=YES', 'SEPARATOR=TAB']\n\nbase_name = QgsProject.instance().baseName()\nracine = Path(QgsProject.instance().absoluteFilePath()).parent\noutput_file = racine.joinpath(f'{base_name}.csv')\n\nQgsVectorFileWriter.writeAsVectorFormatV3(\n    layer_info,\n    str(output_file),\n    QgsProject.instance().transformContext(),\n    options,\n)\n</code></pre> <p>Warning</p> <p>Ajouter une couche raster et retester le script ... surprise \ud83c\udf81</p> Pour les experts, ajouter un alias ou un commentaire sur un champ <p><pre><code>field = QgsField(\n    'seuil_visibilite',\n    QVariant.Bool,\n    comment=\"Champ contenant le seuil de visibilit\u00e9\")\nfield.setAlias(\"Seuil de visibilit\u00e9\")\nlayer_info.addAttribute(field)\n</code></pre> Ceci dit, cela d\u00e9pend dans quel format on exporte la couche, dans l'exercice, on fait du CSV, donc on perd ces informations.</p> <p>Tip</p> <p>Pour obtenir en Python la liste des fournisseurs GDAL/OGR : <pre><code>from osgeo import ogr\n[ogr.GetDriver(i).GetDescription() for i in range(ogr.GetDriverCount())]    \n</code></pre> ou dans le menu Pr\u00e9f\u00e9rences \u27a1 Options \u27a1 GDAL \u27a1 Pilotes vecteurs</p>"},{"location":"fonctions-scripts/#finalisation","title":"Finalisation","text":"<p>Id\u00e9alement, il faut v\u00e9rifier le r\u00e9sultat de l'enregistrement du fichier. Les diff\u00e9rentes m\u00e9thodes <code>writeAsVectorFormat</code> retournent syst\u00e9matiquement un tuple avec un code d'erreur et un message si n\u00e9cessaire, voir la documentation.</p> <p>Pour s'en rendre compte, on peut ajouter une variable <code>result = QgsVectorFileWriter.writeAsVectorFormatV3(...)</code>. Puis de faire un <code>print(result)</code> pour s'en rendre compte. On peut tenir compte donc ce tuple :</p> <ul> <li><code>QgsVectorFileWriter.WriterError.NoError</code> \u2192 <code>0</code></li> </ul> <p>De plus, en cas de succ\u00e8s, il est pratique d'avertir l'utilisateur. On peut aussi fournir un lien pour ouvrir l'explorateur de fichier :</p> <pre><code># Affichage d'un message \u00e0 l'utilisateur\niface.messageBar().pushSuccess(\n    \"Export OK des couches \ud83d\udc4d\",\n    (\n        \"Le fichier CSV a \u00e9t\u00e9 enregistr\u00e9 dans \"\n        \"&lt;a href=\\\"{}\\\"&gt;{}&lt;/a&gt;\"\n    ).format(output_file.parent, output_file)\n)\n</code></pre> Pour ajouter le support du message d'erreur <pre><code>if result[0] != QgsVectorFileWriter.WriterError.NoError:\n    print(f\"Erreur : {result[1]}\")\nelse:\n    # Affichage d'un message \u00e0 l'utilisateur\n    iface.messageBar().pushSuccess(\n        \"Export OK des couches \ud83d\udc4d\",\n        (\n            \"Le fichier CSV a \u00e9t\u00e9 enregistr\u00e9 dans \"\n            \"&lt;a href=\\\"{}\\\"&gt;{}&lt;/a&gt;\"\n        ).format(output_file.parent, output_file)\n    )\n</code></pre>"},{"location":"formulaire/","title":"Formulaire","text":"<p>Warning</p> <p>Pensez \u00e0 autoriser les macros dans les  Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros</p> <p></p> <p>On peut personnaliser un formulaire avec :</p> <ul> <li>un fichier QtDesigner, m\u00eame si on recommande l'utilisation du mode Drag&amp;Drop qui permet de cr\u00e9er des onglets   et des cat\u00e9gories.</li> <li>un fichier Python afin de modifier le comportement du formulaire, ajouter des boutons, modifier la CSS etc</li> </ul> <p>Tip</p> <p>Le blog de Nathan est une bonne ressource concernant les formulaires et QtDesigner pour cette partie la, mais cela commence \u00e0 \u00eatre vieux.</p> <p>Sur la couche Geopackage, dans les propri\u00e9t\u00e9s de la couche \u27a1 Formulaire d'attributs, cliquer sur le petit logo Python en haut bleu et jaune. Choisir l'option Fournir le code dans cette bo\u00eete de dialogue.</p> <p>Dans le nom de la fonction, mettre <code>my_form_open</code> qui correspond \u00e0 l'exemple du code en dessous.</p> <p>La fonction <code>my_form_open</code> sera donc ex\u00e9cut\u00e9 par d\u00e9faut lors de l'ouverture du formulaire. On remarque qu'il y a trois param\u00e8tres qui sont donn\u00e9s :</p> <ul> <li><code>dialog</code> \u27a1 QgsAttributeForm qui h\u00e9rite de QWidget</li> <li><code>layer</code> \u27a1 QgsVectorLayer</li> <li><code>feature</code> \u27a1 QgsFeature</li> </ul> <p>Dans l'objet <code>dialog</code> :</p> <ul> <li>essayons de rechercher les boutons en bas OK et Annuler</li> <li>ajoutons le bouton Aide pour ouvrir une page internet d'aide</li> </ul> <p>Pour information :</p> <ul> <li><code>QWidget::findChild(NOM_CLASSE)</code> retourne un objet de la NOM_CLASSE sp\u00e9cifi\u00e9 dans le widget courant. Ce n'est pas une cha\u00eene de caract\u00e8re bien une classe qu'il faut donner.</li> <li><code>QWidget::findChild(NOM_CLASSE, \"nom_objet\")</code>, idem que ci-dessus, mais permet de filtrer avec le nom de l'objet, tr\u00e8s utile sur les champs.</li> <li>La barre des boutons est une <code>QDialogButtonBox</code></li> <li>Pour ouvrir une URL : <code>QDesktopServices</code></li> </ul> Afficher <pre><code>from qgis.PyQt.QtCore import QUrl\nfrom qgis.PyQt.QtWidgets import QWidget, QDialogButtonBox\nfrom qgis.PyQt.QtGui import QDesktopServices\n\ndef my_form_open(dialog, layer, feature):\n    button_box = dialog.findChild(QDialogButtonBox)\n    button_box.setStandardButtons(QDialogButtonBox.Cancel|QDialogButtonBox.Help|QDialogButtonBox.Ok)\n\n    button_box.button(QDialogButtonBox.Help).clicked.connect(open_help)\n\ndef open_help():\n    QDesktopServices.openUrl(QUrl('https://docs.3liz.org/'))\n</code></pre> <ul> <li>Appliquons une CSS sur le champ <code>type</code> pour mettre un fond rouge :</li> </ul> <p><pre><code>type_field = dialog.findChild(QLineEdit, \"type\")\ntype_field.setStyleSheet(\"background-color: rgba(255, 107, 107, 150);\")\n</code></pre> * On souhaite rendre le champ en rouge seulement s'il y a une condition :</p> <pre><code>type_field = dialog.findChild(QLineEdit, \"type\")\ntype_field.textChanged.connect(type_field_changed)\n\ndef type_field_changed():\n    type_field = dialog.findChild(QLineEdit, \"type\")\n    if type_field.text() not in ('studio', 'appartement', 'maison'):\n        type_field.setStyleSheet(\"background-color: rgba(255, 107, 107, 150);\")\n        type_field.setToolTip(\"La valeur doit \u00eatre 'studio', 'appartement' ou 'maison'.\")\n    else:\n        type_field.setStyleSheet(\"\")\n        type_field.setToolTip()\n</code></pre> <ul> <li>Cherchons le champ <code>surface</code> et calculons la surface avec la g\u00e9om\u00e9trie.</li> </ul> <p>Info</p> <p>Notons que ce ne sont que des exemples des fonctionnalit\u00e9s Python. On peut faire ces masques de saisie \u00e0 l'aide des expressions QGIS ou simplement en changeant le type de widget pour un champ en particulier.</p>"},{"location":"ide-git/","title":"Python avanc\u00e9","text":""},{"location":"ide-git/#utilisation-dun-ide","title":"Utilisation d'un IDE","text":"<p>Pour \u00e9crire du code Python, on peut utiliser n'importe quel \u00e9diteur de texte brut quelque soit l'OS. Cependant, l'utilisation d'un \u00e9diteur de texte qui \"comprend\" le code Python est vivement recommand\u00e9, car il peut vous signaler quelques erreurs facilement d\u00e9tectables, telles que les imports manquants. Comme \u00e9diteur de texte, il en existe plusieurs.</p> <p>Si vous souhaitez faire plus de programmation, nous vous recommandons l'utilisation d'un IDE. Il embarque l'\u00e9diteur de texte ci-dessus, mais poss\u00e8de aussi des outils de debugs et d'assistance dans l'\u00e9criture du code comme l'autocompl\u00e9tion.</p> <p>En IDE gratuit, il existe : </p> <ul> <li>Visual Studio en ajoutant les extensions Python</li> <li>PyCharm Community, d\u00e9di\u00e9 au langage Python</li> </ul> <p>Un IDE est outil tr\u00e8s complet pour d\u00e9veloppement. Il est possible de coder en Python avec un \u00e9diteur de texte, mais si possible qui sait quand m\u00eame faire de la coloration syntaxique du code Python est vraiment un plus (NotePad++\u2026).</p>"},{"location":"ide-git/#lancer-un-script-python-dans-la-console","title":"Lancer un script Python dans la console","text":"<p>Si vous utilisez un IDE pour \u00e9crire du code Python, vous pouvez lancer le code Python dans la console Python \u00e0 l'aide de cette astuce.</p> <ul> <li>Ouvrir l'\u00e9diteur de script Python (pas juste la console)</li> <li>Tapez <code>print(\"bonjour\")</code> dans le panneau de droite</li> <li>Lancer le script avec la fl\u00e8che verte</li> <li>Copier/coller la ligne qui permet de lancer le script et modifier le chemin pour pointer vers le fichier sur votre disque.   Elle ressemble \u00e0 <code>exec(Path('/chemin/vers/fichier.py').read_text())</code>.</li> </ul>"},{"location":"ide-git/#utilisation-de-git","title":"Utilisation de GIT","text":"<p>Il est vivement recommand\u00e9 d'utiliser GIT :</p> <ul> <li>sauvegarde de son code sur un serveur (public ou priv\u00e9)</li> <li>versionner son code et suivre les modifications</li> <li>simplifier le travail d'\u00e9quipe</li> </ul> <p>La documentation : https://git-scm.com/docs/</p> <p>Les commandes les plus utiles :</p> <ul> <li><code>git commit</code> : https://git-scm.com/docs/git-commit/fr</li> <li><code>git add</code> : https://git-scm.com/docs/git-add/fr</li> <li><code>git push</code> : https://git-scm.com/docs/git-push/fr</li> <li><code>git pull</code> : https://git-scm.com/docs/git-pull/fr</li> </ul> <p>Liens vers OpenClassRooms :</p> <ul> <li>https://openclassrooms.com/fr/courses/1233741-gerez-vos-codes-source-avec-git</li> <li>https://openclassrooms.com/fr/courses/5641721-utilisez-git-et-github-pour-vos-projets-de-developpement</li> </ul>"},{"location":"legende/","title":"Objectif","text":"<p>\u00c0 travers ce TP, on va traiter plusieurs points : </p> <ul> <li>jointure d'une couche ODS pour r\u00e9cup\u00e9rer des populations</li> <li>appeler un algorithme Processing pour agr\u00e9ger les donn\u00e9es</li> <li>retravailler la l\u00e9gende afin d'afficher le nom de la commune et la population dans le libell\u00e9</li> </ul> <p>METTRE PHOTO l\u00e9gende</p>"},{"location":"legende/#donnees","title":"Donn\u00e9es","text":"<p>On peut placer les deux fichiers l'un \u00e0 c\u00f4t\u00e9 de l'autre. Ouvrir dans QGIS le fichier GPKG seulement.</p> <ul> <li>L'agglom\u00e9ration de Montpellier d'OpenStreetMap</li> <li>Fichier tableur avec les populations de l'INSEE</li> </ul>"},{"location":"legende/#objectif_1","title":"Objectif","text":"<pre><code>from pathlib import Path\n\nlayer = iface.activeLayer()\n\nparent_folder = Path(layer.source()).parent\n\nprint(parent_folder)\n\nfichier_ods = parent_folder / \"base_cc_comparateur.ods\"\nprint(fichier_ods.is_file())\n\ntableur = QgsVectorLayer(str(fichier_ods), \"tableur\", \"ogr\")\nprint(tableur.isValid())\n</code></pre>"},{"location":"memo-python/","title":"Introduction au language Python","text":""},{"location":"memo-python/#quest-ce-que-python","title":"Qu'est-ce que Python ?","text":"<ul> <li>Multi-usage (WEB, application graphique, script, serveur etc)</li> <li>Programmation Orient\u00e9e Objet (POO)<ul> <li>Tout est objet</li> </ul> </li> <li>Interpr\u00e9t\u00e9</li> <li>Centr\u00e9 sur la lecture et la productivit\u00e9<ul> <li>Syntaxe du code simple</li> </ul> </li> <li>Grosse communaut\u00e9<ul> <li>De nombreux packages disponibles sur internet sur PyPi.org</li> </ul> </li> </ul> <p>Exemple d'un code qui d\u00e9clare une variable et compare si sa valeur est sup\u00e9rieur \u00e0 5 afin d'afficher un message :</p> <pre><code># D\u00e9claration d'une variable de type entier\nx = 10\n\n# D\u00e9claration d'une variable cha\u00eene de caract\u00e8re\ninfo = 'X est sup\u00e9rieur \u00e0 5'\n\nif x &gt; 5:\n    print(info)\n</code></pre>"},{"location":"memo-python/#versions","title":"Versions","text":"<ul> <li>Python 2<ul> <li>Sortie en 2000</li> <li>Il a \u00e9t\u00e9 tr\u00e8s utilis\u00e9, notamment sur les tutoriels sur internet et quelques projets qui tardent \u00e0  se mettre \u00e0 jour</li> <li>Une adoption massive (QGIS 2)</li> <li>Derni\u00e8re version le 1 janvier 2020</li> </ul> </li> <li>Python 3<ul> <li>Sortie en 2008, mais il s'agit d'une adoption tr\u00e8s lente, tellement Python 2 a \u00e9t\u00e9 massivement adopt\u00e9.</li> <li>Derni\u00e8re version 3.13.X du 7 octobre 2024</li> <li>1 version majeure par an, en octobre</li> <li>QGIS 3 requiert :<ul> <li>Python 3.5 minimum for QGIS 3.4</li> <li>Python 3.6 minimum for QGIS 3.18</li> <li>Python 3.7 minimum for QGIS 3.20</li> <li>Python 3.9 minimum for QGIS 3.40</li> </ul> </li> <li>Version de Python souvent sup\u00e9rieure \u00e0 la version minimum, sauf sur MacOS\u2026 \ud83d\ude11</li> <li>Python release cycle</li> </ul> </li> </ul>"},{"location":"memo-python/#rappel-de-base-sur-python","title":"Rappel de base sur Python","text":"<ul> <li>Un m\u00e9mo Python plus important sur W3Schools</li> <li>Docteur Python et son m\u00e9mo</li> <li>Un cours Python sur OpenClassRooms</li> </ul>"},{"location":"memo-python/#la-console","title":"La console","text":"<p>Pour la suite de la formation, nous allons utiliser la console Python de QGIS.</p> <p>Dans le menu Extensions \u27a1 Console Python.</p> <p>Tip</p> <p>Souvent, avec Windows, il y a un conflit avec un raccourci clavier pour taper le caract\u00e8re <code>{</code> ou <code>}</code> dans la console.</p> <p>Ces caract\u00e8res sont utilis\u00e9s en Python. Il est donc conseill\u00e9 de supprimer ce raccourci clavier. Il s'agit du \"zoom + secondaire\" dans QGIS \u2192 menu Pr\u00e9f\u00e9rences \u27a1 Raccourcis clavier.</p>"},{"location":"memo-python/#les-types-de-donnees","title":"Les types de donn\u00e9es","text":"<p>Une variable peut contenir un entier, un bool\u00e9en (<code>True</code> ou <code>False</code>), cha\u00eene de caract\u00e8res, nombre d\u00e9cimal, un objet... Il y a un faible typage des variables, c'est-\u00e0-dire qu'une variable peut changer de type au cours de l'ex\u00e9cution du programme.</p> <pre><code># Pour cr\u00e9er une variable, on d\u00e9clare juste le nom de la variable ainsi que sa valeur :\ncompteur = 0\n</code></pre> <p>Nous allons par la suite utiliser <code>type(variable)</code> pour v\u00e9rifier le type de la variable.</p> <pre><code>mon_compteur = 0\ntype(mon_compteur)\n&lt;class 'int'&gt;\n\nest_valide = False\ntype(est_valide)\n&lt;class 'bool'&gt;\n\nnom_couche = 'communes'\ntype(nom_couche)\n&lt;class 'str'&gt;\n\nnom_couche = \"communes\"\ntype(nom_couche)\n&lt;class 'str'&gt;\n\ntexte = 'Bonjour je m\\'appelle \"Olivier\"'\ntype(texte)\n&lt;class 'str'&gt;\n\ndensite = 3.5\ntype(densite)\n&lt;class 'float'&gt;\n\nnom_couche = None\ntype(nom_couche)\n&lt;class 'NoneType'&gt;\n</code></pre>"},{"location":"memo-python/#les-structures-de-donnees","title":"Les structures de donn\u00e9es","text":"<p>Il existe quatre types de structure de donn\u00e9es :</p> <ul> <li> <p>les variables simples (ci-dessus)</p> </li> <li> <p>les listes (modifiables)</p> </li> </ul> <p>Tip</p> <p>Documentation Python sur les listes</p> <pre><code># Cr\u00e9er une liste vide\nnombres = []\ntype(nombres)\n&lt;class 'list'&gt;\n\n# Cr\u00e9er une liste avec des \u00e9l\u00e9ments \u00e0 l'int\u00e9rieur\nmois = ['janvier', 'f\u00e9vrier', 'mars']\n\n# Ajouter un \u00e9l\u00e9ment\nmois.append('avril')\n# Ajouter une autre liste\nmois.extend(['mai', 'juin'])\n\n# Nombre de mois\nlen(mois)\n\n# Supprimer un \u00e9l\u00e9ment\ndel mois[1]\n\n# On peut acc\u00e9der \u00e0 un \u00e9l\u00e9ment avec un \"index\" \u00e0 l'aide de []\nmois[2]\n\n# Attention \u00e0 l'index maximum\nmois[12]\nTraceback (most recent call last):\n  File \"/usr/lib/python3.12/code.py\", line 90, in runcode\n    exec(code, self.locals)\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\nIndexError: tuple index out of range\n</code></pre> <ul> <li>les tuples, comme des listes, mais non modifiables</li> </ul> <p>Tip</p> <p>Documentation Python sur les tuples</p> <pre><code>liste = ('route double sens', 'route sens unique')\ntype(liste)\n&lt;class 'tuple'&gt;\nlen(liste)\n2\nliste[0]\n\nliste[5]\nTraceback (most recent call last):\n  File \"/usr/lib/python3.12/code.py\", line 90, in runcode\n    exec(code, self.locals)\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\nIndexError: tuple index out of range\n</code></pre> <ul> <li>les dictionnaires</li> </ul> <p>Attention, les dictionnaires ne sont pas ordonn\u00e9s, de fa\u00e7on native, m\u00eame depuis Python 3.9. Si vraiment, il y a besoin, il existe une classe OrderedDict, mais ce n'est pas une structure de donn\u00e9es native dans Python. C'est un objet qu'il faut importer.</p> <pre><code>commune = {}\ntype(commune)\n# &lt;class 'dict'&gt;\ncommune['nom'] = 'Besan\u00e7on'\ncommune['code_insee'] = 25056\ncommune['est_prefecture'] = True\n\n# Ou directement lors de la cr\u00e9ation de la variable :\ncommune = {'nom': 'Besan\u00e7on', 'code_insee': 25056, 'est_prefecture': True}\n\n# Lire le contenu d'une cl\u00e9 :\nprint(commune['nom'])\nprint(commune['population'])  # Leve une erreur IndexError\nprint(commune.get('population'))  # Imprime None\n</code></pre>"},{"location":"memo-python/#les-commentaires","title":"Les commentaires","text":"<p>Pour commenter le code dans un script, pas dans la console : </p> <pre><code># Ceci est un commentaire sur une ligne\n\n\"\"\" Ces lignes sont r\u00e9serv\u00e9s pour la documentation de l'API et ne doivent pas \u00eatre des lignes de commentaires. \"\"\"\n</code></pre>"},{"location":"memo-python/#arithmetique","title":"Arithm\u00e9tique","text":"<pre><code>a = 10\n# Op\u00e9rateurs de base\nb = a + 1\nc = a - 1\nd = a * 2\ne = a / 2\n\n# Les espaces ne sont pas importants\n# 1+2 ou 1 + 2 sont \u00e9quivalents\n\n# Il est souvent utile de faire de l'incr\u00e9mentation ou d\u00e9cr\u00e9mentation d'une variable :\na = a + 1\n# mais on \u00e9crit plus souvent\na += 1\n# On peut changer le pas d'incr\u00e9mentation ou alors faire de la d\u00e9cr\u00e9mentation\na -= 1 # Diminuer de 1\na += 5 # Incr\u00e9menter de 5\n\n\na = 10\nf = a % 3  # Fonction \"modulo\", r\u00e9sultat 1\ng = a ** 2  # Fonction puissance, r\u00e9sultat 100\n</code></pre>"},{"location":"memo-python/#concatener-des-chaines-et-des-variables","title":"Concat\u00e9ner des cha\u00eenes et des variables","text":"<p>Concat\u00e9ner, c'est assembler des cha\u00eenes de caract\u00e8res dans une seule et m\u00eame sortie. On peut concat\u00e9ner des variables entre elles ou du texte.</p> <p>Il existe plein de mani\u00e8res de faire, mais certaines sont plus pratiques que d'autres <pre><code># Non recommand\u00e9\na = 'bon'\nb = 'jour'\na + b  # 'bonjour'\nc = 1\na + c  # Erreur\na + str(c)  # Marche\n</code></pre></p> <p>\u00c0 l'ancienne avec <code>%</code> <pre><code>prenom = 'Pierre'\nnumero_jour = 2\nbienvenue = 'Bonjour %s !' % prenom\nbienvenue = 'Bonjour %s, nous sommes le %s novembre' % (prenom, numero_jour)\n</code></pre></p> <p>Nouveau avec <code>{}</code> et <code>format</code> <pre><code>prenom = 'Pierre'\nnumero_jour = 2\nbienvenue = 'Bonjour {} !'.format(prenom)\nbienvenue = 'Bonjour {}, nous sommes le {} novembre'.format(prenom, numero_jour)\nbienvenue = 'Bonjour {prenom}, nous sommes le {jour} novembre'.format(prenom=prenom, jour=numero_jour)\n</code></pre></p> <p>Warning</p> <p>Attention \u00e0 la port\u00e9e des variables.</p> <p>Encore plus moderne avec <code>fstring</code> <pre><code>prenom = 'Pierre'\nnumero_jour = 2\nbienvenue = f'Bonjour {prenom} !'\nbienvenue = f'Bonjour {prenom}, nous sommes le {numero_jour} novembre'\n</code></pre></p>"},{"location":"memo-python/#operateurs-logiques","title":"Op\u00e9rateurs logiques","text":"<pre><code>a &gt; b\na &gt;= b\na &lt; b\na &lt;= b\na == b\na != b\n\n# Dans plusieurs langages, pour v\u00e9rifier si \"a\" est entre deux bornes :\n0 &lt; a and a &lt; 10\n# En Python, on peut faire\n0 &lt; a &lt; 10\n\n# Pour les objets\na is b\na is not b\na in b\n</code></pre>"},{"location":"memo-python/#condition","title":"Condition","text":"<p>Important, Python oblige l'indentation sinon il y a une erreur. Par convention, il s'agit de 4 espaces. </p> <pre><code>note = 13\nif note &gt;= 16:\n    if note == 20:\n        print('Toutes mes f\u00e9licitations')\n    else:\n        print('F\u00e9licitations')\nelif 14 &lt;= note &lt; 16:\n    print('Tr\u00e8s bien')\nelif 12 &lt;= note &lt; 14:\n    print('Bien')\nelse:\n    print('Peu mieux faire')\n</code></pre>"},{"location":"memo-python/#boucle-for","title":"Boucle for","text":"<p>Utile lors que l'on connait le nombre de r\u00e9p\u00e9titions avant l'ex\u00e9cution de la boucle.</p> <pre><code>countries = ['Allemagne', 'Espagne', 'France']\nfor country in countries:\n    print(f'Pays : {country}')\n\nfor x in range(10):\n    print(x)\n\nregions = {\n    'Auvergne-Rh\u00f4ne-Alpes': 'Lyon',\n    'Bourgogne-Franche-Comt\u00e9': 'Dijon',\n    'Bretagne': 'Rennes',\n    'Centre-Val de Loire': 'Orl\u00e9ans',\n}\n\nfor region in regions:\n    print(region)\n\nfor region in regions.keys():\n    print(region)\n\nfor city in regions.values():\n    print(city)\n\nfor region, city in regions.items():\n    print(f'R\u00e9gion {region} dont le chef lieu est {city}')\n\n# Non recommand\u00e9, mais on peut le rencontrer\nfor region in regions.keys():\n  print(f\"R\u00e9gion {region} dont le chef lieu est {regions[region]}\")\n</code></pre>"},{"location":"memo-python/#recherche-dun-element","title":"Recherche d'un \u00e9l\u00e9ment","text":"<pre><code>countries = ['Allemagne', 'Espagne', 'France']\n\n# Solution simple\nif 'Allemagne' in countries:\n    print('Pr\u00e9sent')\nelse:\n    print('Non pr\u00e9sent')\n\n# Plus complexe, avec une fonction pour les minuscules\npresent = False\nfor country in countries:\n    if country.lower() == 'allemagne':\n        present = True\nif present:\n    print('Pr\u00e9sent')\nelse:\n    print('Non pr\u00e9sent')\n\n\n# Le plus pythonique\nfor country in countries:\n    if country.lower() == 'allemagne':\n        print('Pr\u00e9sent')\n        break\nelse:\n    print('Non pr\u00e9sent')\n\n# Encore plus pythonique avec une list-comprehension, voir plus bas\n</code></pre>"},{"location":"memo-python/#boucle-while","title":"Boucle while","text":"<p>Contrairement \u00e0 la boucle <code>for</code>, on ne connait pas forc\u00e9ment le nombre d'ex\u00e9cution de la boucle en lisant uniquement la ligne <code>while</code>.</p> <pre><code>x = 0\nwhile x &lt; 10:\n    print(x)\n    x += 1\n</code></pre> <p>Error</p> <p>Attention \u00e0 ne pas faire une boucle infinie !</p> <ul> <li>En Python, il n'y a pas de boucle <code>do ... while</code>, \u00e0 la place, on peut faire ainsi :</li> </ul> <pre><code>executer_une_fonction()\nwhile not conditon_echec:\n    executer_une_fonction()\n</code></pre>"},{"location":"memo-python/#switch","title":"Switch","text":"<p>Python 3.10 minimum</p> <pre><code>numero_jour = 2\n\nmatch numero_jour:\n  case 1:\n    print('Lundi')\n  case 2:\n    print('Mardi')\n  case 3:\n    print('Mercredi')\n  case 4:\n    print('Jeudi')\n  case 5:\n    print('Vendredi')\n  case 6:\n    print('Samedi')\n  case 7:\n    print('Dimanche')\n  case _:\n    print('Pas un jour de la semaine')\n</code></pre> Avant Python 3.10 avec un <code>if elif</code> <pre><code>numero_jour = 2\n\nif numero_jour == 1:\n    print('Lundi')\nelif numero_jour == 2:\n    print('Mardi')\nelif numero_jour == 3:\n    print('Mercredi')\nelif numero_jour == 4:\n    print('Jeudi')\nelif numero_jour == 5:\n    print('Vendredi')\nelif numero_jour == 6:\n    print('Samedi')\nelif numero_jour == 7:\n    print('Dimanche')\nelse:\n    print('Pas un jour de la semaine')\n</code></pre>"},{"location":"memo-python/#list-comprehensions","title":"List Comprehensions","text":"<p>C'est une fa\u00e7on tr\u00e8s pythonique et tr\u00e8s utilis\u00e9e de cr\u00e9er des listes.</p>"},{"location":"memo-python/#pour-transformer-une-liste-existante-en-la-remplacant","title":"Pour transformer une liste existante, en la rempla\u00e7ant :","text":"<pre><code>countries = ['Allemagne', 'Espagne', 'France']\ncountries = [c.upper() for c in countries]\n</code></pre> <p>Par exemple, cr\u00e9er une liste des nombres impairs entre 1 et 9 :</p> <pre><code># Non pythonique\nimpair = []\nfor x in range(10):\n    if x % 2:\n        impair.append(x)\n\n# Pythonique\nimpair = [x for x in range(10) if x % 2]\n</code></pre> <ul> <li>Il existe aussi les Dict Comprehensions (moins utilis\u00e9)</li> </ul>"},{"location":"memo-python/#manipulation-sur-les-chaines-de-caracteres","title":"Manipulation sur les cha\u00eenes de caract\u00e8res","text":"<p>Slicing sur les mois de l'ann\u00e9e :</p> <pre><code>mois = ['Janvier', 'F\u00e9vrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Octobre', 'Novembre', 'D\u00e9cembre']\n\nmois[0:2]\n['Janvier', 'F\u00e9vrier']\n\nmois[2:]\n['Mars', 'Avril', 'Mai', 'Juin', 'Octobre', 'Novembre', 'D\u00e9cembre']\n\nmois[:-2]\n['Janvier', 'F\u00e9vrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Octobre']\n\nmois[-2:]\n['Novembre', 'D\u00e9cembre']\n</code></pre> <ul> <li>Pour information, les cha\u00eenes de caract\u00e8res sont des listes et on peut faire du slicing sur des listes :</li> </ul> <pre><code>alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nlen(alphabet)\n','.join(alphabet)\nalphabet.lower()\nalphabet.upper()\nalphabet[1]  # B\nalphabet[1:3]  # BC\nalphabet[-1]  # Z\nalphabet[-3:]  # XYZ\nalphabet[:6]  # ABCDEF\n</code></pre>"},{"location":"memo-python/#fonctions","title":"Fonctions","text":"<p>Une fonction permet de factoriser son code. Elle peut :</p> <ul> <li>ne pas prendre de param\u00e8tre en entr\u00e9e</li> <li>prendre un ou plusieurs param\u00e8tres en entr\u00e9e</li> <li>ces entr\u00e9es peuvent avoir des valeurs par d\u00e9faut, on n'est donc pas oblig\u00e9 de les fournir de lors l'appel de la fonction</li> <li>une fonction peut ne rien retourner, (pas d'instructions <code>return</code> ou alors <code>return None</code>)</li> <li> <p>ou alors retourner une ou plusieurs valeurs (cela sera implicitement une liste)</p> </li> <li> <p>Voici des exemples de fonction Python. Encore une fois, attention \u00e0 l'indentation !</p> </li> </ul> <pre><code>def ajouter(x, y):\n    \"\"\"Ajouter deux nombres.\"\"\"\n    return x + y\n\ndef crier(phrase='bonjour'):\n    print(phrase.upper())\n\ndef discuter(texte, personnage='Charles'):\n    \"\"\"Un personnage discute.\"\"\"\n    print('{}: \"{}\"'.format(personnage, texte))\n\ndef discuter(texte, personnage='Charles'):\n    \"\"\"Un personnage discute.\"\"\"\n    return f'{personnage}: \"{texte}\"'\n</code></pre> <ul> <li>Une fonction peut retourner plusieurs valeurs :</li> </ul> <pre><code>def decomposer(entier, diviser_par):\n    \"\"\"Retourne la partie enti\u00e8re et le reste d'une division.\"\"\"\n    partie_entiere = entier / diviser_par\n    reste = entier % diviser_par\n    return int(partie_entiere), reste\n</code></pre> <ul> <li>Il se peut que l'on ne connaisse pas \u00e0 l'avance le nombre pr\u00e9cis d'arguments dans une fonction.<ul> <li><code>args</code> est utilis\u00e9 pour passer un nombre ind\u00e9termin\u00e9 d'arguments \u00e0 la fonction</li> <li><code>kwargs</code> est utilis\u00e9 pour un nombre ind\u00e9termin\u00e9 d'arguments nomm\u00e9s</li> </ul> </li> </ul> <pre><code>def une_fonction(*args, **kwargs):\n    print('Les arguments')\n    for arg in args:\n        print(arg)\n    print('Les arguments non nomm\u00e9s')\n    for key, value in kwargs.items():\n        print('{} -&gt; {}'.format(key, value))\n\nune_fonction(1,2,3, text='Ma phrase')\n</code></pre>"},{"location":"memo-python/#poo-programmation-orientee-objet","title":"POO : Programmation Orient\u00e9e Objet","text":"<p>Pour l'explication th\u00e9orique, lire l'introduction dans le chapitre de la console.</p> <p>On peut introduire l'utilisation de la POO \u00e0 l'aide de l'objet <code>Path</code>. La documentation de cette classe se trouve en ligne.</p> <p>La librairie <code>Path</code> est install\u00e9 de base avec Python.</p> <p>La programmation orient\u00e9e objet permet de cr\u00e9er un objet (on parle plus pr\u00e9cis\u00e9ment d'instancier) puis on peut appeler des m\u00e9thodes sur cet objet.</p> <p>Dans une console QGIS :</p> <pre><code>from pathlib import Path\n# Appel du \"constructeur\"\nchemin = Path('.')\n# La notation . est une cha\u00eene de caract\u00e8re particuli\u00e8re pour un OS demandant le dossier courant de l'ex\u00e9cution.\n# On peut utiliser .. pour faire r\u00e9f\u00e9rence au dossier parent\nprint(chemin.absolute())\nprint(chemin.is_dir())\nun_fichier = chemin / 'mon_projet.qgs'\nprint(un_fichier.exists())\nprint(un_fichier.name)\nprint(un_fichier.name)\nprint(chemin.joinpath('mon_projet.qgs').exists())\n</code></pre> <p>Tip</p> <p>Quand l'instruction se termine par des <code>()</code>, on dit que c'est une m\u00e9thode de cet objet. Il s'agit d'une fonction, qui peut prendre ou non des param\u00e8tres et qui peut renvoyer ou non des r\u00e9sultats en sortie.  Quand l'instruction ne se termine pas par <code>()</code>, on acc\u00e8de \u00e0 une propri\u00e9t\u00e9 de l'objet.</p> <p>Pour une application avec des objets QGIS, il faut lire le chapitre suivant sur la console ou encore la partie sur l'\u00e9criture d'un script Processing.</p>"},{"location":"memo-python/#exceptions","title":"Exceptions","text":"<p>Lire le chapitre sur le parcours des entit\u00e9s.</p>"},{"location":"memo-python/#truc-et-astuces","title":"Truc et astuces","text":""},{"location":"memo-python/#passage-par-reference","title":"Passage par r\u00e9f\u00e9rence","text":"<p>Warning</p> <p>Attention au passage par r\u00e9f\u00e9rence : <pre><code>ma_liste_1 = [1, 2, 3]\nma_liste_2 = ma_liste_1\nma_liste_2.append(4)\nprint(ma_liste_2)\nprint(ma_liste_1)\n</code></pre></p>"},{"location":"memo-python/#enumerate","title":"Enumerate","text":"<p>Avoir un compteur lors de l'it\u00e9ration d'une liste : <pre><code>users = ['Tom', 'James', 'John']\nfor i, user in enumerate(users):\n    print('{} -&gt; {}'.format(i + 1, user))\n</code></pre></p>"},{"location":"memo-python/#annotations","title":"Annotations","text":"<p>Dans la suite de la formation, il est possible de voir des annotations Python. Cela permet de sp\u00e9cifier le type des variables dans les param\u00e8tres des fonctions et/ou de d\u00e9finir le type de retour.</p> <pre><code>from typing import Tuple\ndef decomposer(entier: int, diviser_par: int) -&gt; Tuple[int, int]:\n    \"\"\"Retourne la partie enti\u00e8re et le reste d'une division.\"\"\"\n    partie_entiere = entier / diviser_par\n    reste = entier % diviser_par\n    return int(partie_entiere), reste\n</code></pre> <p>Il faut lire la documentation des annotations pour voir les diff\u00e9rentes possibilit\u00e9s.</p>"},{"location":"memo-python/#signal-et-slot","title":"\"Signal\" et \"slot\"","text":"<p>Lire le passage dans Signaux et slots.</p>"},{"location":"memo-python/#terminologie","title":"Terminologie","text":"<ul> <li>Package</li> <li>Module</li> <li>Classe</li> <li>Instance / Objet</li> <li>Variable</li> </ul>"},{"location":"migration-majeure/","title":"Migration majeure au sein de PyQGIS","text":"<p>Lire la page recensant les \"breaking changes\" de QGIS de toutes les versions.</p>"},{"location":"migration-majeure/#qgis-2-qgis-3","title":"QGIS 2 \u2192 QGIS 3","text":"<ul> <li>QGIS 2, c'\u00e9tait Python 2 et Qt 4</li> <li>QGIS 3, Python 3 et Qt 5</li> </ul> <p>Petit guide sur une migration vers QGIS 3.</p>"},{"location":"migration-majeure/#qt-5-qt-6","title":"Qt 5 \u2192 Qt 6","text":"<p>QGIS tente de passer de la version Qt 5 vers Qt 6, sans passer par la case QGIS 4.0 (et donc non \"cassage\" de l'API QGIS 3.X).</p> <p>Le travail de migration a commenc\u00e9 depuis QGIS 3.34. Mais \u00e0 l'heure actuelle, fin 2024, il n'existe qu'un binaire de QGIS pour tester Qt 6. C'est pour le moment, \"sous le capot\" de QGIS que cela se passe. </p> <p>Contrairement au passage Qt 4 vers Qt 5, il est possible de rendre une extension compatible pour les deux versions \u00e0 l'aide d'un script que l'on peut trouver dans l'autre petit guide pour une migration vers Qt 6.</p> <p>Par exemple, l'extension Lizmap avec le commit qui ajoute la compatibilit\u00e9 Qt 6.</p>"},{"location":"postgis/","title":"PostGIS","text":""},{"location":"postgis/#psycopg","title":"Psycopg","text":"<p>En Python, il existe un package d\u00e9di\u00e9 \u00e0 PostgreSQL, il s'agit de Psycopg. Il s'agit d'un package totalement ind\u00e9pendant de QGIS.</p> <p>Exemple pour r\u00e9cup\u00e9rer les tables pr\u00e9sentes dans une base de donn\u00e9es \u00e0 l'aide de SQL</p> <pre><code>import psycopg\n\ninspect_schema = \"mon_schema\"\n\nconnection = psycopg.connect(\n    user=\"docker\", password=\"docker\", host=\"db\", port=\"5432\", database=\"gis\"\n)\ncursor = connection.cursor()\ncursor.execute(\n    f\"SELECT table_name FROM information_schema.tables WHERE table_schema = '{inspect_schema}'\"\n)\nrecords = cursor.fetchall()\nprint(records)\n</code></pre>"},{"location":"postgis/#pyqgis","title":"PyQGIS","text":"<p>Depuis QGIS 3.16, il existe de plus en plus de m\u00e9thodes dans la classe QgsAbstractDatabaseProviderConnection pour interagir avec une base de donn\u00e9es PostGIS.</p> <pre><code>from qgis.core import QgsProviderRegistry\n\nmetadata = QgsProviderRegistry.instance().providerMetadata('postgres')\nconnection = metadata.findConnection(\"nom de la connexion PG dans votre panneau\")\n\n# Faire une requ\u00eate SQL (ou plusieurs)\n# Besoin d'\u00e9chapper en utilisant \"\" si votre sch\u00e9ma ou table comporte des majuscules\nresults = connection.executeSql(\"SELECT * FROM \\\"schema\\\".\\\"table\\\";\")\nprint(results)\n\n# Cr\u00e9er un sch\u00e9ma\nconnection.createSchema(\"mon_nouveau_schema\")\n\n# Lister les tables\nprint(connection.tables(\"un_schema\"))\n\n# Afficher une table dans QGIS, cela retourne une cha\u00eene de caract\u00e8re\n# permettant de faire une source de donn\u00e9es pour une QgsVectorLayer\nprint(connection.tableUri(\"schema\", \"table\"))\n</code></pre> <p>Afficher une table sans g\u00e9om\u00e9trie :</p> <pre><code>layer = QgsVectorLayer(connection.tableUri(\"schema\", \"table\"), \"Ma table\", \"postgres\")\nlayer.loadDefaultStyle()  # Si un style par d\u00e9faut existe dans votre base PostgreSQL, avec la table layer_styles\nQgsProject.instance().addMapLayer(layer)\n</code></pre> <p>Afficher une table avec g\u00e9om\u00e9trie en partant de <code>QgsDataSourceUri</code> : <pre><code>uri = QgsDataSourceUri(connection.uri())\nuri.setSchema('schema')\nuri.setTable('table')\nuri.setKeyColumn('uid')\n\n# Avec une geom si besoin\nuri.setGeometryColumn('geom')\n\nlayer = QgsVectorLayer(uri.uri(), 'Ma table', 'postgres')\nQgsProject.instance().addMapLayer(layer)\n</code></pre></p> <p>Afficher le r\u00e9sultat d'un <code>SELECT</code> :</p> <pre><code># Notons l'usage des parenth\u00e8ses autour du SELECT\nuri = QgsDataSourceUri(connection.uri())\nuri.setTable('(SELECT * FROM schema.table)')\nuri.setKeyColumn('uid')\n\n# Avec une geom si besoin\nuri.setGeometryColumn('geom')\n\nlayer = QgsVectorLayer(uri.uri(), 'Requ\u00eate SELECT', 'postgres')\nQgsProject.instance().addMapLayer(layer)\n</code></pre> <p>Exemple d'extension</p> <p>Si besoin, l'extension PgMetadata utilise exclusivement l'API \"Base de donn\u00e9es PG\" de QGIS.</p>"},{"location":"python-qgis/","title":"Le python dans QGIS","text":"<p>QGIS permet d'utiliser du Python dans divers emplacement que nous allons voir ci-dessous. Python poss\u00e8de de tr\u00e8s nombreux packages/modules disponibles sur internet qui fournissent des fonctions d\u00e9j\u00e0 \u00e9crites.</p>"},{"location":"python-qgis/#console","title":"Console","text":"<p>La console est accessible par le menu <code>Extension</code> -&gt; <code>Console Python</code>. Elle permet l'\u00e9criture de commande simple, une par une.  On ne peut pas enregistrer les commandes dans un fichier.</p>"},{"location":"python-qgis/#script-python","title":"Script Python","text":"<p>L'\u00e9diteur de script Python est accessible depuis l'ic\u00f4ne d\u00e9di\u00e9e dans la console Python. Il permet un prototypage rapide d'un script. On peut y \u00e9crire du code plus complexe en faisant intervenir des librairies ou des classes.</p> <p></p>"},{"location":"python-qgis/#script-processing","title":"Script Processing","text":"<p>Le menu Traitement dans QGIS donne acc\u00e8s a plusieurs algorithmes d'analyse.  Ces algorithms proviennent soient de QGIS, GDAL ou encore de plugins. La bo\u00eete \u00e0 outils de traitements ainsi que le modeleur graphique utilisent le \"framework\" Processing propre \u00e0  QGIS. Ce framework permet de d\u00e9finir les entr\u00e9es et les sorties d'un algorithme. Les algorithms sont donc  normalis\u00e9s en suivant tous le m\u00eame mod\u00e8le. Processing impose la fa\u00e7on d'\u00e9crire les scripts.</p> <p>\u00c9crire un script compatible QGIS Processing permet l'int\u00e9gration dans ce menu, permet \u00e9galement  l'utilisation de ce-dernier dans un mod\u00e8le ou encore l'utilisation en mode traitement par lot. Le framework peut aussi g\u00e9n\u00e9rer automatiquement l'interface graphique de l'algorithme et le code est optimis\u00e9.</p> <p>Il existe un mod\u00e8le par d\u00e9faut que l'on peut utiliser pour d\u00e9marrer l'\u00e9criture d'un script Processing. Depuis la barre d'outils traitements, <code>Cr\u00e9er un nouveau script depuis un mod\u00e8le.</code> Ce mod\u00e8le utilise la syntaxe Programmation Orient\u00e9e Objet. Depuis QGIS 3.6, on peut \u00e9galement utiliser la syntaxe par d\u00e9corateur <code>@alg</code>.</p> <p>Voir la documentation https://docs.qgis.org/latest/fr/docs/user_manual/processing/scripts.html#the-alg-decorator</p> <p></p>"},{"location":"python-qgis/#un-modele-processing-en-python","title":"Un mod\u00e8le Processing en Python","text":"<p>Depuis QGIS 3.6, on peut d\u00e9sormais exporter un mod\u00e8le de traitement Processing en Python. Il faut faire un clic droit sur un mod\u00e8le dans la bo\u00eete \u00e0 outils puis choisir \"Exporter le mod\u00e8le comme un  algorithme Python\". On peut donc modifier ensuite ce fichier Python afin de rajouter de la logique suppl\u00e9mentaire.</p> <p></p>"},{"location":"python-qgis/#extension-plugin","title":"Extension (plugin)","text":"<ul> <li>Extension c\u00f4t\u00e9 bureautique et m\u00eame c\u00f4t\u00e9 QGIS Serveur.</li> <li>La plupart des plugins sont disponibles sur https://plugins.qgis.org pour le    t\u00e9l\u00e9chargement,  ou sinon ils peuvent \u00eatre install\u00e9s par un dossier ZIP.</li> <li>Afin de d\u00e9velopper une extension :<ul> <li>Utilisation du Plugin Builder https://github.com/g-sherman/Qgis-Plugin-Builder/</li> <li>ou squelette minimum :<ul> <li>L'original https://github.com/wonder-sk/qgis-minimal-plugin</li> <li>Le \"fork\" de la formation https://github.com/Gustry/qgis_minimal_plugin</li> </ul> </li> </ul> </li> <li>Plugin Reloader permet de simplifier le d\u00e9veloppement en \u00e9vitant de recharger QGIS</li> <li>Documentation plugin QGIS Serveur : https://docs.qgis.org/latest/fr/docs/pyqgis_developer_cookbook/server.html</li> </ul>"},{"location":"python-qgis/#fournisseur-processing-dans-une-extension-processing-provider","title":"Fournisseur Processing dans une extension (Processing Provider)","text":"<p>Similaire au script Processing, une extension QGIS peut aussi avoir son propre fournisseur d'algorithme.</p> <p></p> <p>On peut remarquer les plugins <code>DataPlotly</code>, <code>QuickOSM</code> etc.</p> <p>Ajout de Processing \u00e0 un plugin QGIS :</p> <ul> <li>soit lors du plugin builder https://github.com/g-sherman/Qgis-Plugin-Builder/</li> <li>ou manuellement en suivant la documentation pour l'ajout \u00e0 un plugin existant :   https://docs.qgis.org/latest/fr/docs/pyqgis_developer_cookbook/processing.html </li> </ul> <p>Il se peut que certaines extensions ne soient que des fournisseurs Processing.</p>"},{"location":"python-qgis/#expressions","title":"Expressions","text":"<p>Les expressions sont souvent pr\u00e9sentes dans QGIS. On peut les utiliser dans nombreux endroits, pour faire des s\u00e9lections, des conditions, etc. On peut \u00e9galement les utiliser \u00e0 chaque fois que vous pouvez voir ce symbole : </p> <p>Un plugin, ou m\u00eame simplement un utilisateur, peut enregistrer ses propres expressions. Ci-dessous, le plugin <code>InaSAFE</code>: </p> <ul> <li>Utilisation de l'API Wikip\u00e9dia pour r\u00e9cup\u00e9rer la description d'un terme :</li> </ul> <p></p>"},{"location":"python-qgis/#macros","title":"Macros","text":"<p>Warning</p> <p>Pensez \u00e0 autoriser les macros dans les  Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros</p> <p>Accessible depuis les propri\u00e9t\u00e9s du projet, dans l'onglet <code>Macros</code>. On peut lancer du code Python  automatiquement soit :</p> <ul> <li>\u00e0 l'ouverture du projet</li> <li>lors de l'enregistrement du projet</li> <li>ou lors de sa fermeture </li> </ul> <p></p>"},{"location":"python-qgis/#formulaire","title":"Formulaire","text":"<p>Warning</p> <p>Pensez \u00e0 autoriser les macros dans les  Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros</p> <p>On peut personnaliser un formulaire par l'ajout de logique Python. Cependant, dans QGIS 3,  l'utilisation de Python n'est plus forc\u00e9ment n\u00e9cessaire, on peut d\u00e9sormais utiliser des expressions  (recommand\u00e9).</p> <p></p>"},{"location":"python-qgis/#actions","title":"Actions","text":"<p>Les actions sont des petits traitements que l'on peut lancer soit depuis la table attributaire ou depuis le canevas. Par exemple, on peut ouvrir un lien WEB ou un PDF en fonction d'un attribut d'une entit\u00e9. Il est possible  d'\u00e9crire les actions en Python.</p> <p>Pour la cr\u00e9ation :</p> <p></p> <p>Pour l'utilisation c\u00f4t\u00e9 utilisateur :</p> <p></p> <p></p>"},{"location":"python-qgis/#applicationscript-independant","title":"Application/script ind\u00e9pendant","text":"<p>Sans lancer QGIS graphiquement, on peut utiliser la librairie QGIS dans nos scripts Python. On peut donc cr\u00e9er notre propre application graphique ou notre propre ex\u00e9cutable et ainsi utiliser les fonctions de QGIS. On peut donc faire un programme en ligne de commande qui effectue une certaine op\u00e9ration dans un r\u00e9pertoire donn\u00e9.</p> <p>Depuis QGIS 3.16, nous pouvons lancer un mod\u00e8le ou un script Processing depuis la ligne de commande depuis l'outil qgis_process.</p>"},{"location":"python-qgis/#le-fichier-startuppy","title":"Le fichier \"startup.py\"","text":"<p>Si l'on place un fichier nomm\u00e9 <code>startup.py</code> dans le dossier Python du profil de l'utilisateur, QGIS va le lancer automatiquement \u00e0 chaque ouverture de QGIS.</p>"},{"location":"script-processing/","title":"Processing","text":"<p>Processing est un framework pour faire des algorithmes dans QGIS.</p> <p>Toute la boite \u00e0 outils Traitement dans QGIS sont des bas\u00e9s sur \"Processing\".</p> <p>Note, depuis QGIS 3.6, il existe d\u00e9sormais une autre syntaxe pour  \u00e9crire script Processing \u00e0 l'aide des d\u00e9corateurs Python. Lire sur Docteur Python pour les d\u00e9corateurs</p>"},{"location":"script-processing/#documentation","title":"Documentation","text":"<p>Pour l'\u00e9criture d'un script Processing, tant en utilisant la POO ou la version avec les d\u00e9corateurs, il y a une page sur la  documentation.</p>"},{"location":"script-processing/#utiliser-processing-en-python-avec-un-algorithme-existant","title":"Utiliser Processing en Python avec un algorithme existant","text":"<ul> <li>Sur une couche en EPSG:2154, faire un buffer de 10 m\u00e8tres par exemple.</li> <li>Cliquer sur la petite horloge dans le panneau de Processing/Traitement en haut</li> <li>Cliquer sur le dernier traitement en haut, puis copier/coller la ligne de Python</li> </ul> <p>On peut appeler un traitement en ligne de commande Python :</p> <pre><code>result = processing.run(\n    \"native:buffer\", \n    {\n        'INPUT': '/chemin/vers/HYDROGRAPHIE/CANALISATION_EAU.shp',\n        'DISTANCE': 10,\n        'SEGMENTS': 5,\n        'END_CAP_STYLE': 0,\n        'JOIN_STYLE': 0,\n        'MITER_LIMIT': 2,\n        'DISSOLVE': False,\n        'OUTPUT': 'TEMPORARY_OUTPUT',\n    }\n)\n# print(result)\n</code></pre> <p>Tip</p> <p>Pour obtenir l'identifiant de l'algorithme, laissez la souris sur le nom de l'algorithme pour avoir son info-bulle dans le panneau traitement.</p> <p>Lien vers la documentation : https://docs.qgis.org/latest/fr/docs/user_manual/processing/console.html</p> <pre><code>QgsProject.instance().addMapLayer(result['OUTPUT'])\n</code></pre> <p>Pour obtenir la description d'un algorithme : <pre><code>processing.algorithmHelp(\"native:buffer\")\n</code></pre></p> <p>Exercice, faire une 3 tampons sur la m\u00eame couche vecteur, distance 10, 20 et 30 m\u00e8tres, avec une fonction.</p> <pre><code>def tampon(distance):\n    result = processing.run(\n        \"native:buffer\", \n        {\n            'INPUT':'/chemin/vers/HYDROGRAPHIE/BARRAGE.shp',\n            'DISTANCE':distance,\n            'SEGMENTS':5,\n            'END_CAP_STYLE':0,\n            'JOIN_STYLE':0,\n            'MITER_LIMIT':2,\n            'DISSOLVE':False,\n            'OUTPUT':'TEMPORARY_OUTPUT'\n        }\n    )\n    QgsProject.instance().addMapLayer(result['OUTPUT'])\n\nfor x in [10, 20, 30]:\n    tampon(x)\n</code></pre> <p>Warning</p> <p>Attention si utilisation de <code>iface.activeLayer()</code> qui va \u00eatre modifi\u00e9 si utilisation de <code>QgsProject.instance().addMapLayer()</code>. Il peut \u00eatre n\u00e9cessaire d'extraire la s\u00e9lection de la couche hors de la boucle.</p>"},{"location":"script-processing/#lancer-linterface-graphique-de-notre-algorithme","title":"Lancer l'interface graphique de notre algorithme","text":"<p>Au lieu de <code>processing.run</code>, on peut cr\u00e9er uniquement le dialogue. Il faut alors l'afficher manuellement.</p> <pre><code>dialog = processing.createAlgorithmDialog(\n    \"native:buffer\",\n    {\n        'INPUT': '/data/lines.shp',\n        'DISTANCE': 100.0,\n        'SEGMENTS': 10,\n        'DISSOLVE': True,\n        'END_CAP_STYLE': 0,\n        'JOIN_STYLE': 0,\n        'MITER_LIMIT': 10,\n        'OUTPUT': '/data/buffers.shp'\n    }\n)\ndialog.show()\n</code></pre> <p>Ou alors directement lancer ex\u00e9cution du dialogue :</p> <pre><code>processing.execAlgorithmDialog(\n    \"native:buffer\",\n    {\n        'INPUT': '/data/lines.shp',\n        'DISTANCE': 100.0,\n        'SEGMENTS': 10,\n        'DISSOLVE': True,\n        'END_CAP_STYLE': 0,\n        'JOIN_STYLE': 0,\n        'MITER_LIMIT': 10,\n        'OUTPUT': '/data/buffers.shp'\n    }\n)\n</code></pre>"},{"location":"script-processing/#convertir-un-modele-processing-en-python","title":"Convertir un mod\u00e8le Processing en python","text":"<p>Il est possible de convertir un mod\u00e8le Processing en script Python. On peut alors le modifier avec plus de finesse.</p> <p>On ne peut pas reconvertir un script Python en mod\u00e8le.</p> <ul> <li>Depuis un mod\u00e8le, cliquer sur le bouton \"Convertir en script Processing\".</li> </ul>"},{"location":"script-processing/#utiliser-un-script-processing-dans-une-action","title":"Utiliser un script Processing dans une action","text":"<p>On peut utiliser <code>processing.run()</code> dans le code d'une action, pour faire une zone tampon sur un point en particulier par exemple.</p> <p>On peut lancer, graphiquement depuis la bo\u00eete \u00e0 outil Processing, une zone tampon, avec une s\u00e9lection. Regardons ensuite dans l'historique Processing pour voir comment QGIS a pu sp\u00e9cifier la s\u00e9lection dans son appel PyQGIS.</p> <p>On note l'usage d'une nouvelle classe <code>QgsProcessingFeatureSourceDefinition</code>.</p> <p>On souhaite donc pouvoir faire une zone tampon personnalis\u00e9e en cliquant sur un point \u00e0 l'aide d'une action.</p> <p>Il faut donc revoir le code dans le chapitre actions pour voir comment cr\u00e9er une action. Pour utiliser la s\u00e9lection, nous allons faire dans l'action :</p> <pre><code>from qgis.core import QgsProject, QgsVectorLayer\n\nlayer: QgsVectorLayer = QgsProject.instance().mapLayer('[% @layer_id %]')\nlayer.selectByIds([int('[% $id %]')])\n# Ajouter ici le code processing.run avec une s\u00e9lection\nlayer.removeSelection()\n</code></pre> <p>On peut compl\u00e9ter l'action avec un <code>processing.run</code> en utilisant uniquement l'entit\u00e9 en s\u00e9lection.</p> Solution <pre><code>import processing\n\nlayer = QgsProject.instance().mapLayer('[% @layer_id %]')\nlayer.selectByIds([int('[% $id %]')])\n\nresult = processing.run(\n    \"native:buffer\",\n    {\n        'INPUT':QgsProcessingFeatureSourceDefinition(layer.source(), selectedFeaturesOnly=True),\n        'DISTANCE':1000,\n        'SEGMENTS':5,\n        'END_CAP_STYLE':0,\n        'JOIN_STYLE':0,\n        'MITER_LIMIT':2,\n        'DISSOLVE':False,\n        'OUTPUT':'TEMPORARY_OUTPUT'\n    }\n)\nQgsProject.instance().addMapLayer(result['OUTPUT'])\n\nlayer.removeSelection()\n</code></pre>"},{"location":"script-processing/#introduction-aux-decorateurs","title":"Introduction aux d\u00e9corateurs","text":"<p>Comme mentionn\u00e9 au d\u00e9but de ce chapitre, il est possible de ne pas utiliser la POO pour \u00e9crire un \"Script Processing\" mais plut\u00f4t l'\u00e9criture \u00e0 l'aide des d\u00e9corateurs.</p> <p>Dans la documentation QGIS, on trouve :</p> <ul> <li>le tableau de correspondance   entre la notation dans le d\u00e9corateur et pour les types des param\u00e8tres</li> <li>un exemple avec d\u00e9corateur la correspondance</li> </ul> <p>Le code suivant utilise le d\u00e9corateur <code>@alg</code> :</p> <pre><code>from qgis import processing\nfrom qgis.processing import alg\n\n\n@alg(name='bufferrasteralg', label='Buffer and export to raster (alg)',\n     group='examplescripts', group_label='Example scripts')\n# 'INPUT' is the recommended name for the main input parameter\n@alg.input(type=alg.SOURCE, name='INPUT', label='Input vector layer')\n# 'OUTPUT' is the recommended name for the main output parameter\n@alg.input(type=alg.RASTER_LAYER_DEST, name='OUTPUT',\n           label='Raster output')\n@alg.input(type=alg.VECTOR_LAYER_DEST, name='BUFFER_OUTPUT',\n           label='Buffer output')\n@alg.input(type=alg.DISTANCE, name='BUFFERDIST', label='BUFFER DISTANCE',\n           default=1.0)\n@alg.input(type=alg.DISTANCE, name='CELLSIZE', label='RASTER CELL SIZE',\n           default=10.0)\n@alg.output(type=alg.NUMBER, name='NUMBEROFFEATURES',\n            label='Number of features processed')\ndef bufferrasteralg(instance, parameters, context, feedback, inputs):\n   \"\"\"\n   Description of the algorithm.\n   (If there is no comment here, you will get an error)\n   \"\"\"\n   input_featuresource = instance.parameterAsSource(parameters,\n                                                    'INPUT', context)\n   numfeatures = input_featuresource.featureCount()\n   bufferdist = instance.parameterAsDouble(parameters, 'BUFFERDIST',\n                                           context)\n   rastercellsize = instance.parameterAsDouble(parameters, 'CELLSIZE',\n                                               context)\n\n   if feedback.isCanceled():\n      return {}\n\n   params = {\n      'INPUT': parameters['INPUT'],\n      'OUTPUT': parameters['BUFFER_OUTPUT'],\n      'DISTANCE': bufferdist,\n      'SEGMENTS': 10,\n      'DISSOLVE': True,\n      'END_CAP_STYLE': 0,\n      'JOIN_STYLE': 0,\n      'MITER_LIMIT': 10\n   }\n   buffer_result = processing.run(\n      'native:buffer',\n      params,\n      is_child_algorithm=True,\n      context=context,\n      feedback=feedback)\n\n   if feedback.isCanceled():\n      return {}\n\n   params = {\n      'LAYER': buffer_result['OUTPUT'],\n      'EXTENT': buffer_result['OUTPUT'],\n      'MAP_UNITS_PER_PIXEL': rastercellsize,\n      'OUTPUT': parameters['OUTPUT']\n   }\n   rasterized_result = processing.run(\n      'qgis:rasterize',\n      params,\n      is_child_algorithm=True, context=context,\n      feedback=feedback)\n\n   if feedback.isCanceled():\n      return {}\n\n   results = {\n      'OUTPUT': rasterized_result['OUTPUT'],\n      'BUFFER_OUTPUT': buffer_result['OUTPUT'],\n      'NUMBEROFFEATURES': numfeatures,\n   }\n   return results\n</code></pre>"},{"location":"selection-parcours-entites/","title":"Fonctions sur une couche vecteur","text":""},{"location":"selection-parcours-entites/#utilisation-des-expressions-qgis","title":"Utilisation des expressions QGIS","text":"<ul> <li>Les expressions sont tr\u00e8s pr\u00e9sentes dans QGIS, tant dans l'interface graphique que dans l'utilisation en   Python.</li> <li>Nous partons de la couche des <code>COMMUNES</code> uniquement charg\u00e9 dans QGIS.</li> </ul> <p>Tip</p> <p>Adapter le num\u00e9ro des codes INSEE ou des d\u00e9partements selon votre BDTOPO \ud83d\ude09</p>"},{"location":"selection-parcours-entites/#selection-dentite","title":"S\u00e9lection d'entit\u00e9","text":"<p>Nous souhaitons s\u00e9lectionner les entit\u00e9s dont le code INSEE commence par <code>77</code>. Commen\u00e7ons par faire cela graphiquement dans QGIS Bureautique. \u00c0 l'aide d'une expression QGIS, s\u00e9lectionner les codes INSEE qui commencent par <code>77</code> (\u00e0 choisir un code INSEE propre au jeu de donn\u00e9es).</p> <p></p> <p>Solution en mode graphique :</p> <pre><code>\"INSEE_COM\" LIKE '77%'\n</code></pre> <p>Nous allons faire la m\u00eame chose, mais en utilisant Python. Pensez \u00e0 d\u00e9s\u00e9lectionner les entit\u00e9s.</p> <p>Il va falloir \"\u00e9chapper\" un caract\u00e8re \u00e0 l'aide de <code>\\</code>. Voir la page Wikip\u00e9dia sur l'\u00e9chappement ou ce meme pour les devs \ud83e\udee2</p> <pre><code>from qgis.utils import iface\n\nlayer = iface.activeLayer()\nlayer.removeSelection()\nlayer.selectByExpression(f\"\\\"INSEE_COM\\\" LIKE '77%'\")\n# layer.selectByExpression(f'\"INSEE_COM\" LIKE \\'77%\\'')  # R\u00e9sultat identique\nlayer.invertSelection()\nlayer.removeSelection()\n</code></pre> <p>Le raccourci <code>iface.activeLayer()</code> est tr\u00e8s pratique, mais de temps en temps, on a besoin de plusieurs couches qui sont d\u00e9j\u00e0 dans la l\u00e9gende. Il existe dans <code>QgsProject</code> plusieurs m\u00e9thodes pour r\u00e9cup\u00e9rer des couches dans la l\u00e9gende :</p> <pre><code>from qgis.core import QgsProject\n\nprojet = QgsProject.instance()\ncommunes = projet.mapLayersByName('communes')[0]\ninsee = projet.mapLayersByName('tableau INSEE')\n</code></pre> <p>Notons le s dans <code>mapLayersByName</code>. Il peut y avoir plusieurs couches avec ce m\u00eame nom de couche. La fonction retourne donc une liste de couches. Il convient alors de regarder si la liste est vide ou si elle contient plusieurs couches avec <code>len(communes)</code> par exemple.</p> <p>Warning</p> <p><code>mapLayersByName</code> fait uniquement une recherche stricte, sensible \u00e0 la casse. Il faut passer par du code Python \"pure\" en it\u00e9rant sur l'ensemble des couches, ind\u00e9pendamment de leur nom si l'on souhaite faire une recherche plus fine. Si vraiment, on a besoin, on peut utiliser le module re (lien du Docteur Python).</p> <pre><code>from qgis.core import QgsProject\n\nprojet = QgsProject.instance()\ncommunes = projet.mapLayersByName('communes')\n\nif len(communes) == 0:\n    print(\"Pas de couches dans la l\u00e9gende qui se nomme 'communes'\")\n    layer = None\nelif len(communes) &gt;= 1:\n    # TODO FIX ME, pas forc\u00e9ment la bonne couche 'communes'\n    layer = communes[0]\n</code></pre>"},{"location":"selection-parcours-entites/#exemple-dune-selection-avec-un-export","title":"Exemple d'une s\u00e9lection avec un export","text":"<p>On souhaite pouvoir exporter les communes par d\u00e9partement. On peut cr\u00e9er une variable <code>depts = ('34', '30')</code> puis boucler dessus pour exporter les entit\u00e9s s\u00e9lectionn\u00e9es dans un nouveau fichier.</p> <pre><code>from pathlib import Path\nfrom qgis.core import QgsProject, QgsVectorFileWriter\nfrom qgis.utils import iface\n\nlayer = iface.activeLayer()\n\noptions = QgsVectorFileWriter.SaveVectorOptions()\noptions.driverName = 'ESRI Shapefile'\noptions.fileEncoding = 'UTF-8'\noptions.onlySelectedFeatures = True  # Nouvelle option pour la s\u00e9lection\n\ndepts = ('34', '30')\nfor dept in depts:\n    print(f\"Dept {dept}\")\n    layer.selectByExpression(f\"\\\"INSEE_DEP\\\"  =  '{dept}'\")\n    result = QgsVectorFileWriter.writeAsVectorFormatV3(\n        layer,\n        str(Path(QgsProject.instance().homePath()).joinpath(f'{dept}.shp')),\n        QgsProject.instance().transformContext(),\n        options\n    )\n    print(result)\n    if result[0] == QgsVectorFileWriter.WriterError.NoError:\n        print(\" \u2192 OK\")\n</code></pre> <p>Bonus</p> <p>Si l'on souhaite parcourir automatiquement les d\u00e9partements existants, on peut r\u00e9cup\u00e9rer les valeurs uniques. Pour cela, il faut modifier deux lignes :</p> <pre><code>index = layer.fields().indexFromName(\"INSEE_DEP\")\nfor dept in layer.uniqueValues(index):\n</code></pre>"},{"location":"selection-parcours-entites/#boucler-sur-les-entites-dune-couche-sans-expression","title":"Boucler sur les entit\u00e9s d'une couche sans expression","text":"<p>Si besoin, pour que la suite de l'exercice soit plus rapide, on peut utiliser une couche <code>ARRONDISSEMENT</code> par exemple.</p> <p>On peut parcourir les entit\u00e9s d'une couche <code>QgsVectorLayer</code> \u00e0 l'aide de <code>getFeatures()</code>.</p> <p>Info</p> <p>Avec PyQGIS, on peut acc\u00e9der aux attributs d'une <code>QgsFeature</code> simplement avec l'op\u00e9rateur <code>[]</code> sur l'objet courant comme s'il s'agissait d'un dictionnaire Python :</p> <pre><code># Pour acc\u00e9der au champ \"NOM\" de l'entit\u00e9 \"feature\" :\nprint(feature['NOM'])\n</code></pre> <p>On peut le voir dans les exemples <code>attribute</code> de QgsFeature : https://qgis.org/pyqgis/3.34/core/QgsFeature.html#qgis.core.QgsFeature.attribute</p> <pre><code>from qgis.utils import iface\n\nlayer = iface.activeLayer()\nfor feature in layer.getFeatures():\n    print(feature)\n    print(feature['NOM'])\n    print(feature.attribute('NOM'))\n</code></pre>"},{"location":"selection-parcours-entites/#boucler-sur-les-entites-a-laide-dune-expression","title":"Boucler sur les entit\u00e9s \u00e0 l'aide d'une expression","text":"<p>L'objectif est d'afficher dans la console le nom des communes dont la code d\u00e9partement <code>INSEE_DEP</code> correspond uniquement \u00e0 un seul d\u00e9partement arbitraire.</p> <p>L'exemple \u00e0 ne pas faire, m\u00eame si cela fonctionne (car on peut l'optimiser tr\u00e8s facilement) :</p> <pre><code>from qgis.utils import iface\n\nlayer = iface.activeLayer()\nfor feature in layer.getFeatures():\n    if feature['INSEE_DEP'] == '84':\n        print(f'{feature['NOM']} : d\u00e9partement {feature['INSEE_DEP']}')\n</code></pre> <ol> <li>Imaginons qu'il s'agisse d'une couche PostgreSQL, sur un serveur distant</li> <li>On demande \u00e0 QGIS de r\u00e9cup\u00e9rer l'ensemble de la table distante, \u00e9quivalent \u00e0 <code>SELECT * FROM ma_table</code></li> <li>Puis, on filtre dans QGIS (toute la donn\u00e9e est pr\u00e9sente dans QGIS Bureautique d\u00e9sormais)</li> </ol> <p>Tip</p> <p>Ce qui prend du temps lors de l'ex\u00e9cution, c'est surtout le <code>print</code> en lui-m\u00eame. Si vous n'utilisez pas <code>print</code>, mais un autre traitement, cela sera plus rapide. Un simple print ralenti l'ex\u00e9cution d'un script.</p>"},{"location":"selection-parcours-entites/#optimisation-de-la-requete","title":"Optimisation de la requ\u00eate","text":"<p>Dans la documentation, observez bien la signature de la fonction <code>getFeatures</code>. Que remarquez-vous ? Utilisons donc une expression pour limiter les r\u00e9sultats.</p> <pre><code>from qgis.utils import iface\nfrom qgis.core import QgsFeatureRequest\n\nlayer = iface.activeLayer()\n\nrequest = QgsFeatureRequest()\n# \u00c9quivalent \u00e0 SELECT * FROM ma_table WHERE \"INSEE_DEP\" = '84'\nrequest.setFilterExpression('\"INSEE_DEP\" = \\'84\\'')\n\nfor feature in layer.getFeatures(request):\n    print(f'{feature['NOM']} : d\u00e9partement {feature['INSEE_DEP']}')\n</code></pre> <p>Nous pouvons accessoirement ordonner les r\u00e9sultats et surtout encore optimiser la requ\u00eate en :</p> <ul> <li>Ne demandant pas de charger la g\u00e9om\u00e9trie</li> <li>Ne demandant pas de charger tous les attributs, par exemple, on souhaite afficher que le nom de la commune et sa     population.</li> </ul> La solution pour les experts <pre><code>request = QgsFeatureRequest()\nrequest.setFilterExpression('\"INSEE_DEP\" = \\'84\\'')\nrequest.addOrderBy('NOM')\nrequest.setFlags(QgsFeatureRequest.NoGeometry)\n# request.setSubsetOfAttributes([1, 4]) autre mani\u00e8re moins pratique, historique\nrequest.setSubsetOfAttributes(['NOM', 'POPULATION'], layer.fields())\n# # \u00c9quivalent \u00e0 SELECT NOM, POPULATION FROM ma_table WHERE \"INSEE_DEP\" = '84' ORDER BY NOM\nfor feature in layer.getFeatures(request):\n    print('{commune} : {nombre} habitants'.format(commune=feature['NOM'], nombre=feature['POPULATION']))\n</code></pre> <ul> <li>Faire le test en affichant un champ qui n'est pas dans la requ\u00eate.</li> </ul>"},{"location":"selection-parcours-entites/#enregistrement-dune-requete-dans-une-couche-en-memoire","title":"Enregistrement d'une requ\u00eate dans une couche en m\u00e9moire","text":"<p>Si l'on souhaite \"enregistrer\" le r\u00e9sultat de cette expression QGIS, on peut la mat\u00e9rialiser dans une nouvelle couche :</p> <pre><code>memory_layer = layer.materialize(request)\nQgsProject.instance().addMapLayer(memory_layer)\n</code></pre> <p>Warning</p> <p>Attention \u00e0 la ligne iface.activeLayer() qui peut changer lors de l'ajout d'une nouvelle couche dans la l\u00e9gende.</p> <p>Regardons le r\u00e9sultat et corrigeons ce probl\u00e8me d'export afin d'obtenir les g\u00e9om\u00e9tries et les attributs, il faut supprimer la ligne <code>NoGeometry</code> si vous l'avez.</p>"},{"location":"selection-parcours-entites/#valeur-null","title":"Valeur NULL","text":"<p>En PyQGIS, il existe la valeur <code>NULL</code> qui peut \u00eatre pr\u00e9sente dans la table attributaire d'une couche vecteur.</p> <pre><code>from qgis.PyQt.QtCore import NULL\n\nif feature['nom_attribut'] == NULL:\n    # Traiter la valeur NULL\n    pass\nelse:\n    # Continuer\n    pass\n</code></pre>"},{"location":"selection-parcours-entites/#calculer-un-champ-densite","title":"Calculer un champ \"densite\"","text":"<p>Nous souhaitons avoir une colonne <code>densite</code> dans notre table attributaire, avec la densit\u00e9 de population.</p> <p>Mais regardons avant la gestion des erreurs lors d'un traitement. En effet, nous allons vouloir \"caster\" (transformer le type) de la variable <code>population</code> en entier, mais attention, il y a des valeurs <code>NC</code> dans les valeurs.</p> <p>_Note, il n'y a d\u00e9sormais plus de valeur <code>NC</code> dans le champ <code>POPULATION</code> dans la donn\u00e9e, mais imaginons. Il peut s'agir d'une autre couche dont on ne connait pas la provenance et le contenu.</p>"},{"location":"selection-parcours-entites/#les-exceptions-en-python","title":"Les exceptions en Python","text":"<p>Avant de traiter cet exercice, nous devons voir ce qu'est une exception en Python.</p> <p>\u00c0 plusieurs reprises depuis le d\u00e9but de la formation, il est fort \u00e0 parier que nous ayons des messages en rouges dans la console de temps en temps. Ce sont des exceptions. C'est une notion de programmation qui existe dans beaucoup de languages.</p> <p>Dans le langage informatique, une exception peut-\u00eatre :</p> <ul> <li>lev\u00e9e (\"<code>raise</code>\" en anglais) pour d\u00e9clencher une erreur</li> <li>attrap\u00e9e (\"catch\" en anglais, ou plut\u00f4t \"<code>except</code>\" en Python) pour traiter l'erreur</li> </ul> <p>Essayons dans la console de faire une op\u00e9ration 10 / 2 :</p> <pre><code>10 / 2\n</code></pre> <p>Essayons cette fois-ci 10 / 0, ce qui est math\u00e9matiquement impossible : <pre><code>10 / 0\n</code></pre></p> <p>Passons cette fois-ci dans un script pour que cela soit plus simple, et voir que le script s'arr\u00eate brutalement \ud83d\ude09</p> <pre><code>print('D\u00e9but')\nprint(10 / 2)\nprint('Fin')\n</code></pre> <p>On peut \"attraper\" cette erreur Python \u00e0 l'aide d'un <code>try ... except...</code> :</p> <pre><code>print('D\u00e9but')\ntry:\n    print(10 / 2)\nexcept ZeroDivisionError:\n    print('Ceci est une division par z\u00e9ro !')\nprint('Fin')\n</code></pre> <p>Le <code>try</code> permet d'essayer le code qui suit. Le <code>except</code> permet d'attraper en filtrant s'il y a des exceptions et de traiter l'erreur si besoin.</p> <p>Tip</p> <p>On peut avoir une ou plusieurs lignes de code dans chacun de ces blocs. On peut appeler des fonctions, etc.</p>"},{"location":"selection-parcours-entites/#une-exception-remonte-le-fil-dexecution-du-programme","title":"Une exception remonte le fil d'ex\u00e9cution du programme","text":"<p>Important, une exception remonte tant qu'elle n'est pas attrap\u00e9e : </p> <pre><code>def function_3():\n    print(\"D\u00e9but fonction 3\")\n    a = 10\n    b = 2\n    print(f\"\u2192 {a} / {b} = {a/b}\")\n    print(\"Fin fonction 3\")\n\ndef function_2():\n    print(\"D\u00e9but fonction 2\")\n    function_3()\n    print(\"Fin fonction 2\")\n\ndef function_1():\n    print(\"D\u00e9but fonction 1\")\n    function_2()\n    print(\"Fin fonction 1\")\n\nfunction_1()\n</code></pre> <p>Testons d\u00e9sormais d'attraper l'erreur dans la fonction 1 :</p> <pre><code>try:\n    function_2()\nexcept ZeroDivisionError:\n    print(\"Fin de l'exception\")\n</code></pre> <p>On voit que Python, quand il peut, nous indique la \"stacktrace\" ou encore \"traceback\", c'est-\u00e0-dire une sorte de fil d'ariane.</p>"},{"location":"selection-parcours-entites/#heritage-des-exceptions","title":"H\u00e9ritage des exceptions","text":"<p>Toutes les exceptions h\u00e9ritent de <code>Exception</code> donc le code ci-dessous fonctionne, mais n'est pas recommand\u00e9, car il masque d'autres erreurs :</p> <pre><code>try:\n    a = 10 / 5\n\n    mois = ['janvier', 'f\u00e9vrier']\n    b = mois[0]\n\nexcept Exception:\n    print('Erreur inconnue')\n</code></pre> <p>On peut par contre \"encha\u00eener\" les exceptions, afin de filtrer progressivement les exceptions.</p> <pre><code>try:\n    a = 10 / 5\n    # a = 10 / 0\n    # a = 10 / int(\"NC\")\n    # a = 10 / \"NC\"\nexcept ZeroDivisionError:\n    print('Erreur, division par 0')\nexcept ValueError:\n    print(\"Erreur, il n'y a avait pas que des chiffres.\")\nexcept Exception:\n    print('Erreur inconnue')\n</code></pre> <p>Il existe d'autres mots-cl\u00e9s en Python pour les exceptions comme <code>finally:</code> et <code>else:</code>. Voir un autre tutoriel.</p> <p>\u00c9videment, on peut v\u00e9rifier la valeur de <code>b</code> en amont si c'est \u00e9gal \u00e0 0. Mais ceci est pour pr\u00e9senter le concept des exceptions en Python.</p>"},{"location":"selection-parcours-entites/#retour-a-lexercice","title":"Retour \u00e0 l'exercice","text":"<p>On souhaite donc savoir si un nombre est transformable en entier, dans le cas de la population (s'il y a <code>NC</code> par exemple) :</p> <pre><code>int('10')\nint('NC')\n</code></pre> <p>Correction possible de l'exercice :</p> <pre><code>from qgis.utils import iface\nfrom qgis.core import QgsFeatureRequest\n\nlayer = iface.activeLayer()\nrequest = QgsFeatureRequest()\n# request.setLimit(5)  # Pour aller plus vite si-besoin\nrequest.addOrderBy('NOM')\nrequest.setSubsetOfAttributes(['NOM', 'POPULATION'], layer.fields())\nfor feature in layer.getFeatures(request):\n    area = feature.geometry().area() / 1000000\n    try:\n        population = int(feature['POPULATION'])\n        # Par exemple, pour nettoyer une cha\u00eene de caract\u00e8re en Python des espaces avant/apr\u00e8s : \"  Bonjour  \".strip()\n        # \"rstrip\"/\"lstrip\" existent \u00e9galement\n    except ValueError:\n        population = 0\n\n    densite = population/area\n\n    print(f\"{feature['NOM']} : {densite} habitants/km\u00b2\")\n</code></pre> <p>Nous souhaitons enregistrer ces informations dans une vraie table avec un nouveau champ <code>densite_population</code>.</p> <p>Solution possible :</p> <pre><code>from qgis.utils import iface\nfrom qgis.core import QgsFeatureRequest, QgsField, edit\n\nfrom qgis.PyQt.QtCore import QVariant\n\nlayer = iface.activeLayer()\n\nif 'densite' not in layer.fields().names():\n    with edit(layer):\n        field = QgsField('densite', QVariant.Double, prec=2, len=2)\n        layer.addAttribute(field)\n\nindex = layer.fields().indexFromName('densite')\nlayer.startEditing()\nrequest = QgsFeatureRequest()\n# request.setLimit(5)  # Pour aller plus vite si-besoin\nrequest.addOrderBy('NOM')\nrequest.setSubsetOfAttributes(['NOM', 'POPULATION'], layer.fields())\nfor feature in layer.getFeatures(request):\n    area = feature.geometry().area() / 1000000\n    try:\n        population = int(feature['POPULATION'])\n    except ValueError:\n        population = 0\n\n    densite = population/area\n\n    # Cette ligne n'aura aucun effet\n    # La variable \"feature\" est une copie, comme un peu le r\u00e9sultat du SELECT * FROM ma_table LIMIT 5\n    # un SELECT est en lecture seule. Pour expliquer rapidement ce qu'il se passe.\n    feature['densite'] = densite\n\n    # Uniquement l'appel \u00e0 \"changeAttributeValue\" fonctionne\n    # Pour information, il existe \"changeGeometry\" pour la m\u00eame raison\n    # Un peu comme la commande SQL UPDATE, sur une entit\u00e9 existante, bien qu'il ne faut pas oublier la session d'\u00e9dition.\n    layer.changeAttributeValue(feature.id(), index, densite)\n    # print('{commune} : {densite} habitants/km\u00b2'.format(commune=feature['NOM'], densite=round(population/area,2)))\n\nlayer.commitChanges()\n</code></pre>"},{"location":"selection-parcours-entites/#calculer-deux-champs-en-utilisant-la-geometrie-et-une-reprojection-a-la-volee","title":"Calculer deux champs en utilisant la g\u00e9om\u00e9trie et une reprojection \u00e0 la vol\u00e9e","text":"<p>Manipulons d\u00e9sormais la g\u00e9om\u00e9trie en ajoutant le centro\u00efde de la commune dans une colonne <code>latitude</code> et <code>longitude</code> en degr\u00e9es.</p> <p>Warning</p> <p>TODO, en cours de correction, suppression de la variable <code>petite_communes</code></p> <pre><code>from qgis.utils import iface\nfrom qgis.core import QgsFeatureRequest, QgsField, edit\n\nlayer = iface.activeLayer()\n\nrequest = QgsFeatureRequest()\nrequest.setFilterExpression('to_int( \"POPULATION\" ) &lt; 1000')\npetites_communes = layer.materialize(request)\n\nwith edit(petites_communes):\n    petites_communes.addAttribute(QgsField('densite_population', QVariant.Double))\n\n    # /!\\ Ajouter les 2 lignes ci-dessous\n    petites_communes.addAttribute(QgsField('longitude', QVariant.Double))\n    petites_communes.addAttribute(QgsField('latitude', QVariant.Double))\n\nrequest = QgsFeatureRequest()\nrequest.setSubsetOfAttributes([4])\n\n# /!\\ Ajouter les 2 lignes ci-dessous \u00e0 propos de la transformation\ntransform = QgsCoordinateTransform(\n    QgsCoordinateReferenceSystem(\"EPSG:2154\"), QgsCoordinateReferenceSystem(\"EPSG:4326\"), QgsProject.instance())\n\nwith edit(petites_communes):\n    for feature in petites_communes.getFeatures(request):\n        area = feature.geometry().area() / 1000000\n        population = int(feature['POPULATION'])\n        densite=population/area\n        petites_communes.changeAttributeValue(feature.id(), 5, densite)\n\n        # /!\\ Ajouter les lignes ci-dessous\n        geom = feature.geometry()\n        # La transformation affecte directement l'objet Python en cours, mais pas l'entit\u00e9 dans la couche\n        geom.transform(transform)\n        centroid = geom.centroid().asPoint()\n        petites_communes.changeAttributeValue(feature.id(), 6, centroid.x())\n        petites_communes.changeAttributeValue(feature.id(), 7, centroid.y())\n\nQgsProject.instance().addMapLayer(petites_communes)\n</code></pre>"},{"location":"signal-slot/","title":"Les signaux et les slots","text":""},{"location":"signal-slot/#definition","title":"D\u00e9finition","text":"<p>Nous avons pu voir dans la documentation des librairies Qt et QGIS, il y a une section Signals.</p> <p>Chaque objet \u00e9met tr\u00e8s souvent un signal d\u00e8s qu'une action est faite sur l'objet. Cela sert \u00e0 d\u00e9clencher du code Python lorsqu'un signal pr\u00e9cis est \u00e9mis.</p> <p>Par exemple sur la documentation de QgsMapLayer, on peut chercher le tableau <code>signals</code>.</p> <p>Info</p> <p>Comme on peut le voir dans la documentation CPP, c'est d\u00e9sormais dans la classe <code>QgsMapLayer</code> et non <code>QgsVectorLayer</code> depuis QGIS 3.22. \ud83e\uddd0</p> <p>La plupart des signaux sont aux pass\u00e9s, par exemple <code>crsChanged</code>, <code>nameChanged</code>. Cependant, certaines sont dans un \"futur\" proche comme <code>willBeDeleted</code>.</p>"},{"location":"signal-slot/#syntaxe","title":"Syntaxe","text":"<p>On dit que l'on souhaite connecter un signal \u00e0 une fonction/slot :</p> <pre><code>variable_de_lobjet.nom_du_signal.connect(nom_de_la_fonction)\n</code></pre> <p>Danger</p> <p>Il ne faut pas \u00e9crire <code>nom_de_la_fonction()</code> car on ne souhaite pas appeler la fonction, juste connecter.</p> <p>Cela sera Python, plus tard, quand le signal sera \u00e9mis, que la fonction sera r\u00e9ellement appel\u00e9e.</p>"},{"location":"signal-slot/#exemple","title":"Exemple","text":"<p>Par exemple, dans la classe <code>QgsMapLayer</code>, cherchons un signal qui est \u00e9mis apr\u00e8s (before) que la session d'\u00e9dition commence. Il s'agit de <code>editingStarted</code>.</p> <p>Affichons un message \u00e0 l'utilisateur lors du d\u00e9but et de la fin d'une session d'\u00e9dition.</p> <p>Tip</p> <p>On profite de cet exemple pour voir comment \u00e9valuer une expression QGIS \u00e0 l'aide des diff\u00e9rents contextes.</p> <pre><code>def user_from_qgis() -&gt; str:\n    \"\"\" \u00c0 l'aide d'une expression QGIS, r\u00e9cup\u00e9ration du nom d'utilisateur.\"\"\"\n    context = QgsExpressionContext()\n    context.appendScope(QgsExpressionContextUtils.globalScope())\n    # On peut th\u00e9oriquement s'arr\u00eater \u00e0 ce niveau la concernant l'ajout des \"scopes\" avec le GlobalScope\n    # Mais on peut ajouter d'autre \"scope\", comme ajouter celui du projet :\n    # context.appendScope(QgsExpressionContextUtils.projectScope(project))\n    # context.appendScope(QgsExpressionContextUtils.layerScope(layer))\n\n    # On peut ensuite \u00e9valuer l'expression QGIS\n    # \"@user_account_name\" ou encore \"@user_full_name\"\n    expression = QgsExpression(\"@user_full_name\")\n    return expression.evaluate(context)\n\ndef user_from_os() -&gt; str:\n    \"\"\" \u00c0 l'aide de l'OS, retourne le nom d'utilisateur.\"\"\"\n    import os\n    return os.getlogin()\n\ndef we_are_watching_you():\n    \"\"\" Just warn the user about the editing session.\"\"\"\n    current_user = user_from_qgis()\n    # Attention aux effets si on lance le code plusieurs fois !\n    # print(\"Hello \ud83d\ude09\")\n    iface.messageBar().pushMessage('Hey',f'Be careful &lt;strong&gt;{current_user}&lt;/strong&gt; while you are editing \ud83e\uddd0', Qgis.Warning)\n\ndef thanks():\n    iface.messageBar().pushMessage('Hey', \"Thanks \ud83d\ude09\", Qgis.Success)\n\n\nlayer = iface.activeLayer()\n\nlayer.beforeEditingStarted.connect(we_are_watching_you)\nlayer.editingStopped.connect(thanks)\n</code></pre>"},{"location":"standalone/","title":"Librairie QGIS","text":""},{"location":"standalone/#qgis-process","title":"QGIS Process","text":"<p>Depuis QGIS 3.16, il existe un outil qgis_process qui permet de lancer QGIS Processing en ligne de commande.</p> <p>Quelques rappels pour utiliser la ligne de commande sous Windows :</p> <ul> <li><code>cd</code> pour Change D*irectory. Par exemple <code>cd C:/Program Files/QGIS 3.34/bin/</code></li> <li><code>dir</code> pour lister les fichiers/dossiers d'un r\u00e9pertoire</li> </ul> <p>Dans le shell OSGEO, taper :</p> <pre><code>cd C:/Program Files/QGIS 3.14/bin/\n# Il peut s'agit du chemin ci-dessous\ncd C:\\OSGeo4W\\apps\\qgis-ltr\\bin\\\n</code></pre> <p>On doit avoir d\u00e9sormais un ex\u00e9cutable <code>qgis_process-qgis-ltr.bat</code></p> <pre><code>qgis_process-qgis-ltr.bat\nqgis_process-qgis-ltr.bat --help\nqgis_process-qgis-ltr.bat list\n</code></pre> <p>On peut lancer les algorithmes, les mod\u00e8les, les scripts Python qui sont dans la version graphique de QGIS Processing.</p> <p>On peut donc lancer en ligne de commande, ou alors avec notre propre ic\u00f4ne sur son bureau un ex\u00e9cutable.</p> <pre><code>qgis_process help qgis:buffer\nqgis_process run qgis:buffer -- INPUT=/home/etienne/source.shp DISTANCE=2 OUTPUT=/tmp/sortie.gpkg\n</code></pre> <p>L'id\u00e9e de QGIS Process est soit de faire un petit ex\u00e9cutable ou alors de lancer le programme \u00e0 intervalle de temps r\u00e9gulier.</p> <p></p>"},{"location":"standalone/#standalone-application","title":"Standalone application","text":"<p>Il est possible de faire un programme qui ne se lance pas dans QGIS Bureautique mais qui utilise la librairie QGIS qui se trouve sur l'ordinateur.</p> <p>Warning</p> <p>Gr\u00e2ce \u00e0 <code>qgis_process</code>, c'est exemple d'application standalone perd la plupart de son int\u00e9r\u00eat. Pour lancer QGIS en ligne de commande pour faire des traitements, il est d\u00e9sormais fortement conseill\u00e9 d'utiliser <code>qgis_process</code>.</p> <p>On peut donc cr\u00e9er son propre programme, en ligne de commande ou avec une interface graphique qui utilise le moteur de QGIS en arri\u00e8re-plan pour utiliser ce que sait d\u00e9j\u00e0 faire QGIS.</p> <p>Exemple sur le gist de Thomas Gratier</p> <pre><code># Code borrowed from https://subscription.packtpub.com/book/application_development/9781783984985/1/ch01lvl1sec18/creating-a-standalone-application\n# and upgraded for QGIS 3.0\nimport os\nimport sys\nimport shutil\nimport tempfile\nimport urllib.request\nfrom zipfile import ZipFile\nfrom glob import glob\n\nfrom qgis.core import (QgsApplication, QgsCoordinateReferenceSystem, QgsFeature,\n                   QgsGeometry, QgsProject, QgsRasterLayer, QgsVectorLayer)\nfrom qgis.gui import QgsLayerTreeMapCanvasBridge, QgsMapCanvas\nfrom qgis.PyQt.QtCore import Qt\n# Unused so commented\n# from qgis.PyQt.QtGui import *\n\napp = QgsApplication([], True)\n# On Windows : https://gis.stackexchange.com/questions/334172/creating-standalone-application-in-qgis\n# On Linux, didn't need to set it so commented\n# app.setPrefixPath(\"C:/Program Files/QGIS Brighton/apps/qgis\", True)\napp.initQgis()\ncanvas = QgsMapCanvas()\ncanvas.setWindowTitle(\"PyQGIS Standalone Application Example\")\ncanvas.setCanvasColor(Qt.white)\ncrs = QgsCoordinateReferenceSystem('EPSG:3857')\nproject = QgsProject.instance()\ncanvas.setDestinationCrs(crs)\n\nurlWithParams = 'type=xyz&amp;url=https://a.tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png&amp;zmax=19&amp;zmin=0&amp;crs=EPSG3857'\nrlayer2 = QgsRasterLayer(urlWithParams, 'OpenStreetMap', 'wms')\n\nif rlayer2.isValid():\n    project.addMapLayer(rlayer2)\nelse:\n    print('invalid layer')\n\n# Download shp ne_10m_admin_0_countries.shp and associated files in the same directory\nurl = \"https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_admin_0_countries.zip\"\nif not glob(\"ne_10m_admin_0_countries.*\"):\n    with urllib.request.urlopen(url) as response:\n        with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n            shutil.copyfileobj(response, tmp_file)\n        with ZipFile(tmp_file.name, 'r') as zipObj:\n            # Extract all the contents of zip file in current directory\n            zipObj.extractall()\n\nlayer_shp = QgsVectorLayer(os.path.join(os.path.dirname(__file__), \"ne_10m_admin_0_countries.shp\"), \"Natural Earth\", \"ogr\")\nif not layer_shp.isValid():\n  print(\"Layer failed to load!\")\n\nproject.addMapLayer(layer_shp)\n\nprint(layer_shp.crs().authid())\nprint(rlayer2.crs().authid())\ncanvas.setExtent(layer_shp.extent())\ncanvas.setLayers([rlayer2, layer_shp])\ncanvas.zoomToFullExtent()\n# canvas.freeze(True)\ncanvas.show()\ncanvas.refresh()\n# canvas.freeze(False)\ncanvas.repaint()\nbridge = QgsLayerTreeMapCanvasBridge(\n    project.layerTreeRoot(),\n    canvas\n)\n\ndef run_when_project_saved():\n    print('Saved')\n\nproject.projectSaved.connect(run_when_project_saved)\n\nproject.write('my_new_qgis_project.qgz')\n\ndef run_when_application_state_changed(state):\n    print('State changed', state)\n\napp.applicationStateChanged.connect(run_when_application_state_changed)\n\nexitcode = app.exec()\nQgsApplication.exitQgis()\nsys.exit(True)\n</code></pre>"},{"location":"symbologie/","title":"Symbologie","text":"<p>\u00c9tant donn\u00e9 que la symbologie pouvant \u00eatre complexe dans QGIS Bureautique, avec les diff\u00e9rents types de symbologie, les diff\u00e9rents niveaux de symbole, les ensembles de r\u00e8gles avec des filtres etc, il n'est pas forc\u00e9ment simple de s'y retrouver dans l'API PyQGIS \u00e9galement.</p>"},{"location":"symbologie/#utilisation-dun-qml-au-lieu-de-pyqgis","title":"Utilisation d'un QML au lieu de PyQGIS","text":"<p>On peut se passer de PyQGIS pour fournir une symbologie \u00e0 l'aide d'un fichier QML, si on ne souhaite pas faire \u00e7a en Python enti\u00e8rement.</p> <p>Regarder les m\u00e9thodes <code>loadNamedStyle</code> de la classe <code>QgsMapLayer</code>.</p> <pre><code>from pathlib import Path\n\nlayer = iface.activeLayer()\n\nqml = Path(\"path_to_qml\")\nif qml.exists():\n    layer.loadNamedStyle(str(qml))\n    iface.legendInterface().refreshLayerSymbology(layer)\n</code></pre>"},{"location":"symbologie/#classes-utiles-en-pyqgis","title":"Classes utiles en PyQGIS","text":"<p>Voir les graphiques d'h\u00e9ritage sur :</p> <ul> <li>QgsFeatureRenderer pour le moteur de rendu.</li> <li>QgsSymbol pour un symbole, selon le type de g\u00e9om\u00e9trie.</li> </ul>"},{"location":"symbologie/#afficher-les-infos-de-la-symbologie","title":"Afficher les infos de la symbologie","text":"<ul> <li>Affichage sous forme textuelle</li> </ul> <pre><code>layer = iface.activeLayer()\nrenderer = layer.renderer()\nprint(renderer.dump())\n</code></pre> <p>SINGLE: FILL SYMBOL (1 layers) color 125,139,143,255</p> <ul> <li>Affichage du \"dictionnaire\" contenant l'ensemble des informations pour un niveau de symbole :</li> </ul> <pre><code>layer = iface.activeLayer()\nrenderer = layer.renderer()\nprint(renderer.symbol().symbolLayers()[0].properties())\n</code></pre> <p>{'border_width_map_unit_scale': '3x:0,0,0,0,0,0', 'color': '125,139,143,255', 'joinstyle': 'bevel', 'offset': '0,0', 'offset_map_unit_scale': '3x:0,0,0,0,0,0', 'offset_unit': 'MM', 'outline_color': '35,35,35,255', 'outline_style': 'solid', 'outline_width': '0.26', 'outline_width_unit': 'MM', 'style': 'solid'}</p>"},{"location":"symbologie/#affecter-une-symbologie-a-une-couche","title":"Affecter une symbologie \u00e0 une couche","text":"<p>Il peut \u00eatre tr\u00e8s pratique de partir d'une symbologie existante, faite via l'interface graphique, puis de l'exporter pour voir les propri\u00e9t\u00e9s.</p>"},{"location":"symbologie/#un-symbole-ponctuel-unique-simple","title":"Un symbole ponctuel unique simple","text":"<pre><code>from qgis.core import QgsMarkerSymbol, QgsSingleSymbolRenderer\n\nsymbol = QgsMarkerSymbol.createSimple(\n    {\n        \"name\": \"circle\",\n        \"color\": \"yellow\",\n        \"size\": 3,\n    }\n)\nrenderer = QgsSingleSymbolRenderer(symbol)\nlayer = iface.activeLayer()\nlayer.setRenderer(renderer)\n# layer.triggerRepaint()  # If necessary\n</code></pre>"},{"location":"symbologie/#un-symbole-lineaire-unique-sous-forme-de-fleche","title":"Un symbole lin\u00e9aire unique sous forme de fl\u00e8che","text":"<pre><code>from qgis.core import QgsApplication, QgsSymbol, Qgis, QgsSingleSymbolRenderer\nfrom qgis.PyQt.QtGui import QColor\n\n# Quelques propri\u00e9t\u00e9s d'une fl\u00e8che si besoin de surcharger. Utiliser le code PyQGIS pour r\u00e9cup\u00e9rer la liste des propri\u00e9t\u00e9s.\nARROW = {\n    'arrow_start_width': '1',\n    'arrow_start_width_unit': 'MM',\n    'arrow_start_width_unit_scale': '3x:0,0,0,0,0,0',\n    'arrow_type': '0',\n}\n\nregistry = QgsApplication.symbolLayerRegistry()\nline_metadata = registry.symbolLayerMetadata('ArrowLine')\nline_layer = line_metadata.createSymbolLayer(ARROW)\nline_layer.setColor(QColor('#33a02c'))\n\nsymbol = QgsSymbol.defaultSymbol(Qgis.GeometryType.LineGeometry)\nsymbol.deleteSymbolLayer(0)\nsymbol.appendSymbolLayer(line_layer)\n\n\nrenderer = QgsSingleSymbolRenderer(symbol)\nlayer = iface.activeLayer()\nlayer.setRenderer(renderer)\n</code></pre>"}]}