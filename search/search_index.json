{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Formation PyQGIS # Pr\u00e9-requis # Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent apprendre l'API Python de QGIS : Ajout de fonctionnalit\u00e9s \u00e0 QGIS Automatisation de certains traitements Cr\u00e9ation de script Cr\u00e9ation d'algorithme Processing Pour suivre la formation, il faut : Avoir QGIS LTR minimum Avoir des connaissances en QGIS bureautique Avoir des bases en programmation Avoir un jeu de donn\u00e9es, par exemple : Donn\u00e9es OSM \u00e0 l'aide du plugin QuickOSM Donn\u00e9es OSM2Igeo (utilisation de ce jeu de donn\u00e9es ci-apr\u00e8s dans la formation) Si n\u00e9cessaire, il peut-\u00eatre utile d'avoir en plus : qgis_process QtDesigner pour la partie sur les formulaires ou une extension graphique Plan # Pr\u00e9sentation Python dans QGIS M\u00e9mo Python Premier pas Console Fonctions & Scripts S\u00e9lection & Parcours Utilisation simple Action Formulaire Utilisation avanc\u00e9 Script Processing Extension g\u00e9n\u00e9rique Extension graphique Extension Processing Application standalone Autres D\u00e9ploiement d'une extension IDE Python & Git","title":"Accueil"},{"location":"#formation-pyqgis","text":"","title":"Formation PyQGIS"},{"location":"#pre-requis","text":"Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent apprendre l'API Python de QGIS : Ajout de fonctionnalit\u00e9s \u00e0 QGIS Automatisation de certains traitements Cr\u00e9ation de script Cr\u00e9ation d'algorithme Processing Pour suivre la formation, il faut : Avoir QGIS LTR minimum Avoir des connaissances en QGIS bureautique Avoir des bases en programmation Avoir un jeu de donn\u00e9es, par exemple : Donn\u00e9es OSM \u00e0 l'aide du plugin QuickOSM Donn\u00e9es OSM2Igeo (utilisation de ce jeu de donn\u00e9es ci-apr\u00e8s dans la formation) Si n\u00e9cessaire, il peut-\u00eatre utile d'avoir en plus : qgis_process QtDesigner pour la partie sur les formulaires ou une extension graphique","title":"Pr\u00e9-requis"},{"location":"#plan","text":"Pr\u00e9sentation Python dans QGIS M\u00e9mo Python Premier pas Console Fonctions & Scripts S\u00e9lection & Parcours Utilisation simple Action Formulaire Utilisation avanc\u00e9 Script Processing Extension g\u00e9n\u00e9rique Extension graphique Extension Processing Application standalone Autres D\u00e9ploiement d'une extension IDE Python & Git","title":"Plan"},{"location":"action/","text":"Les actions # Pour conna\u00eetre le principe des actions dans QGIS, il faut se r\u00e9f\u00e9rer au manuel de QGIS : https://docs.qgis.org/latest/fr/docs/user_manual/working_with_vector/vector_properties.html#actions-properties On souhaite pouvoir faire notre propre action pour inverser le sens d'une ligne, par exemple une rivi\u00e8re. Pour la couche lin\u00e9aire : Nous allons utiliser le script ci-dessous pour cr\u00e9er une couche tr\u00e8s simple, mais qui permet de voir la construction d'une ligne en partant de z\u00e9ro Sinon, pour aller beaucoup plus vite, ajouter la couche D_OSM_HYDROGRAPHIE/TRONCON_COURS_EAU.shp mais on ne voit pas comment construire la g\u00e9om\u00e9trie en partant de rien. Faire un style rapide pour mettre en \u00e9vidence le sens de la ligne \u00e0 l'aide d'une Ligne de symbole dans l'onglet Symbologie de la couche en question. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Notation pour ajouter des attributs en cr\u00e9ant une couche m\u00e9moire # https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/vector.html#from-an-instance-of-qgsvectorlayer river = QgsVectorLayer ( 'MultiLineString?crs=epsg:2154&field=id:integer&field=name:string(20)&index=yes' , 'Rivers' , 'memory' ) QgsProject . instance () . addMapLayer ( river ) with edit ( river ): feature = QgsVectorLayerUtils . createFeature ( river ) feature . setAttribute ( 'id' , 0 ) feature . setAttribute ( 'name' , 'Une rivi\u00e8re' ) geom = QgsGeometry . fromMultiPolylineXY ( [ [ QgsPointXY ( 1 , 1 ), QgsPointXY ( 2 , 2 ), QgsPointXY ( 3 , 2 ), QgsPointXY ( 4 , 1 )] ]) feature . setGeometry ( geom ) river . addFeature ( feature ) extent = river . extent () canvas = iface . mapCanvas () canvas . setExtent ( extent ) canvas . refresh () Les actions par d\u00e9faut # Dans la fen\u00eatre des propri\u00e9t\u00e9s d'une couche vecteur, aller dans l'onglet Actions . Cliquer sur le bouton Cr\u00e9er les actions par d\u00e9faut . Observons quelques actions pour comprendre le fonctionnement ainsi que les scopes/champs d'application des actions. Info Selon le champ d'application de l'action, il y a plus ou moins de variables . Notre propre action # Commen\u00e7ons un nouveau par un script Python classique, laissons de c\u00f4t\u00e9 le concept des actions pour le moment. \u00c9crire une fonction qui se charge d'inverser une ligne. Cette fonction prend en param\u00e8tre la couche vecteur et une liste d'ID des entit\u00e9s. Il faut penser \u00e0 v\u00e9rifier le type exact de g\u00e9om\u00e9trie de nos lignes, dans les propri\u00e9t\u00e9s de la couche. 1 2 3 4 5 6 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" pass Le mot-cl\u00e9 pass est juste une instruction Python qui ne fait strictement rien, mais qui permet de rendre une ligne de code valide en respectant l'indentation. Vous pouvez la supprimer d\u00e8s qu'il y a du code. Il faut : Utiliser une session d'\u00e9dition R\u00e9cup\u00e9rer la g\u00e9om\u00e9trie, tenir compte qu'il s'agit d'une multi-ligne Appliquer la fonction reverse en Python Utiliser QgsVectorLayer.changeGeometry() pour changer la g\u00e9om\u00e9trie d'un objet Afficher la solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = iface . activeLayer () ids = layer . selectedFeatureIds () reverse_geom ( layer , ids ) Incorporons ce code dans une action et adaptons-le l\u00e9g\u00e8rement : 1 2 3 4 5 6 7 8 9 10 11 12 def reverse_geom ( layer , ids ): with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = QgsProject . instance () . mapLayer ( '[% @layer_id %]' ) reverse_geom ( layer , '[% $id %]' ) On peut d\u00e9sormais cliquer sur une ligne pour automatiquement inverser une ligne. Le code de l'action est enregistr\u00e9 dans le style QML de la couche vecteur. Il peut donc \u00eatre partag\u00e9 avec d'autres utilisateurs qui ne connaissent pas Python. Astuce pour stocker le code d'une action dans une extension QGIS # Tip Pour suivre cette partie, il faut la plupart du temps une extension par exemple, voir l'autre chapitre , afin de stocker le code Python. Pour \u00e9viter d'avoir du code les propri\u00e9t\u00e9s de la couche QGIS, on peut r\u00e9duire le code Python au minimum en faisant dans le c\u0153ur de l'action uniquement l'import d'une fonction et de lancer son ex\u00e9cution. Exemple du code d'une action dans l'extension QuickOSM lors de l'ex\u00e9cution d'une requ\u00eate rapide : 1 2 from QuickOSM.core.actions import Actions Actions . run ( \"josm\" , \"[% \" full_id \" %]\" ) Ou alors l'extension RAEPA : 1 2 from qgis.utils import plugins plugins [ 'raepa' ] . run_action ( \"nom_de_laction\" , params )","title":"Action"},{"location":"action/#les-actions","text":"Pour conna\u00eetre le principe des actions dans QGIS, il faut se r\u00e9f\u00e9rer au manuel de QGIS : https://docs.qgis.org/latest/fr/docs/user_manual/working_with_vector/vector_properties.html#actions-properties On souhaite pouvoir faire notre propre action pour inverser le sens d'une ligne, par exemple une rivi\u00e8re. Pour la couche lin\u00e9aire : Nous allons utiliser le script ci-dessous pour cr\u00e9er une couche tr\u00e8s simple, mais qui permet de voir la construction d'une ligne en partant de z\u00e9ro Sinon, pour aller beaucoup plus vite, ajouter la couche D_OSM_HYDROGRAPHIE/TRONCON_COURS_EAU.shp mais on ne voit pas comment construire la g\u00e9om\u00e9trie en partant de rien. Faire un style rapide pour mettre en \u00e9vidence le sens de la ligne \u00e0 l'aide d'une Ligne de symbole dans l'onglet Symbologie de la couche en question. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Notation pour ajouter des attributs en cr\u00e9ant une couche m\u00e9moire # https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/vector.html#from-an-instance-of-qgsvectorlayer river = QgsVectorLayer ( 'MultiLineString?crs=epsg:2154&field=id:integer&field=name:string(20)&index=yes' , 'Rivers' , 'memory' ) QgsProject . instance () . addMapLayer ( river ) with edit ( river ): feature = QgsVectorLayerUtils . createFeature ( river ) feature . setAttribute ( 'id' , 0 ) feature . setAttribute ( 'name' , 'Une rivi\u00e8re' ) geom = QgsGeometry . fromMultiPolylineXY ( [ [ QgsPointXY ( 1 , 1 ), QgsPointXY ( 2 , 2 ), QgsPointXY ( 3 , 2 ), QgsPointXY ( 4 , 1 )] ]) feature . setGeometry ( geom ) river . addFeature ( feature ) extent = river . extent () canvas = iface . mapCanvas () canvas . setExtent ( extent ) canvas . refresh ()","title":"Les actions"},{"location":"action/#les-actions-par-defaut","text":"Dans la fen\u00eatre des propri\u00e9t\u00e9s d'une couche vecteur, aller dans l'onglet Actions . Cliquer sur le bouton Cr\u00e9er les actions par d\u00e9faut . Observons quelques actions pour comprendre le fonctionnement ainsi que les scopes/champs d'application des actions. Info Selon le champ d'application de l'action, il y a plus ou moins de variables .","title":"Les actions par d\u00e9faut"},{"location":"action/#notre-propre-action","text":"Commen\u00e7ons un nouveau par un script Python classique, laissons de c\u00f4t\u00e9 le concept des actions pour le moment. \u00c9crire une fonction qui se charge d'inverser une ligne. Cette fonction prend en param\u00e8tre la couche vecteur et une liste d'ID des entit\u00e9s. Il faut penser \u00e0 v\u00e9rifier le type exact de g\u00e9om\u00e9trie de nos lignes, dans les propri\u00e9t\u00e9s de la couche. 1 2 3 4 5 6 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" pass Le mot-cl\u00e9 pass est juste une instruction Python qui ne fait strictement rien, mais qui permet de rendre une ligne de code valide en respectant l'indentation. Vous pouvez la supprimer d\u00e8s qu'il y a du code. Il faut : Utiliser une session d'\u00e9dition R\u00e9cup\u00e9rer la g\u00e9om\u00e9trie, tenir compte qu'il s'agit d'une multi-ligne Appliquer la fonction reverse en Python Utiliser QgsVectorLayer.changeGeometry() pour changer la g\u00e9om\u00e9trie d'un objet Afficher la solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def reverse_geom ( layer : QgsVectorLayer , ids : list ): \"\"\" Inverser le sens des diff\u00e9rentes entit\u00e9s dans la couche layer. ids est une liste comportant les IDs des entit\u00e9s \u00e0 inverser. \"\"\" with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = iface . activeLayer () ids = layer . selectedFeatureIds () reverse_geom ( layer , ids ) Incorporons ce code dans une action et adaptons-le l\u00e9g\u00e8rement : 1 2 3 4 5 6 7 8 9 10 11 12 def reverse_geom ( layer , ids ): with edit ( layer ): for feature in layer . getFeatures ( ids ): geom = feature . geometry () lines = geom . asMultiPolyline () for line in lines : line . reverse () new_geom = QgsGeometry . fromMultiPolylineXY ( lines ) layer . changeGeometry ( feature . id (), new_geom ) layer = QgsProject . instance () . mapLayer ( '[% @layer_id %]' ) reverse_geom ( layer , '[% $id %]' ) On peut d\u00e9sormais cliquer sur une ligne pour automatiquement inverser une ligne. Le code de l'action est enregistr\u00e9 dans le style QML de la couche vecteur. Il peut donc \u00eatre partag\u00e9 avec d'autres utilisateurs qui ne connaissent pas Python.","title":"Notre propre action"},{"location":"action/#astuce-pour-stocker-le-code-dune-action-dans-une-extension-qgis","text":"Tip Pour suivre cette partie, il faut la plupart du temps une extension par exemple, voir l'autre chapitre , afin de stocker le code Python. Pour \u00e9viter d'avoir du code les propri\u00e9t\u00e9s de la couche QGIS, on peut r\u00e9duire le code Python au minimum en faisant dans le c\u0153ur de l'action uniquement l'import d'une fonction et de lancer son ex\u00e9cution. Exemple du code d'une action dans l'extension QuickOSM lors de l'ex\u00e9cution d'une requ\u00eate rapide : 1 2 from QuickOSM.core.actions import Actions Actions . run ( \"josm\" , \"[% \" full_id \" %]\" ) Ou alors l'extension RAEPA : 1 2 from qgis.utils import plugins plugins [ 'raepa' ] . run_action ( \"nom_de_laction\" , params )","title":"Astuce pour stocker le code d'une action dans une extension QGIS"},{"location":"console/","text":"Introduction \u00e0 la console Python # La documentation et les liens utiles # QGIS est compos\u00e9 de plusieurs centaines de classes \u00e9crites en C++. La plupart de ces classes (et donc des fonctions) sont accessibles \u00e0 travers un API en Python. Comme il n'est pas possible de m\u00e9moriser enti\u00e8rement l'API de QGIS, il est n\u00e9cessaire de conna\u00eetre la documentation et comment rechercher des informations. QGIS repose sur la librairie Qt version 5 pour l'interface graphique et sur Python version 3. Toutes les classes QGIS commencent par Qgs et toutes les classes Qt commencent par Q . Voici une liste de liens pour la documentation : https://docs.qgis.org qui regroupe : Le Python Cookbook https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook (recette de cuisine) L'API C++ https://qgis.org/api/3.16/ L'API Python https://qgis.org/pyqgis/3.16/ Documentation de l'API Qt Documentation de Python Le module os.path par exemple , module historique pour manipuler des chemins Le module Pathlib Voici une liste non exhaustive de blog-post utiles pour manipuler PyQGIS : Optimisation des couches vecteurs Parcourir la l\u00e9gende en 3 parties Plugin Processing Workshop sur les expressions en Python Autre lien pour l'apprentissage de Python (sans QGIS) : https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python Configurer le projet # Commencer un nouveau projet et enregistrer le. \u00c0 c\u00f4t\u00e9 du projet, ajouter le dossier provenant d\u2019OSM2Igeo, par exemple 201909_11_ILE_DE_FRANCE_SHP_L93_2154 . Manipulation dans la console # Rappel sur la POO # La Programmation Orient\u00e9e Objet, POO : la POO permet de mieux mod\u00e9liser la r\u00e9alit\u00e9 en concevant des mod\u00e8les d'objets, les classes les objets sont cr\u00e9\u00e9s ind\u00e9pendamment les uns des autres, gr\u00e2ce \u00e0 l'encapsulation, m\u00e9canisme qui permet d'embarquer leurs propri\u00e9t\u00e9s les classes permettent d'\u00e9viter au maximum l'emploi des variables globales Imaginons le cas d'une voiture. Une voiture est un objet, on peut en cr\u00e9er une instance. Sur cette instance, on a des \"propri\u00e9t\u00e9s\" comme : la couleur de la voiture le nombre de chevaux le nombre de portes la marque le propri\u00e9taire (qui peut-\u00eatre un autre objet \"Personne\") Sur cette instance, on a des \"m\u00e9thodes\" : avancer reculer tourner \u00e0 gauche verrouiller les portes activer les clignotants classDiagram class Voiture{ +Color Couleur +Int NbPuissance +Int NbPortes +String Marque +Personne Proprietaire +avancer() bool +reculer(amount) int +tourner(direction) bool } Pratique # Dans QGIS, Plugins -> Console Python QGIS nous donne acc\u00e8s au projet actuel via la classe QgsProject https://qgis.org/api/classQgsProject.html https://qgis.org/pyqgis/3.16/core/QgsProject.html Dans la documentation (en C++ surtout), on remarque plusieurs sections : Public types Public slots Signals Public Member Functions Static Public Member Functions Nous verrons progressivement ces diff\u00e9rentes sections. Recherchons filename . 1 2 project = QgsProject . instance () project . fileName () Ajoutons un titre \u00e0 notre projet, recherchons donc title dans la page : setTitle dans la classe QgsProject . Warning Il est important de bien pouvoir lire la signature des m\u00e9thodes . La m\u00e9thode title retourne une QString et ne prend pas de param\u00e8tre. La m\u00e9thode setTitle retourne rien , ( void ) mais elle prend un param\u00e8tre, une QString . Objectif, ajouter une couche vecteur contenu dans un dossier fils : Recherchons dans l'API le dossier racine du projet. Indice , en informatique, on appelle souvent cela le home . Nous allons utiliser le module os.path pour manipuler les dossiers. https://docs.python.org/3/library/os.path.html join , isfile , isdir 1 2 3 4 5 6 7 8 9 10 11 12 from os.path import join , isfile , isdir racine = QgsProject . instance () . homePath () join ( racine , 'nexistepas' ) '/home/etienne/Documents/3liz/formation/nexistepas' isfile ( join ( racine , 'nexistepas' )) False isdir ( join ( racine , 'nexistepas' )) False chemin = join ( racine , '201909_11_ILE_DE_FRANCE_SHP_L93_2154' , 'H_OSM_ADMINISTRATIF' ) fichier_shape = join ( chemin , 'COMMUNE.shp' ) isfile ( fichier_shape ) True Charger la couche vecteur \u00e0 l'aide de iface QgisInterface (et non pas Qgs Interface !) 1 2 communes = iface . addVectorLayer ( fichier_shape , 'communes' , 'ogr' ) print ( communes ) Charger la couche autrement (conseill\u00e9) 1 2 3 communes = QgsVectorLayer ( fichier_shape , 'communes' , 'ogr' ) communes . isValid () QgsProject . instance () . addMapLayer ( communes ) Afficher la solution compl\u00e8te 1 2 3 4 5 6 7 8 9 10 from os.path import join , isfile , isdir project = QgsProject . instance () racine = project . homePath () chemin = join ( racine , '202103_OSM2IGEO_91_LANGUEDOC_ROUSSILLON_SHP_L93_2154' , 'H_OSM_ADMINISTRATIF' ) fichier_shape = join ( chemin , 'COMMUNE.shp' ) communes = QgsVectorLayer ( fichier_shape , 'communes' , 'ogr' ) communes . isValid () QgsProject . instance () . addMapLayer ( communes ) Explorer l'objet communes qui est un QgsVectorLayer \u00e0 l'aide de la documentation pour chercher sa g\u00e9om\u00e9trie, le nombre d'entit\u00e9s. API QgsVectorLayer C++ , API QgsVectorLayer Python Pour la g\u00e9om\u00e9trie, toujours utiliser l'\u00e9num\u00e9ration et non pas le chiffre (explication dans l'exemple ci-dessous) Essayer d'ouvrir et de clore une session d'\u00e9dition Essayer d\u00e9sormais de chercher son nom, la projection ou encore les seuils de visibilit\u00e9 de la couche. On ne les trouve pas dans la page QgsVectorLayer ! Pour cela, il faut faire r\u00e9f\u00e9rence \u00e0 la notion d'h\u00e9ritage en Programmation Orient\u00e9e Objet. classDiagram class QgsMapLayer{ +name() str +crs() QgsCoordinateReferenceSystem +autreFonctions() } class QgsVectorLayer{ +startEditing() bool +commitChanges() bool +autreFonctionsPourUneCoucheVecteur() } class QgsRasterLayer{ +int largeur +int hauteur +autreFonctionsPourUneCoucheRaster() } QgsMapLayer <-- QgsVectorLayer QgsMapLayer <-- QgsRasterLayer L'objet QgsVectorLayer h\u00e9rite de QgsMapLayer qui est une classe commune avec QgsMapLayer . API QgsMapLayer C++ , API QgsMapLayer Python Regardons la fonction isinstance qui permet de tester si un objet est une instance d'une classe : 1 2 3 4 5 6 isinstance ( communes , QgsVectorLayer ) True isinstance ( communes , QgsRasterLayer ) False isinstance ( communes , QgsMapLayer ) True Objectif, ne pas afficher la couche commune pour une \u00e9chelle plus petite que le 1:2 000 000 . Code # Petit r\u00e9capitulatif \u00e0 tester pour voir si cela fonctionne correctement ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) result = QgsProject . instance () . addMapLayer ( layer ) print ( layer . featureCount ()) print ( layer . crs () . authid ()) print ( 'Est en m\u00e8tre : {} ' . format ( layer . crs () . mapUnits () == QgsUnitTypes . DistanceMeters )) print ( layer . name ()) layer . setScaleBasedVisibility ( True ) layer . setMaximumScale ( 1 ) layer . setMinimumScale ( 2000000 ) layer . triggerRepaint () Ajouter \u00e9galement la couche ARRONDISSEMENT et s\u00e9lectionner l\u00e0. Parcourir les entit\u00e9s # Un raccourci a savoir, dans la console : 1 iface . activeLayer () Cela retourne la couche QgsMapLayer active dans la l\u00e9gende ! On souhaite d\u00e9sormais it\u00e9rer sur les polygones et les faire clignoter depuis la console. Nous allons donc avoir besoin de la m\u00e9thode getFeatures() qui fait partie de QgsVectorLayer . 1 2 3 4 5 6 layer = iface . activeLayer () features = layer . getFeatures () features feature = QgsFeature () features . nextFeature ( feature ) iface . mapCanvas () . flashFeatureIds ( layer , [ feature . id ()]) Note , nous pouvons concat\u00e9ner les deux derni\u00e8res lignes \u00e0 l'aide du caract\u00e8re ; pour que cela soit plus pratique. Ce code est plus pour la partie \"amusante\" pour montrer les limites de la console. Nous allons d\u00e9sormais utiliser un script Python dans le prochain chapitre. Petite chose suppl\u00e9mentaire avant de passer aux scripts, on souhaite d\u00e9sormais afficher le nom des arrondissements \u00e0 l'aide d'une boucle for . 1 2 3 4 5 layer = iface . activeLayer () for feature in layer . getFeatures (): # On peut traiter l'entit\u00e9 courante gr\u00e2ce \u00e0 la variable \"feature\". # Pour acc\u00e9der \u00e0 un attribut en particulier, on peut y acc\u00e9der avec des crochets. pass Noter l'apparition de ... au lieu de >>> apr\u00e8s avoir \u00e9crit la premi\u00e8re ligne du for . Il faut faire une indentation obligatoire ! Pour afficher un attribut, on peut faire print(feature['NOM_ARR'] pour afficher le contenu de l'attribut NOM_ARR .","title":"Console"},{"location":"console/#introduction-a-la-console-python","text":"","title":"Introduction \u00e0 la console Python"},{"location":"console/#la-documentation-et-les-liens-utiles","text":"QGIS est compos\u00e9 de plusieurs centaines de classes \u00e9crites en C++. La plupart de ces classes (et donc des fonctions) sont accessibles \u00e0 travers un API en Python. Comme il n'est pas possible de m\u00e9moriser enti\u00e8rement l'API de QGIS, il est n\u00e9cessaire de conna\u00eetre la documentation et comment rechercher des informations. QGIS repose sur la librairie Qt version 5 pour l'interface graphique et sur Python version 3. Toutes les classes QGIS commencent par Qgs et toutes les classes Qt commencent par Q . Voici une liste de liens pour la documentation : https://docs.qgis.org qui regroupe : Le Python Cookbook https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook (recette de cuisine) L'API C++ https://qgis.org/api/3.16/ L'API Python https://qgis.org/pyqgis/3.16/ Documentation de l'API Qt Documentation de Python Le module os.path par exemple , module historique pour manipuler des chemins Le module Pathlib Voici une liste non exhaustive de blog-post utiles pour manipuler PyQGIS : Optimisation des couches vecteurs Parcourir la l\u00e9gende en 3 parties Plugin Processing Workshop sur les expressions en Python Autre lien pour l'apprentissage de Python (sans QGIS) : https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python","title":"La documentation et les liens utiles"},{"location":"console/#configurer-le-projet","text":"Commencer un nouveau projet et enregistrer le. \u00c0 c\u00f4t\u00e9 du projet, ajouter le dossier provenant d\u2019OSM2Igeo, par exemple 201909_11_ILE_DE_FRANCE_SHP_L93_2154 .","title":"Configurer le projet"},{"location":"console/#manipulation-dans-la-console","text":"","title":"Manipulation dans la console"},{"location":"console/#rappel-sur-la-poo","text":"La Programmation Orient\u00e9e Objet, POO : la POO permet de mieux mod\u00e9liser la r\u00e9alit\u00e9 en concevant des mod\u00e8les d'objets, les classes les objets sont cr\u00e9\u00e9s ind\u00e9pendamment les uns des autres, gr\u00e2ce \u00e0 l'encapsulation, m\u00e9canisme qui permet d'embarquer leurs propri\u00e9t\u00e9s les classes permettent d'\u00e9viter au maximum l'emploi des variables globales Imaginons le cas d'une voiture. Une voiture est un objet, on peut en cr\u00e9er une instance. Sur cette instance, on a des \"propri\u00e9t\u00e9s\" comme : la couleur de la voiture le nombre de chevaux le nombre de portes la marque le propri\u00e9taire (qui peut-\u00eatre un autre objet \"Personne\") Sur cette instance, on a des \"m\u00e9thodes\" : avancer reculer tourner \u00e0 gauche verrouiller les portes activer les clignotants classDiagram class Voiture{ +Color Couleur +Int NbPuissance +Int NbPortes +String Marque +Personne Proprietaire +avancer() bool +reculer(amount) int +tourner(direction) bool }","title":"Rappel sur la POO"},{"location":"console/#pratique","text":"Dans QGIS, Plugins -> Console Python QGIS nous donne acc\u00e8s au projet actuel via la classe QgsProject https://qgis.org/api/classQgsProject.html https://qgis.org/pyqgis/3.16/core/QgsProject.html Dans la documentation (en C++ surtout), on remarque plusieurs sections : Public types Public slots Signals Public Member Functions Static Public Member Functions Nous verrons progressivement ces diff\u00e9rentes sections. Recherchons filename . 1 2 project = QgsProject . instance () project . fileName () Ajoutons un titre \u00e0 notre projet, recherchons donc title dans la page : setTitle dans la classe QgsProject . Warning Il est important de bien pouvoir lire la signature des m\u00e9thodes . La m\u00e9thode title retourne une QString et ne prend pas de param\u00e8tre. La m\u00e9thode setTitle retourne rien , ( void ) mais elle prend un param\u00e8tre, une QString . Objectif, ajouter une couche vecteur contenu dans un dossier fils : Recherchons dans l'API le dossier racine du projet. Indice , en informatique, on appelle souvent cela le home . Nous allons utiliser le module os.path pour manipuler les dossiers. https://docs.python.org/3/library/os.path.html join , isfile , isdir 1 2 3 4 5 6 7 8 9 10 11 12 from os.path import join , isfile , isdir racine = QgsProject . instance () . homePath () join ( racine , 'nexistepas' ) '/home/etienne/Documents/3liz/formation/nexistepas' isfile ( join ( racine , 'nexistepas' )) False isdir ( join ( racine , 'nexistepas' )) False chemin = join ( racine , '201909_11_ILE_DE_FRANCE_SHP_L93_2154' , 'H_OSM_ADMINISTRATIF' ) fichier_shape = join ( chemin , 'COMMUNE.shp' ) isfile ( fichier_shape ) True Charger la couche vecteur \u00e0 l'aide de iface QgisInterface (et non pas Qgs Interface !) 1 2 communes = iface . addVectorLayer ( fichier_shape , 'communes' , 'ogr' ) print ( communes ) Charger la couche autrement (conseill\u00e9) 1 2 3 communes = QgsVectorLayer ( fichier_shape , 'communes' , 'ogr' ) communes . isValid () QgsProject . instance () . addMapLayer ( communes ) Afficher la solution compl\u00e8te 1 2 3 4 5 6 7 8 9 10 from os.path import join , isfile , isdir project = QgsProject . instance () racine = project . homePath () chemin = join ( racine , '202103_OSM2IGEO_91_LANGUEDOC_ROUSSILLON_SHP_L93_2154' , 'H_OSM_ADMINISTRATIF' ) fichier_shape = join ( chemin , 'COMMUNE.shp' ) communes = QgsVectorLayer ( fichier_shape , 'communes' , 'ogr' ) communes . isValid () QgsProject . instance () . addMapLayer ( communes ) Explorer l'objet communes qui est un QgsVectorLayer \u00e0 l'aide de la documentation pour chercher sa g\u00e9om\u00e9trie, le nombre d'entit\u00e9s. API QgsVectorLayer C++ , API QgsVectorLayer Python Pour la g\u00e9om\u00e9trie, toujours utiliser l'\u00e9num\u00e9ration et non pas le chiffre (explication dans l'exemple ci-dessous) Essayer d'ouvrir et de clore une session d'\u00e9dition Essayer d\u00e9sormais de chercher son nom, la projection ou encore les seuils de visibilit\u00e9 de la couche. On ne les trouve pas dans la page QgsVectorLayer ! Pour cela, il faut faire r\u00e9f\u00e9rence \u00e0 la notion d'h\u00e9ritage en Programmation Orient\u00e9e Objet. classDiagram class QgsMapLayer{ +name() str +crs() QgsCoordinateReferenceSystem +autreFonctions() } class QgsVectorLayer{ +startEditing() bool +commitChanges() bool +autreFonctionsPourUneCoucheVecteur() } class QgsRasterLayer{ +int largeur +int hauteur +autreFonctionsPourUneCoucheRaster() } QgsMapLayer <-- QgsVectorLayer QgsMapLayer <-- QgsRasterLayer L'objet QgsVectorLayer h\u00e9rite de QgsMapLayer qui est une classe commune avec QgsMapLayer . API QgsMapLayer C++ , API QgsMapLayer Python Regardons la fonction isinstance qui permet de tester si un objet est une instance d'une classe : 1 2 3 4 5 6 isinstance ( communes , QgsVectorLayer ) True isinstance ( communes , QgsRasterLayer ) False isinstance ( communes , QgsMapLayer ) True Objectif, ne pas afficher la couche commune pour une \u00e9chelle plus petite que le 1:2 000 000 .","title":"Pratique"},{"location":"console/#code","text":"Petit r\u00e9capitulatif \u00e0 tester pour voir si cela fonctionne correctement ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) result = QgsProject . instance () . addMapLayer ( layer ) print ( layer . featureCount ()) print ( layer . crs () . authid ()) print ( 'Est en m\u00e8tre : {} ' . format ( layer . crs () . mapUnits () == QgsUnitTypes . DistanceMeters )) print ( layer . name ()) layer . setScaleBasedVisibility ( True ) layer . setMaximumScale ( 1 ) layer . setMinimumScale ( 2000000 ) layer . triggerRepaint () Ajouter \u00e9galement la couche ARRONDISSEMENT et s\u00e9lectionner l\u00e0.","title":"Code"},{"location":"console/#parcourir-les-entites","text":"Un raccourci a savoir, dans la console : 1 iface . activeLayer () Cela retourne la couche QgsMapLayer active dans la l\u00e9gende ! On souhaite d\u00e9sormais it\u00e9rer sur les polygones et les faire clignoter depuis la console. Nous allons donc avoir besoin de la m\u00e9thode getFeatures() qui fait partie de QgsVectorLayer . 1 2 3 4 5 6 layer = iface . activeLayer () features = layer . getFeatures () features feature = QgsFeature () features . nextFeature ( feature ) iface . mapCanvas () . flashFeatureIds ( layer , [ feature . id ()]) Note , nous pouvons concat\u00e9ner les deux derni\u00e8res lignes \u00e0 l'aide du caract\u00e8re ; pour que cela soit plus pratique. Ce code est plus pour la partie \"amusante\" pour montrer les limites de la console. Nous allons d\u00e9sormais utiliser un script Python dans le prochain chapitre. Petite chose suppl\u00e9mentaire avant de passer aux scripts, on souhaite d\u00e9sormais afficher le nom des arrondissements \u00e0 l'aide d'une boucle for . 1 2 3 4 5 layer = iface . activeLayer () for feature in layer . getFeatures (): # On peut traiter l'entit\u00e9 courante gr\u00e2ce \u00e0 la variable \"feature\". # Pour acc\u00e9der \u00e0 un attribut en particulier, on peut y acc\u00e9der avec des crochets. pass Noter l'apparition de ... au lieu de >>> apr\u00e8s avoir \u00e9crit la premi\u00e8re ligne du for . Il faut faire une indentation obligatoire ! Pour afficher un attribut, on peut faire print(feature['NOM_ARR'] pour afficher le contenu de l'attribut NOM_ARR .","title":"Parcourir les entit\u00e9s"},{"location":"extension-deploiement/","text":"Comment d\u00e9ployer son extension # Comme vu dans le chapitre concernant la cr\u00e9ation d'une extension g\u00e9n\u00e9rique , une extension QGIS est un dossier comportant : un dossier qui est nom_du_module : metadata.txt __init__.py avec classFactory d'autres fichiers Python des fichiers QtDesigner UI, SVG, couches etc Ce dossier doit \u00eatre zipp\u00e9. Pour du d\u00e9ploiement, nous recommandons l'usage de QGIS-Plugin-CI qui peut faire du packaging, la g\u00e9n\u00e9ration du plugins.xml , envoyer sur plugins.qgis.org etc. En interne # Si on souhaite publier en interne, on peut d\u00e9poser son dossier zip sur un serveur et on recommande l'utilisation du fichier plugins.xml qui permet de renseigner \u00e0 QGIS la disponibilit\u00e9 d'une extension. Exemple avec l'installation de PgMetadata et son fichier plugins.xml Il est possible de prot\u00e9ger son d\u00e9p\u00f4t avec un login/mot de passe. plugins.qgis.org # Plus simple pour le d\u00e9ploiement car le d\u00e9p\u00f4t plugins.qgis.org est par d\u00e9faut dans les installations de QGIS. Il faut cependant que le code source soit disponible sur internet. Lire les recommandations pour la publication sur ce d\u00e9p\u00f4t : Code source disponible metadata.txt avec les bonnes informations et des liens HTTP valides","title":"D\u00e9ploiement d'une extension"},{"location":"extension-deploiement/#comment-deployer-son-extension","text":"Comme vu dans le chapitre concernant la cr\u00e9ation d'une extension g\u00e9n\u00e9rique , une extension QGIS est un dossier comportant : un dossier qui est nom_du_module : metadata.txt __init__.py avec classFactory d'autres fichiers Python des fichiers QtDesigner UI, SVG, couches etc Ce dossier doit \u00eatre zipp\u00e9. Pour du d\u00e9ploiement, nous recommandons l'usage de QGIS-Plugin-CI qui peut faire du packaging, la g\u00e9n\u00e9ration du plugins.xml , envoyer sur plugins.qgis.org etc.","title":"Comment d\u00e9ployer son extension"},{"location":"extension-deploiement/#en-interne","text":"Si on souhaite publier en interne, on peut d\u00e9poser son dossier zip sur un serveur et on recommande l'utilisation du fichier plugins.xml qui permet de renseigner \u00e0 QGIS la disponibilit\u00e9 d'une extension. Exemple avec l'installation de PgMetadata et son fichier plugins.xml Il est possible de prot\u00e9ger son d\u00e9p\u00f4t avec un login/mot de passe.","title":"En interne"},{"location":"extension-deploiement/#pluginsqgisorg","text":"Plus simple pour le d\u00e9ploiement car le d\u00e9p\u00f4t plugins.qgis.org est par d\u00e9faut dans les installations de QGIS. Il faut cependant que le code source soit disponible sur internet. Lire les recommandations pour la publication sur ce d\u00e9p\u00f4t : Code source disponible metadata.txt avec les bonnes informations et des liens HTTP valides","title":"plugins.qgis.org"},{"location":"extension-generique/","text":"La base pour cr\u00e9er une extension # Pour cr\u00e9er une extension dans QGIS, il existe deux fa\u00e7ons de d\u00e9marrer : Utilisation de l'extension \"Plugin Builder\" : Disponible depuis le gestionnaire des extensions de QGIS Assistant de cr\u00e9ation Tr\u00e8s (trop) complet, il y a squelette pour : Du code avec des actions, ... G\u00e9n\u00e9rer de la documentation Sphinx Des tests unitaires Les traductions (multilingue) Tr\u00e8s historique, moins mis \u00e0 jour ces derni\u00e8res ann\u00e9es QGIS Minimal plugin : https://github.com/wonder-sk/qgis-minimal-plugin ZIP \u00e0 t\u00e9l\u00e9charger et \u00e0 extraire Tr\u00e8s l\u00e9ger Besoin de tout refaire depuis z\u00e9ro Nous pouvons suivre une des deux m\u00e9thodes, mais dans le cadre de la formation, faisons la m\u00e9thode minimale. Dans les deux cas, le r\u00e9sultat doit \u00eatre dans le dossier python/plugins du profil courant. Tip Pour trouver le profil courant, dans QGIS, Pr\u00e9f\u00e9rences -> Profils Utilisateurs -> Ouvrir le dossier du profil actif . Tip Pour installer le Minimal Plugin, vous pouvez utiliser le gestionnaire des extensions pour installer depuis un zip. Plugin reloader # Le \"Plugin Reloader\" est une extension indispensable pour d\u00e9velopper une extension pour recharger son extension. Elle est disponible dans le gestionnaire des extensions. Apprendre d'une autre extension # Comme les extensions sur qgis.org sont disponibles sur internet, on peut regarder le code source pour comprendre. Pensez \u00e0 ouvrir le dossier de votre profil QGIS en suivant l'astuce ci-dessus puis dans python/plugins .","title":"Extension G\u00e9n\u00e9rique"},{"location":"extension-generique/#la-base-pour-creer-une-extension","text":"Pour cr\u00e9er une extension dans QGIS, il existe deux fa\u00e7ons de d\u00e9marrer : Utilisation de l'extension \"Plugin Builder\" : Disponible depuis le gestionnaire des extensions de QGIS Assistant de cr\u00e9ation Tr\u00e8s (trop) complet, il y a squelette pour : Du code avec des actions, ... G\u00e9n\u00e9rer de la documentation Sphinx Des tests unitaires Les traductions (multilingue) Tr\u00e8s historique, moins mis \u00e0 jour ces derni\u00e8res ann\u00e9es QGIS Minimal plugin : https://github.com/wonder-sk/qgis-minimal-plugin ZIP \u00e0 t\u00e9l\u00e9charger et \u00e0 extraire Tr\u00e8s l\u00e9ger Besoin de tout refaire depuis z\u00e9ro Nous pouvons suivre une des deux m\u00e9thodes, mais dans le cadre de la formation, faisons la m\u00e9thode minimale. Dans les deux cas, le r\u00e9sultat doit \u00eatre dans le dossier python/plugins du profil courant. Tip Pour trouver le profil courant, dans QGIS, Pr\u00e9f\u00e9rences -> Profils Utilisateurs -> Ouvrir le dossier du profil actif . Tip Pour installer le Minimal Plugin, vous pouvez utiliser le gestionnaire des extensions pour installer depuis un zip.","title":"La base pour cr\u00e9er une extension"},{"location":"extension-generique/#plugin-reloader","text":"Le \"Plugin Reloader\" est une extension indispensable pour d\u00e9velopper une extension pour recharger son extension. Elle est disponible dans le gestionnaire des extensions.","title":"Plugin reloader"},{"location":"extension-generique/#apprendre-dune-autre-extension","text":"Comme les extensions sur qgis.org sont disponibles sur internet, on peut regarder le code source pour comprendre. Pensez \u00e0 ouvrir le dossier de votre profil QGIS en suivant l'astuce ci-dessus puis dans python/plugins .","title":"Apprendre d'une autre extension"},{"location":"extension-graphique/","text":"Cr\u00e9er une extension QGIS avec une interface graphique # Pour faire ce chapitre, il faut d'abord avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent. QtDesigner # Cr\u00e9ons un fichier QtDesigner comme-ceci : et y ajouter des \"widgets\" : Astuces # Ouvrir la page des \"slots/signaux\" depuis la barre d'outils et supprimer ceux qui existent. Faire un clic droit sur \"QDialog\" \u00e0 droite et faire une mise en page \"vertical\". Tip Ne pas changer la propri\u00e9t\u00e9 objectName pour le moment. On peut t\u00e9l\u00e9charger la solution si besoin. La classe qui accompagne # Cr\u00e9ons un fichier dialog.py avec le contenu suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self ): super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner Modifions la m\u00e9thode la m\u00e9thode run du fichier __init__.py en 1 2 3 4 def run ( self ): from .dialog import MonDialog dialog = MonDialog () dialog . exec_ () Relan\u00e7ons l'extension \u00e0 l'aide du \"plugin reloader\" et cliquons sur le bouton. Les signaux et les slots # Connectons le signal clicked du bouton \"Annuler\" dans le constructeur __init__ : 1 self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) On dit que clicked est un signal , auquel on connecte le slot close . Connectons-le signal clicked du bouton \"Accepter\" \u00e0 notre propre slot (qui est une fonction) : 1 self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) et ajoutons notre propre fonction click_ok pour quitter la fen\u00eatre et en affichant la saisie de l'utilisateur dans la QgsMessageBar de QGIS. Le widget de saisie est un QLineEdit : https://doc.qt.io/qt-5/qlineedit.html 1 2 3 def click_ok ( self ): message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) Faire le test dans QGIS avec une saisie de l'utilisateur et fermer la fen\u00eatre. Continuons en rendant en lecture seule le gros bloc de texte et affichons \u00e0 l'int\u00e9rieur la description de la la couche qui est s\u00e9lectionn\u00e9e dans le menu d\u00e9roulant. Documentation : QPlainTextEdit : https://doc.qt.io/qt-5/qplaintextedit.html QgsMapLayerComboBox : https://qgis.org/api/classQgsMapLayerComboBox.html Dans le __init__ : 1 2 self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) Et la nouvelle fonction qui va se charger de mettre \u00e0 jour le texte : 1 2 3 4 5 6 7 def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" ) On peut donc d\u00e9sormais cumuler l'ensemble des chapitres pr\u00e9c\u00e9dents pour lancer des algorithmes, manipuler les donn\u00e9es, etc. Solution # Afficher 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self , parent = None ): _ = parent super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner # Connectons les signaux self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) def click_ok ( self ): self . close () message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" ) Organisation du code # Il ne faut pas h\u00e9siter \u00e0 cr\u00e9er des fichiers afin de s\u00e9parer le code. On peut aussi cr\u00e9er des dossiers afin d'y mettre plusieurs fichiers Pythons. Un dossier en Python se nomme un module . Pour faire un module compatible, il faut ajouter un fichier __init__.py m\u00eame s\u2019il n'y a rien dedans. Warning Il ne faut vraiment pas oublier le fichier __init__.py . Cela peut emp\u00eacher Python de fonctionner correctement. Un bon IDE peut signaler ce genre d'erreur. Dans l'exemple ci-dessus, on peut diviser le code du fichier __init__.py : 1 2 3 def classFactory ( iface ): from minimal.plugin import MinimalPlugin return MinimalPlugin ( iface ) En faisant un couper/coller, enlever la classe MinimalPlugin du fichier __init__.py . Tip On essaie souvent d'avoir une classe par fichier en Python. Cr\u00e9er un fichier plugin.py et ajouter le contenu en collant. Il est bien de v\u00e9rifier les imports dans les deux fichiers.","title":"Extension Graphique"},{"location":"extension-graphique/#creer-une-extension-qgis-avec-une-interface-graphique","text":"Pour faire ce chapitre, il faut d'abord avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent.","title":"Cr\u00e9er une extension QGIS avec une interface graphique"},{"location":"extension-graphique/#qtdesigner","text":"Cr\u00e9ons un fichier QtDesigner comme-ceci : et y ajouter des \"widgets\" :","title":"QtDesigner"},{"location":"extension-graphique/#astuces","text":"Ouvrir la page des \"slots/signaux\" depuis la barre d'outils et supprimer ceux qui existent. Faire un clic droit sur \"QDialog\" \u00e0 droite et faire une mise en page \"vertical\". Tip Ne pas changer la propri\u00e9t\u00e9 objectName pour le moment. On peut t\u00e9l\u00e9charger la solution si besoin.","title":"Astuces"},{"location":"extension-graphique/#la-classe-qui-accompagne","text":"Cr\u00e9ons un fichier dialog.py avec le contenu suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self ): super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner Modifions la m\u00e9thode la m\u00e9thode run du fichier __init__.py en 1 2 3 4 def run ( self ): from .dialog import MonDialog dialog = MonDialog () dialog . exec_ () Relan\u00e7ons l'extension \u00e0 l'aide du \"plugin reloader\" et cliquons sur le bouton.","title":"La classe qui accompagne"},{"location":"extension-graphique/#les-signaux-et-les-slots","text":"Connectons le signal clicked du bouton \"Annuler\" dans le constructeur __init__ : 1 self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) On dit que clicked est un signal , auquel on connecte le slot close . Connectons-le signal clicked du bouton \"Accepter\" \u00e0 notre propre slot (qui est une fonction) : 1 self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) et ajoutons notre propre fonction click_ok pour quitter la fen\u00eatre et en affichant la saisie de l'utilisateur dans la QgsMessageBar de QGIS. Le widget de saisie est un QLineEdit : https://doc.qt.io/qt-5/qlineedit.html 1 2 3 def click_ok ( self ): message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) Faire le test dans QGIS avec une saisie de l'utilisateur et fermer la fen\u00eatre. Continuons en rendant en lecture seule le gros bloc de texte et affichons \u00e0 l'int\u00e9rieur la description de la la couche qui est s\u00e9lectionn\u00e9e dans le menu d\u00e9roulant. Documentation : QPlainTextEdit : https://doc.qt.io/qt-5/qplaintextedit.html QgsMapLayerComboBox : https://qgis.org/api/classQgsMapLayerComboBox.html Dans le __init__ : 1 2 self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) Et la nouvelle fonction qui va se charger de mettre \u00e0 jour le texte : 1 2 3 4 5 6 7 def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" ) On peut donc d\u00e9sormais cumuler l'ensemble des chapitres pr\u00e9c\u00e9dents pour lancer des algorithmes, manipuler les donn\u00e9es, etc.","title":"Les signaux et les slots"},{"location":"extension-graphique/#solution","text":"Afficher 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from qgis.core import Qgis from qgis.utils import iface from qgis.PyQt.QtWidgets import QDialog , QDialogButtonBox from qgis.PyQt import uic from pathlib import Path folder = Path ( __file__ ) . resolve () . parent ui_file = folder . joinpath ( 'dialog.ui' ) ui_class , _ = uic . loadUiType ( ui_file ) class MonDialog ( ui_class , QDialog ): def __init__ ( self , parent = None ): _ = parent super () . __init__ () self . setupUi ( self ) # Fichier de QtDesigner # Connectons les signaux self . buttonBox . button ( QDialogButtonBox . Ok ) . clicked . connect ( self . click_ok ) self . buttonBox . button ( QDialogButtonBox . Cancel ) . clicked . connect ( self . close ) self . plainTextEdit . setReadOnly ( True ) self . mMapLayerComboBox . layerChanged . connect ( self . layer_changed ) def click_ok ( self ): self . close () message = self . lineEdit . text () iface . messageBar () . pushMessage ( 'Notre plugin' , message , Qgis . Success ) def layer_changed ( self ): self . plainTextEdit . clear () layer = self . mMapLayerComboBox . currentLayer () if layer : self . plainTextEdit . appendPlainText ( f \" { layer . name () } : { layer . crs () . authid () } \" ) else : self . plainTextEdit . appendPlainText ( \"Pas de couche\" )","title":"Solution"},{"location":"extension-graphique/#organisation-du-code","text":"Il ne faut pas h\u00e9siter \u00e0 cr\u00e9er des fichiers afin de s\u00e9parer le code. On peut aussi cr\u00e9er des dossiers afin d'y mettre plusieurs fichiers Pythons. Un dossier en Python se nomme un module . Pour faire un module compatible, il faut ajouter un fichier __init__.py m\u00eame s\u2019il n'y a rien dedans. Warning Il ne faut vraiment pas oublier le fichier __init__.py . Cela peut emp\u00eacher Python de fonctionner correctement. Un bon IDE peut signaler ce genre d'erreur. Dans l'exemple ci-dessus, on peut diviser le code du fichier __init__.py : 1 2 3 def classFactory ( iface ): from minimal.plugin import MinimalPlugin return MinimalPlugin ( iface ) En faisant un couper/coller, enlever la classe MinimalPlugin du fichier __init__.py . Tip On essaie souvent d'avoir une classe par fichier en Python. Cr\u00e9er un fichier plugin.py et ajouter le contenu en collant. Il est bien de v\u00e9rifier les imports dans les deux fichiers.","title":"Organisation du code"},{"location":"extension-processing/","text":"Cr\u00e9er une extension QGIS pour Processing # Pour faire ce chapitre, il faut : avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent faire la mise \u00e0 jour en extension Processing \u00e0 l'aide de la documentation QGIS","title":"Extension Processing"},{"location":"extension-processing/#creer-une-extension-qgis-pour-processing","text":"Pour faire ce chapitre, il faut : avoir une extension de base, \u00e0 l'aide du chapitre pr\u00e9c\u00e9dent faire la mise \u00e0 jour en extension Processing \u00e0 l'aide de la documentation QGIS","title":"Cr\u00e9er une extension QGIS pour Processing"},{"location":"fonctions-scripts/","text":"Organisation du code dans un script avec des fonctions # Communication avec l'utilisateur des erreurs et des logs # Avant de commencer \u00e0 vraiment \u00e9crire un script avec des fonctions, regardons comment communiquer des informations \u00e0 l'utilisateur. On peut envoyer des messages vers l'utilisateur avec l'utilisation de la messageBar de la classe QgisInterface : 1 2 3 4 iface . messageBar () . pushMessage ( 'Erreur' , 'On peut afficher une erreur' , Qgis . Critical ) iface . messageBar () . pushMessage ( 'Avertissement' , 'ou un avertissement' , Qgis . Warning ) iface . messageBar () . pushMessage ( 'Information' , 'ou une information' , Qgis . Info ) iface . messageBar () . pushMessage ( 'Succ\u00e8s' , 'ou un succ\u00e8s' , Qgis . Success ) Cette fonction prend 3 param\u00e8tres : un titre un message un niveau d'alerte On peut aussi \u00e9crire des logs comme ceci (plus discret, mais plus verbeux) : 1 2 3 4 QgsMessageLog . logMessage ( 'Une erreur est survenue' , 'Notre outil' , Qgis . Critical ) QgsMessageLog . logMessage ( 'Un avertissement' , 'Notre outil' , Qgis . Warning ) QgsMessageLog . logMessage ( 'Une information' , 'Notre outil' , Qgis . Info ) QgsMessageLog . logMessage ( 'Un succ\u00e8s' , 'Notre outil' , Qgis . Success ) Cette fonction prend 3 param\u00e8tres : un message une cat\u00e9gorie, souvent le nom de l'extension ou de l'outil en question un niveau d'alerte Charger automatiquement plusieurs couches \u00e0 l'aide d'un script # La console, c'est bien, mais c'est tr\u00e8s limitant. Passons \u00e0 l'\u00e9criture d'un script qui va nous faciliter l'organisation du code. Ci-dessous, voici le dernier script du chapitre pr\u00e9c\u00e9dent, mais avec la gestion des erreurs ci-dessus : Red\u00e9marrer QGIS N'ouvrez pas le projet pr\u00e9c\u00e9dent Ouvrer la console, puis cliquer sur Afficher l'\u00e9diteur Copier/coller le script ci-dessous Ex\u00e9cuter le 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) else : fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) else : layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) else : QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) \u00c0 l'aide du m\u00e9mo Python : Essayons de faire une fonction qui prend 2 param\u00e8tres la th\u00e9matique (le dossier) le nom du shapefile La fonction se chargera de faire le n\u00e9cessaire, par exemple: charger_couche('H_OSM_ADMINISTRATIF', 'COMMUNE') La fonction peut \u00e9galement retourner False si la couche n'est pas charg\u00e9e (une erreur) ou sinon l'objet couche. 1 2 def charger_couche ( thematique , couche ): pass Tip Le mot-cl\u00e9 pass ne sert \u00e0 rien. C'est un mot-cl\u00e9 Python pour rendre un bloc valide mais ne faisant rien. On peut le supprimer le bloc n'est pas vide. Afficher la solution interm\u00e9diaire 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge une couche shapefile dans une th\u00e9matique.\"\"\" racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) else : fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) else : layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) else : QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' charger_couche ( thematique , couche ) Am\u00e9liorons encore cette solution interm\u00e9diaire avec la gestion des erreurs et aussi en gardant le code le plus \u00e0 gauche possible gr\u00e2ce \u00e0 l'instruction return qui ordonne la sortie de la fonction. Afficher une des solutions finales 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from os.path import join , isfile , isdir def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge une couche shapefile dans une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) return False layer = QgsVectorLayer ( fichier_shape , shapefile , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) return False QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) return layer charger_couche ( 'H_OSM_ADMINISTRATIF' , 'COMMUNE' ) charger_couche ( 'H_OSM_ADMINISTRATIF' , 'ARRONDISSEMENT' ) Essayons de faire une fonction qui liste les shapefiles d'une certaine th\u00e9matique. On peut utiliser la m\u00e9thode os.walk(path) permet de parcourir un chemin et de lister les r\u00e9pertoires et les fichiers. Ou alors on peut utiliser une autre m\u00e9thode, un peu plus \u00e0 la mode en utilisant le mode pathlib qui comporte \u00e9galement les fonctions isfile , isdir etc. En utilisant le module os.walk , un peu historique : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import os def liste_shapefiles ( thematique ): \"\"\"Liste les shapefiles d'une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () shapes = [] for root , directories , files in os . walk ( os . path . join ( racine , dossier , thematique )): for file in files : if file . lower () . endswith ( '.shp' ): shapes . append ( file . replace ( '.shp' , '' )) return shapes shapes = liste_shapefiles ( 'H_OSM_ADMINISTRATIF' ) print ( shapes ) En utilisant le \"nouveau\" module pathlib : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pathlib import Path def liste_shapefiles ( thematique ): \"\"\"Liste les shapefiles d'une th\u00e9matique.\"\"\" racine = QgsProject . instance () . homePath () dossier = Path ( racine ) . joinpath ( '202103_OSM2IGEO_91_LANGUEDOC_ROUSSILLON_SHP_L93_2154' , thematique ) shapes = [] for file in dossier . iterdir (): if file . suffix . lower () == '.shp' : shapes . append ( file . stem ) return shapes shapes = liste_shapefiles ( 'H_OSM_ADMINISTRATIF' ) print ( shapes ) Tip Il faut se r\u00e9f\u00e9rer \u00e0 la documentation du module pathlib pour comprendre le fonctionnement de cette classe. Permettre le chargement automatique de toute une th\u00e9matique. Afficher la solution compl\u00e8te 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import os from os.path import join , isfile , isdir dossier = '202103_OSM2IGEO_91_LANGUEDOC_ROUSSILLON_SHP_L93_2154' # couche = 'COMMUNE' def liste_shapesfiles ( thematique ): \"\"\"Liste les shapes d'une th\u00e9matique\"\"\" racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False shapes = [] for root , directories , files in os . walk ( os . path . join ( racine , dossier , thematique )): # print(files) for file in files : # print(file) if file . lower () . endswith ( '.shp' ): # print(file) shapes . append ( file . replace ( \".shp\" , \"\" )) return shapes def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge des couches suivant une th\u00e9matique.\"\"\" racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) return False layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) return False QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) return layer thematique = 'H_OSM_ADMINISTRATIF' shapes = liste_shapesfiles ( thematique ) for shape in shapes : charger_couche ( thematique , shape ) Extraction des informations sous forme d'un fichier CSV. # On souhaite d\u00e9sormais r\u00e9aliser une fonction d'export des m\u00e9tadonn\u00e9es de nos couches au format CSV, avec son CSVT. Il existe d\u00e9j\u00e0 un module CSV dans Python pour nous aider \u00e0 \u00e9crire un fichier de type CSV, mais nous n'allons pas l'utiliser. Nous allons plut\u00f4t utiliser l'API QGIS pour cr\u00e9er une nouvelle couche en m\u00e9moire comportant les diff\u00e9rentes informations que l'on souhaite exporter. Puis nous allons utiliser l'API pour exporter cette couche m\u00e9moire au format CSV (l'\u00e9quivalent dans QGIS de l'action Exporter la couche ). Les diff\u00e9rents champs qui devront \u00eatre export\u00e9s sont : son nom son type de g\u00e9om\u00e9trie (format humain, lisible) la projection le nombre d'entit\u00e9 l'encodage si le seuil de visibilit\u00e9 est activ\u00e9 la source (le chemin) de la donn\u00e9e Exemple de sortie # nom type projection nombre_entite encodage source seuil_de_visibilite couche_1 Line EPSG:4326 5 UTF-8 /tmp/...geojson False couche_2 Tab No geometry 0 /tmp/...shp True Petit m\u00e9mo # Pour cr\u00e9er une couche tabulaire en m\u00e9moire : 1 layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) La liste des couches : 1 layers = QgsProject . instance () . mapLayers () Pour utiliser une session d'\u00e9dition, on peut faire : 1 2 3 layer . startEditing () # D\u00e9but de la session layer . commitChanges () # Fin de la session en enregistrant layer . rollback () # Fin de la session en annulant les modifications On peut \u00e9galement faire une session d'\u00e9dition avec un \"contexte\": 1 2 3 4 5 6 7 from qgis.core import edit with edit ( layer ): # Faire une \u00e9dition sur la couche pass # \u00c0 la fin du bloc d'indentation, la session d'\u00e9dition est automatiquement close. Nous allons avoir besoin de plusieurs classes dans l'API QGIS : Enregistrer un fichier : la classe QgsVectorFileWriter Un champ : QgsField , attention \u00e0 ne pas confondre avec QgsFields qui lui repr\u00e9sente un ensemble de champs. Une entit\u00e9 : QgsFeature Pour le type de champ, on va avoir besoin de l'API Qt \u00e9galement : https://doc.qt.io/qt-5/qmetatype.html#Type-enum Remplacer QMetaType par QVariant Par exemple, pour cr\u00e9er un nouveau champ de type entier : QgsField('nombre_entit\u00e9', QVariant.Int) Il va y avoir plusieurs \u00e9tapes dans ce script : R\u00e9cup\u00e9rer la liste des couches pr\u00e9sentes dans la l\u00e9gende Cr\u00e9er une couche en m\u00e9moire Ajouter des champs \u00e0 cette couche en utilisant une session d'\u00e9dition It\u00e9rer sur les couches pour ajouter ligne par ligne les m\u00e9tadonn\u00e9es dans une session d'\u00e9dition Enregistrer en CSV la couche m\u00e9moire Tip Pour d\u00e9boguer, on peut afficher la couche m\u00e9moire en question avec QgsProject.instance().addMapLayer() Solution # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from os.path import join layers = QgsProject . instance () . mapLayers () if not layers : iface . messageBar () . pushMessage ( 'Pas de couche' , 'Attention, il n \\' a pas de couche' , Qgis . Warning ) layers = [ layer for layer in layers . values ()] layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) fields = [] fields . append ( QgsField ( 'nom' , QVariant . String )) fields . append ( QgsField ( 'type' , QVariant . String )) fields . append ( QgsField ( 'projection' , QVariant . String )) fields . append ( QgsField ( 'nombre_entite' , QVariant . Int )) fields . append ( QgsField ( 'encodage' , QVariant . String )) fields . append ( QgsField ( 'source' , QVariant . String )) fields . append ( QgsField ( 'seuil_de_visibilite' , QVariant . String )) with edit ( layer_info ): for field in fields : layer_info . addAttribute ( field ) QgsProject . instance () . addMapLayer ( layer_info ) with edit ( layer_info ): for layer in layers : feature = QgsFeature ( layer_info . fields ()) feature . setAttribute ( \"nom\" , layer . name ()) feature . setAttribute ( \"projection\" , layer . crs () . authid ()) feature . setAttribute ( \"nombre_entite\" , layer . featureCount ()) feature . setAttribute ( \"source\" , layer . source ()) feature . setAttribute ( \"type\" , QgsWkbTypes . geometryDisplayString ( layer . geometryType ())) feature . setAttribute ( \"seuil_visibilite\" , layer . hasScaleBasedVisibility ()) layer_info . addFeature ( feature ) QgsVectorFileWriter . writeAsVectorFormat ( layer_info , join ( QgsProject . instance () . homePath (), 'test.csv' ), 'utf-8' , QgsCoordinateReferenceSystem (), 'CSV' , layerOptions = [ 'CREATE_CSVT=YES' ] ) # Afficher une messageBar pour confirmer que c'est OK, en vert ;-)","title":"Fonctions & Scripts"},{"location":"fonctions-scripts/#organisation-du-code-dans-un-script-avec-des-fonctions","text":"","title":"Organisation du code dans un script avec des fonctions"},{"location":"fonctions-scripts/#communication-avec-lutilisateur-des-erreurs-et-des-logs","text":"Avant de commencer \u00e0 vraiment \u00e9crire un script avec des fonctions, regardons comment communiquer des informations \u00e0 l'utilisateur. On peut envoyer des messages vers l'utilisateur avec l'utilisation de la messageBar de la classe QgisInterface : 1 2 3 4 iface . messageBar () . pushMessage ( 'Erreur' , 'On peut afficher une erreur' , Qgis . Critical ) iface . messageBar () . pushMessage ( 'Avertissement' , 'ou un avertissement' , Qgis . Warning ) iface . messageBar () . pushMessage ( 'Information' , 'ou une information' , Qgis . Info ) iface . messageBar () . pushMessage ( 'Succ\u00e8s' , 'ou un succ\u00e8s' , Qgis . Success ) Cette fonction prend 3 param\u00e8tres : un titre un message un niveau d'alerte On peut aussi \u00e9crire des logs comme ceci (plus discret, mais plus verbeux) : 1 2 3 4 QgsMessageLog . logMessage ( 'Une erreur est survenue' , 'Notre outil' , Qgis . Critical ) QgsMessageLog . logMessage ( 'Un avertissement' , 'Notre outil' , Qgis . Warning ) QgsMessageLog . logMessage ( 'Une information' , 'Notre outil' , Qgis . Info ) QgsMessageLog . logMessage ( 'Un succ\u00e8s' , 'Notre outil' , Qgis . Success ) Cette fonction prend 3 param\u00e8tres : un message une cat\u00e9gorie, souvent le nom de l'extension ou de l'outil en question un niveau d'alerte","title":"Communication avec l'utilisateur des erreurs et des logs"},{"location":"fonctions-scripts/#charger-automatiquement-plusieurs-couches-a-laide-dun-script","text":"La console, c'est bien, mais c'est tr\u00e8s limitant. Passons \u00e0 l'\u00e9criture d'un script qui va nous faciliter l'organisation du code. Ci-dessous, voici le dernier script du chapitre pr\u00e9c\u00e9dent, mais avec la gestion des erreurs ci-dessus : Red\u00e9marrer QGIS N'ouvrez pas le projet pr\u00e9c\u00e9dent Ouvrer la console, puis cliquer sur Afficher l'\u00e9diteur Copier/coller le script ci-dessous Ex\u00e9cuter le 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) else : fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) else : layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) else : QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) \u00c0 l'aide du m\u00e9mo Python : Essayons de faire une fonction qui prend 2 param\u00e8tres la th\u00e9matique (le dossier) le nom du shapefile La fonction se chargera de faire le n\u00e9cessaire, par exemple: charger_couche('H_OSM_ADMINISTRATIF', 'COMMUNE') La fonction peut \u00e9galement retourner False si la couche n'est pas charg\u00e9e (une erreur) ou sinon l'objet couche. 1 2 def charger_couche ( thematique , couche ): pass Tip Le mot-cl\u00e9 pass ne sert \u00e0 rien. C'est un mot-cl\u00e9 Python pour rendre un bloc valide mais ne faisant rien. On peut le supprimer le bloc n'est pas vide. Afficher la solution interm\u00e9diaire 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from os.path import join , isfile , isdir dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge une couche shapefile dans une th\u00e9matique.\"\"\" racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) else : fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) else : layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) else : QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) thematique = 'H_OSM_ADMINISTRATIF' couche = 'COMMUNE' charger_couche ( thematique , couche ) Am\u00e9liorons encore cette solution interm\u00e9diaire avec la gestion des erreurs et aussi en gardant le code le plus \u00e0 gauche possible gr\u00e2ce \u00e0 l'instruction return qui ordonne la sortie de la fonction. Afficher une des solutions finales 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from os.path import join , isfile , isdir def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge une couche shapefile dans une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) return False layer = QgsVectorLayer ( fichier_shape , shapefile , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) return False QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) return layer charger_couche ( 'H_OSM_ADMINISTRATIF' , 'COMMUNE' ) charger_couche ( 'H_OSM_ADMINISTRATIF' , 'ARRONDISSEMENT' ) Essayons de faire une fonction qui liste les shapefiles d'une certaine th\u00e9matique. On peut utiliser la m\u00e9thode os.walk(path) permet de parcourir un chemin et de lister les r\u00e9pertoires et les fichiers. Ou alors on peut utiliser une autre m\u00e9thode, un peu plus \u00e0 la mode en utilisant le mode pathlib qui comporte \u00e9galement les fonctions isfile , isdir etc. En utilisant le module os.walk , un peu historique : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import os def liste_shapefiles ( thematique ): \"\"\"Liste les shapefiles d'une th\u00e9matique.\"\"\" dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154' racine = QgsProject . instance () . homePath () shapes = [] for root , directories , files in os . walk ( os . path . join ( racine , dossier , thematique )): for file in files : if file . lower () . endswith ( '.shp' ): shapes . append ( file . replace ( '.shp' , '' )) return shapes shapes = liste_shapefiles ( 'H_OSM_ADMINISTRATIF' ) print ( shapes ) En utilisant le \"nouveau\" module pathlib : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pathlib import Path def liste_shapefiles ( thematique ): \"\"\"Liste les shapefiles d'une th\u00e9matique.\"\"\" racine = QgsProject . instance () . homePath () dossier = Path ( racine ) . joinpath ( '202103_OSM2IGEO_91_LANGUEDOC_ROUSSILLON_SHP_L93_2154' , thematique ) shapes = [] for file in dossier . iterdir (): if file . suffix . lower () == '.shp' : shapes . append ( file . stem ) return shapes shapes = liste_shapefiles ( 'H_OSM_ADMINISTRATIF' ) print ( shapes ) Tip Il faut se r\u00e9f\u00e9rer \u00e0 la documentation du module pathlib pour comprendre le fonctionnement de cette classe. Permettre le chargement automatique de toute une th\u00e9matique. Afficher la solution compl\u00e8te 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import os from os.path import join , isfile , isdir dossier = '202103_OSM2IGEO_91_LANGUEDOC_ROUSSILLON_SHP_L93_2154' # couche = 'COMMUNE' def liste_shapesfiles ( thematique ): \"\"\"Liste les shapes d'une th\u00e9matique\"\"\" racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False shapes = [] for root , directories , files in os . walk ( os . path . join ( racine , dossier , thematique )): # print(files) for file in files : # print(file) if file . lower () . endswith ( '.shp' ): # print(file) shapes . append ( file . replace ( \".shp\" , \"\" )) return shapes def charger_couche ( thematique , couche ): \"\"\"Fonction qui charge des couches suivant une th\u00e9matique.\"\"\" racine = QgsProject . instance () . homePath () if not racine : iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le projet n \\' est pas enregistr\u00e9' , Qgis . Critical ) return False fichier_shape = join ( racine , dossier , thematique , ' {} .shp' . format ( couche )) if not isfile ( fichier_shape ): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'Le chemin n \\' existe pas: \" {} \"' . format ( fichier_shape ), Qgis . Critical ) return False layer = QgsVectorLayer ( fichier_shape , couche , 'ogr' ) if not layer . isValid (): iface . messageBar () . pushMessage ( 'Erreur de chargement' , 'La couche n \\' est pas valide' , Qgis . Critical ) return False QgsProject . instance () . addMapLayer ( layer ) iface . messageBar () . pushMessage ( 'Bravo' , 'Well done!' , Qgis . Success ) return layer thematique = 'H_OSM_ADMINISTRATIF' shapes = liste_shapesfiles ( thematique ) for shape in shapes : charger_couche ( thematique , shape )","title":"Charger automatiquement plusieurs couches \u00e0 l'aide d'un script"},{"location":"fonctions-scripts/#extraction-des-informations-sous-forme-dun-fichier-csv","text":"On souhaite d\u00e9sormais r\u00e9aliser une fonction d'export des m\u00e9tadonn\u00e9es de nos couches au format CSV, avec son CSVT. Il existe d\u00e9j\u00e0 un module CSV dans Python pour nous aider \u00e0 \u00e9crire un fichier de type CSV, mais nous n'allons pas l'utiliser. Nous allons plut\u00f4t utiliser l'API QGIS pour cr\u00e9er une nouvelle couche en m\u00e9moire comportant les diff\u00e9rentes informations que l'on souhaite exporter. Puis nous allons utiliser l'API pour exporter cette couche m\u00e9moire au format CSV (l'\u00e9quivalent dans QGIS de l'action Exporter la couche ). Les diff\u00e9rents champs qui devront \u00eatre export\u00e9s sont : son nom son type de g\u00e9om\u00e9trie (format humain, lisible) la projection le nombre d'entit\u00e9 l'encodage si le seuil de visibilit\u00e9 est activ\u00e9 la source (le chemin) de la donn\u00e9e","title":"Extraction des informations sous forme d'un fichier CSV."},{"location":"fonctions-scripts/#exemple-de-sortie","text":"nom type projection nombre_entite encodage source seuil_de_visibilite couche_1 Line EPSG:4326 5 UTF-8 /tmp/...geojson False couche_2 Tab No geometry 0 /tmp/...shp True","title":"Exemple de sortie"},{"location":"fonctions-scripts/#petit-memo","text":"Pour cr\u00e9er une couche tabulaire en m\u00e9moire : 1 layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) La liste des couches : 1 layers = QgsProject . instance () . mapLayers () Pour utiliser une session d'\u00e9dition, on peut faire : 1 2 3 layer . startEditing () # D\u00e9but de la session layer . commitChanges () # Fin de la session en enregistrant layer . rollback () # Fin de la session en annulant les modifications On peut \u00e9galement faire une session d'\u00e9dition avec un \"contexte\": 1 2 3 4 5 6 7 from qgis.core import edit with edit ( layer ): # Faire une \u00e9dition sur la couche pass # \u00c0 la fin du bloc d'indentation, la session d'\u00e9dition est automatiquement close. Nous allons avoir besoin de plusieurs classes dans l'API QGIS : Enregistrer un fichier : la classe QgsVectorFileWriter Un champ : QgsField , attention \u00e0 ne pas confondre avec QgsFields qui lui repr\u00e9sente un ensemble de champs. Une entit\u00e9 : QgsFeature Pour le type de champ, on va avoir besoin de l'API Qt \u00e9galement : https://doc.qt.io/qt-5/qmetatype.html#Type-enum Remplacer QMetaType par QVariant Par exemple, pour cr\u00e9er un nouveau champ de type entier : QgsField('nombre_entit\u00e9', QVariant.Int) Il va y avoir plusieurs \u00e9tapes dans ce script : R\u00e9cup\u00e9rer la liste des couches pr\u00e9sentes dans la l\u00e9gende Cr\u00e9er une couche en m\u00e9moire Ajouter des champs \u00e0 cette couche en utilisant une session d'\u00e9dition It\u00e9rer sur les couches pour ajouter ligne par ligne les m\u00e9tadonn\u00e9es dans une session d'\u00e9dition Enregistrer en CSV la couche m\u00e9moire Tip Pour d\u00e9boguer, on peut afficher la couche m\u00e9moire en question avec QgsProject.instance().addMapLayer()","title":"Petit m\u00e9mo"},{"location":"fonctions-scripts/#solution","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from os.path import join layers = QgsProject . instance () . mapLayers () if not layers : iface . messageBar () . pushMessage ( 'Pas de couche' , 'Attention, il n \\' a pas de couche' , Qgis . Warning ) layers = [ layer for layer in layers . values ()] layer_info = QgsVectorLayer ( 'None' , 'info' , 'memory' ) fields = [] fields . append ( QgsField ( 'nom' , QVariant . String )) fields . append ( QgsField ( 'type' , QVariant . String )) fields . append ( QgsField ( 'projection' , QVariant . String )) fields . append ( QgsField ( 'nombre_entite' , QVariant . Int )) fields . append ( QgsField ( 'encodage' , QVariant . String )) fields . append ( QgsField ( 'source' , QVariant . String )) fields . append ( QgsField ( 'seuil_de_visibilite' , QVariant . String )) with edit ( layer_info ): for field in fields : layer_info . addAttribute ( field ) QgsProject . instance () . addMapLayer ( layer_info ) with edit ( layer_info ): for layer in layers : feature = QgsFeature ( layer_info . fields ()) feature . setAttribute ( \"nom\" , layer . name ()) feature . setAttribute ( \"projection\" , layer . crs () . authid ()) feature . setAttribute ( \"nombre_entite\" , layer . featureCount ()) feature . setAttribute ( \"source\" , layer . source ()) feature . setAttribute ( \"type\" , QgsWkbTypes . geometryDisplayString ( layer . geometryType ())) feature . setAttribute ( \"seuil_visibilite\" , layer . hasScaleBasedVisibility ()) layer_info . addFeature ( feature ) QgsVectorFileWriter . writeAsVectorFormat ( layer_info , join ( QgsProject . instance () . homePath (), 'test.csv' ), 'utf-8' , QgsCoordinateReferenceSystem (), 'CSV' , layerOptions = [ 'CREATE_CSVT=YES' ] ) # Afficher une messageBar pour confirmer que c'est OK, en vert ;-)","title":"Solution"},{"location":"formulaire/","text":"Formulaire # Warning Pensez \u00e0 autoriser les macros dans les Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros On peut personnaliser un formulaire avec : un fichier QtDesigner, m\u00eame si on recommande l'utilisation du mode Drag&Drop qui permet de cr\u00e9er des onglets et des cat\u00e9gories. un fichier Python afin de modifier le comportement du formulaire, ajouter des boutons, modifier la CSS etc Tip Le blog de Nathan est une bonne ressource concernant les formulaires et QtDesigner pour cette partie la, mais cela commence \u00e0 \u00eatre vieux. Sur la couche Geopackage , dans les propri\u00e9t\u00e9s de la couche \u27a1 Formulaire d'attributs, cliquer sur le petit logo Python en haut bleu et jaune. Choisir l'option Fournir le code dans cette bo\u00eete de dialogue . Dans le nom de la fonction , mettre my_form_open qui correspond \u00e0 l'exemple du code en dessous. La fonction my_form_open sera donc ex\u00e9cut\u00e9 par d\u00e9faut lors de l'ouverture du formulaire. On remarque qu'il y a trois param\u00e8tres qui sont donn\u00e9s : dialog \u27a1 QgsAttributeForm qui h\u00e9rite de QWidget layer \u27a1 QgsVectorLayer feature \u27a1 QgsFeature Dans l'objet dialog : essayons de rechercher les boutons en bas OK et Annuler ajoutons le bouton Aide pour ouvrir une page internet d'aide Pour information : QWidget::findChild(CLASSE) retourne un objet de la CLASSE sp\u00e9cifi\u00e9 dans le widget courant La barre des boutons est une QDialogButtonBox Pour ouvrir une URL : QDesktopServices Afficher 1 2 3 4 5 6 7 8 9 10 11 12 from qgis.PyQt.QtCore import QUrl from qgis.PyQt.QtWidgets import QWidget , QDialogButtonBox from qgis.PyQt.QtGui import QDesktopServices def my_form_open ( dialog , layer , feature ): button_box = dialog . findChild ( QDialogButtonBox ) button_box . setStandardButtons ( QDialogButtonBox . Cancel | QDialogButtonBox . Help | QDialogButtonBox . Ok ) button_box . button ( QDialogButtonBox . Help ) . clicked . connect ( open_help ) def open_help (): QDesktopServices . openUrl ( QUrl ( 'https://docs.3liz.org/' )) Appliquons une CSS sur le champ type pour mettre un fond rouge : 1 2 type_field = dialog . findChild ( QLineEdit , \"type\" ) type_field . setStyleSheet ( \"background-color: rgba(255, 107, 107, 150);\" ) Cherchons le champ surface et calculons la surface avec la g\u00e9om\u00e9trie.","title":"Formulaire"},{"location":"formulaire/#formulaire","text":"Warning Pensez \u00e0 autoriser les macros dans les Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros On peut personnaliser un formulaire avec : un fichier QtDesigner, m\u00eame si on recommande l'utilisation du mode Drag&Drop qui permet de cr\u00e9er des onglets et des cat\u00e9gories. un fichier Python afin de modifier le comportement du formulaire, ajouter des boutons, modifier la CSS etc Tip Le blog de Nathan est une bonne ressource concernant les formulaires et QtDesigner pour cette partie la, mais cela commence \u00e0 \u00eatre vieux. Sur la couche Geopackage , dans les propri\u00e9t\u00e9s de la couche \u27a1 Formulaire d'attributs, cliquer sur le petit logo Python en haut bleu et jaune. Choisir l'option Fournir le code dans cette bo\u00eete de dialogue . Dans le nom de la fonction , mettre my_form_open qui correspond \u00e0 l'exemple du code en dessous. La fonction my_form_open sera donc ex\u00e9cut\u00e9 par d\u00e9faut lors de l'ouverture du formulaire. On remarque qu'il y a trois param\u00e8tres qui sont donn\u00e9s : dialog \u27a1 QgsAttributeForm qui h\u00e9rite de QWidget layer \u27a1 QgsVectorLayer feature \u27a1 QgsFeature Dans l'objet dialog : essayons de rechercher les boutons en bas OK et Annuler ajoutons le bouton Aide pour ouvrir une page internet d'aide Pour information : QWidget::findChild(CLASSE) retourne un objet de la CLASSE sp\u00e9cifi\u00e9 dans le widget courant La barre des boutons est une QDialogButtonBox Pour ouvrir une URL : QDesktopServices Afficher 1 2 3 4 5 6 7 8 9 10 11 12 from qgis.PyQt.QtCore import QUrl from qgis.PyQt.QtWidgets import QWidget , QDialogButtonBox from qgis.PyQt.QtGui import QDesktopServices def my_form_open ( dialog , layer , feature ): button_box = dialog . findChild ( QDialogButtonBox ) button_box . setStandardButtons ( QDialogButtonBox . Cancel | QDialogButtonBox . Help | QDialogButtonBox . Ok ) button_box . button ( QDialogButtonBox . Help ) . clicked . connect ( open_help ) def open_help (): QDesktopServices . openUrl ( QUrl ( 'https://docs.3liz.org/' )) Appliquons une CSS sur le champ type pour mettre un fond rouge : 1 2 type_field = dialog . findChild ( QLineEdit , \"type\" ) type_field . setStyleSheet ( \"background-color: rgba(255, 107, 107, 150);\" ) Cherchons le champ surface et calculons la surface avec la g\u00e9om\u00e9trie.","title":"Formulaire"},{"location":"ide-git/","text":"Python avanc\u00e9 # Utilisation d'un IDE # Pour \u00e9crire du code Python, on peut utiliser n'importe quel \u00e9diteur de texte brut quelque soit l'OS. Cependant, l'utilisation d'un \u00e9diteur de texte qui \"comprend\" le code Python est vivement recommand\u00e9 car il peut vous signaler quelques erreurs facilement d\u00e9tectables, tel que les imports manquants. Comme \u00e9diteur de texte, il en existe plusieurs. Si vous souhaitez faire plus de programmation, nous vous recommandons l'utilisation d'un IDE. Il embarque l'\u00e9diteur de texte ci-dessus mais poss\u00e8de aussi des outils de debugs et d'assistance dans l'\u00e9criture du code comme l'autocompl\u00e9tion. En IDE gratuit, il existe : Visual Studio en ajoutant les extensions Python PyCharm Community , d\u00e9di\u00e9 au language Python Un IDE est outil tr\u00e8s complet pour d\u00e9veloppement. Il est possible de coder en Python avec un \u00e9diteur de texte, mais si possible qui sait quand m\u00eame faire de la coloration syntaxique du code Python est vraiment un plus ( NotePad++ \u2026). Lancer un script Python dans la console # Si vous utilisez un IDE pour \u00e9crire du code Python, vous pouvez lancer le code Python dans la console Python \u00e0 l'aide de cette astuce. Ouvrir l'\u00e9diteur de script Python (pas juste la console) Tapez print(\"bonjour\") dans le panneau de droite Lancer le script avec la fl\u00e8che verte Copier/coller la ligne qui permet de lancer le script et modifier le chemin pour pointer vers le fichier sur votre disque. Elle ressemble \u00e0 exec(open('/chemin/vers/fichier.py'.encode('utf-8')).read()) . Utilisation de GIT # Il est vivement recommand\u00e9 d'utiliser GIT : sauvegarde de son code sur un serveur versionner son code et suivre les modifications simplifier le travail d'\u00e9quipe La documentation : https://git-scm.com/docs/ Les commandes les plus utiles : git commit : https://git-scm.com/docs/git-commit/fr git add : https://git-scm.com/docs/git-add/fr git push : https://git-scm.com/docs/git-push/fr git pull : https://git-scm.com/docs/git-pull/fr Liens vers OpenClassRooms : https://openclassrooms.com/fr/courses/1233741-gerez-vos-codes-source-avec-git https://openclassrooms.com/fr/courses/5641721-utilisez-git-et-github-pour-vos-projets-de-developpement","title":"IDE & Git"},{"location":"ide-git/#python-avance","text":"","title":"Python avanc\u00e9"},{"location":"ide-git/#utilisation-dun-ide","text":"Pour \u00e9crire du code Python, on peut utiliser n'importe quel \u00e9diteur de texte brut quelque soit l'OS. Cependant, l'utilisation d'un \u00e9diteur de texte qui \"comprend\" le code Python est vivement recommand\u00e9 car il peut vous signaler quelques erreurs facilement d\u00e9tectables, tel que les imports manquants. Comme \u00e9diteur de texte, il en existe plusieurs. Si vous souhaitez faire plus de programmation, nous vous recommandons l'utilisation d'un IDE. Il embarque l'\u00e9diteur de texte ci-dessus mais poss\u00e8de aussi des outils de debugs et d'assistance dans l'\u00e9criture du code comme l'autocompl\u00e9tion. En IDE gratuit, il existe : Visual Studio en ajoutant les extensions Python PyCharm Community , d\u00e9di\u00e9 au language Python Un IDE est outil tr\u00e8s complet pour d\u00e9veloppement. Il est possible de coder en Python avec un \u00e9diteur de texte, mais si possible qui sait quand m\u00eame faire de la coloration syntaxique du code Python est vraiment un plus ( NotePad++ \u2026).","title":"Utilisation d'un IDE"},{"location":"ide-git/#lancer-un-script-python-dans-la-console","text":"Si vous utilisez un IDE pour \u00e9crire du code Python, vous pouvez lancer le code Python dans la console Python \u00e0 l'aide de cette astuce. Ouvrir l'\u00e9diteur de script Python (pas juste la console) Tapez print(\"bonjour\") dans le panneau de droite Lancer le script avec la fl\u00e8che verte Copier/coller la ligne qui permet de lancer le script et modifier le chemin pour pointer vers le fichier sur votre disque. Elle ressemble \u00e0 exec(open('/chemin/vers/fichier.py'.encode('utf-8')).read()) .","title":"Lancer un script Python dans la console"},{"location":"ide-git/#utilisation-de-git","text":"Il est vivement recommand\u00e9 d'utiliser GIT : sauvegarde de son code sur un serveur versionner son code et suivre les modifications simplifier le travail d'\u00e9quipe La documentation : https://git-scm.com/docs/ Les commandes les plus utiles : git commit : https://git-scm.com/docs/git-commit/fr git add : https://git-scm.com/docs/git-add/fr git push : https://git-scm.com/docs/git-push/fr git pull : https://git-scm.com/docs/git-pull/fr Liens vers OpenClassRooms : https://openclassrooms.com/fr/courses/1233741-gerez-vos-codes-source-avec-git https://openclassrooms.com/fr/courses/5641721-utilisez-git-et-github-pour-vos-projets-de-developpement","title":"Utilisation de GIT"},{"location":"memo-python/","text":"Introduction au language Python # Qu'est-ce que Python ? # Multi-usage (WEB, application graphique, script, serveur etc) Programmation Orient\u00e9e Objet (POO) Tout est objet Interpr\u00e9t\u00e9 Centr\u00e9 sur la lecture et la productivit\u00e9 Syntaxe du code simple Grosse communaut\u00e9 De nombreux packages disponibles sur internet https://pypi.org/ 1 2 3 4 5 6 7 8 # D\u00e9claration d'une variable de type entier x = 5 # D\u00e9claration d'une variable cha\u00eene de caract\u00e8re info = 'X est compris entre 0 et 10' if 0 < x < 10 : print ( info ) Versions # Python 2 Sortie en 2000 Il est encore tr\u00e8s utilis\u00e9, notamment sur les tutoriels sur internet et quelques projets qui tardent \u00e0 se mettre \u00e0 jour Une adoption massive (QGIS 2) Derni\u00e8re version le 1 janvier 2020 Python 3 Sortie en 2008, mais il s'agit d'une adoption tr\u00e8s lente, tellement Python 2 a \u00e9t\u00e9 massivement adopt\u00e9. Derni\u00e8re version 3.10.0 du 4 octobre 2021 1 version majeure par an, en octobre QGIS 3 requi\u00e8re : Python 3.5 minimum for QGIS 3.4 Python 3.6 minimum for QGIS 3.18 Python 3.7 minimum for QGIS 3.20 Rappel de base sur Python # Un m\u00e9mo Python plus important : https://www.w3schools.com/python/ Un cours Python : https://openclassrooms.com/fr/courses/4262331-demarrez-votre-projet-avec-python Les types de donn\u00e9es # Une variable peut contenir un entier, un bool\u00e9en ( True ou False ), cha\u00eene de caract\u00e8res, nombre d\u00e9cimal, un objet... Il y a un faible typage des variables, c'est-\u00e0-dire qu'une variable peut changer de type au cours de l'ex\u00e9cution du programme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 mon_compteur = 0 type ( mon_compteur ) < class ' int '> mon_compteur = False type ( mon_compteur ) < class ' bool '> mon_compteur = 'oui' type ( mon_compteur ) < class ' str '> mon_compteur = \"non\" type ( mon_compteur ) < class ' str '> mon_compteur = 3.5 type ( mon_compteur ) < class ' float '> mon_compteur = None type ( mon_compteur ) < class ' NoneType '> Les structures de donn\u00e9es # Il existe quatre types de structure de donn\u00e9es : les variables simples (ci-dessus) les tuples (non modifiables) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_vide = () liste = ( 1 , 2 , 3 , 'bonjour' ) type ( liste ) < class ' tuple '> len ( liste ) 4 liste [ 0 ] 1 liste [ 0 : 2 ] ( 1 , 2 ) liste [ 2 :] ( 3 , 'bonjour' ) liste [ 5 ] Traceback ( most recent call last ): File \"/usr/lib/python3.7/code.py\" , line 90 , in runcode exec ( code , self . locals ) File \"<input>\" , line 1 , in < module > IndexError : tuple index out of range * les listes (modifiables) 1 2 3 4 5 6 7 nombres = [] type ( nombres ) < class ' list '> nombres . append ( 1 ) nombres . extend ([ 2 , 3 , 4 ]) nombres [ 1 , 2 , 3 , 4 ] les dictionnaires Attention , les dictionnaires ne sont pas ordonn\u00e9s ! Si vraiment il y a besoin, il existe une classe OrderedDict , mais ce n'est pas une structure de donn\u00e9es native dans Python. C'est un objet. 1 2 3 4 5 6 7 personne = {} type ( personne ) # <class 'dict'> personne [ 'prenom' ] = 'etienne' personne [ 'nom' ] = 'trimaille' personne [ 'est_majeur' ] = True personne [ 'age' ] = 30 Les commentaires # Pour commenter le code dans un script, pas dans la console : 1 2 3 4 5 6 7 8 # Ceci est un commentaire sur une ligne /* Ceci est un commentaire sur plusieurs lignes */ \"\"\" Ces lignes sont r\u00e9serv\u00e9s pour la documentation de l'API et ne doivent pas \u00eatre des lignes de commentaires. \"\"\" Arithm\u00e9tique # 1 2 3 4 5 6 7 8 9 a = 10 a += 1 a -= 1 b = a + 1 c = a - 1 d = a * 2 e = a / 2 f = a % 3 # 1 g = a ** 2 # 100 Concat\u00e9ner des cha\u00eenes et des variables # Concat\u00e9ner, c'est assembler des assembler des cha\u00eenes de caract\u00e8res dans une seule et m\u00eame sortie. On peut concat\u00e9ner des variables entre elles ou du textes. Il existe plein de mani\u00e8res de faire, mais certaines sont plus pratiques que d'autres 1 2 3 4 5 6 7 # Non recommand\u00e9 a = 'bon' b = 'jour' a + b # 'bonjour' c = 1 a + c # Erreur a + str ( c ) # Marche \u00c0 l'ancienne avec % 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour %s !' % prenom bienvenue = 'Bonjour %s , nous sommes le %s novembre' % ( prenom , numero_jour ) Nouveau avec {} et format 1 2 3 4 5 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour {} !' . format ( prenom ) bienvenue = 'Bonjour {} , nous sommes le {} novembre' . format ( prenom , numero_jour ) bienvenue = 'Bonjour {prenom} , nous sommes le {jour} novembre' . format ( prenom = prenom , jour = numero_jour ) Encore plus moderne avec Python 3.6 et fstring 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = f 'Bonjour { prenom } !' bienvenue = f 'Bonjour { prenom } , nous sommes le { numero_jour } novembre' Op\u00e9rateurs logiques # 1 2 3 4 5 6 7 8 9 10 a > b a >= b a < b a <= b a == b a != b a is b a is not b a in b 0 < a < 10 Condition # Important , Python oblige l'indentation sinon il y a une erreur. Par convention, il s'agit de 4 espaces. 1 2 3 4 5 6 7 8 9 10 11 12 note = 13 if note >= 16 : if note == 20 : print ( 'Toutes mes f\u00e9licitations' ) else : print ( 'F\u00e9licitations' ) elif 14 <= note < 16 : print ( 'Tr\u00e8s bien' ) elif 12 <= note < 14 : print ( 'Bien' ) else : print ( 'Peu mieux faire' ) Boucle for # Utile lors que l'on connait le nombre de r\u00e9p\u00e9titions avant l'\u00e9x\u00e9cution de la boucle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 for x in range ( 10 ): print ( x ) countries = [ 'Allemagne' , 'Espagne' , 'France' ] for country in countries : print ( 'Pays : {} ' . format ( country )) regions = { 'Auvergne-Rh\u00f4ne-Alpes' : 'Lyon' , 'Bourgogne-Franche-Comt\u00e9' : 'Dijon' , 'Bretagne' : 'Rennes' , 'Centre-Val de Loire' : 'Orl\u00e9ans' , } for region in regions : print ( region ) for region in regions . keys (): print ( region ) for city in regions . values (): print ( city ) for region , city in regions . items (): print ( 'R\u00e9gion {} dont le chef lieu est {} ' . format ( region , city )) Recherche d'un \u00e9l\u00e9ment # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 countries = [ 'Allemagne' , 'Espagne' , 'France' ] # Solution simple if 'Allemagne' in countries : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Plus complexe, avec une fonction pour les minuscules present = False for country in countries : if country . lower () == 'allemagne' : present = True if present : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Le plus pythonique for country in countries : if country . lower () == 'allemagne' : print ( 'Pr\u00e9sent' ) break else : print ( 'Non pr\u00e9sent' ) # Encore plus pythonique avec une list-comprehension Boucle while # 1 2 3 4 x = 0 while x < 10 : print ( x ) x += 1 En Python, il n'y a pas de boucle do ... while , \u00e0 la place, on peut faire ainsi : 1 2 3 executer_une_fonction () while not conditon_echec : executer_une_fonction () Switch # Python 3.10 uniquement List Comprehensions # C'est une fa\u00e7on tr\u00e8s pythonique et tr\u00e8s utilis\u00e9e de cr\u00e9er des listes. Par exemple, cr\u00e9er une liste des nombres impaires entre 1 et 9 : 1 2 3 4 5 6 7 8 # Non pythonique impair = [] for x in range ( 10 ): if x % 2 : impair . append ( x ) # Pythonique impair = [ x for x in range ( 10 ) if x % 2 ] Autre exemple en transformant une liste : 1 2 countries = [ 'Allemagne' , 'Espagne' , 'France' ] countries = [ c . upper () for c in countries ] Il existe aussi les Dict Comprehensions (moins utilis\u00e9) Manipulation sur les cha\u00eenes de caract\u00e8res # Pour information, les cha\u00eenes de caract\u00e8res sont des listes et on peut faire du slicing sur des listes : 1 2 3 4 5 6 7 8 9 10 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' len ( alphabet ) ',' . join ( alphabet ) alphabet . lower () alphabet . upper () alphabet [ 1 ] # B alphabet [ 1 : 3 ] # BC alphabet [ - 1 ] # Z alphabet [ - 3 :] # XYZ alphabet [: 6 ] # ABCDEF Fonctions # Voici des exemples de fonction Python. Encore une fois , attention \u00e0 l'indentation ! 1 2 3 4 5 6 7 8 9 10 def ajouter ( x , y ): \"\"\"Ajouter deux nombres.\"\"\" return x + y def crier ( phrase = 'bonjour' ): print ( phrase . upper ()) def discuter ( texte , personnage = 'Charles' ): \"\"\"Un personnage discute.\"\"\" print ( ' {} : \" {} \"' . format ( personnage , texte )) Une fonction peut retourner plusieurs valeurs : 1 2 3 4 5 def decomposer ( entier , diviser_par ): \"\"\"Retourne la partie enti\u00e8re et le reste d'une division.\"\"\" partie_entiere = entier / diviser_par reste = entier % diviser_par return partie_entiere , reste Il se peut que l'on ne connaisse pas \u00e0 l'avance le nombre pr\u00e9cis d'arguments dans une fonction. args est utilis\u00e9 pour passer un nombre ind\u00e9termin\u00e9 d'argument \u00e0 la fonction kwargs est utilis\u00e9 pour un nombre ind\u00e9termin\u00e9 d'arguments nomm\u00e9s 1 2 3 4 5 6 7 8 9 def une_fonction ( * args , ** kwargs ): print ( 'Les arguments' ) for arg in args : print ( arg ) print ( 'Les arguments non nomm\u00e9s' ) for key , value in kwargs . items (): print ( ' {} -> {} ' . format ( key , value )) une_fonction ( 1 , 2 , 3 , text = 'Ma phrase' ) POO : Programmation Orient\u00e9e Objet # Pour cette partie-l\u00e0, il faut lire le chapitre suivant sur la console ou encore la partie sur l'\u00e9criture d'un script Processing . Exceptions # Lire le chapitre sur le parcours des entit\u00e9s . Truc et astuces # Warning Attention au passage par r\u00e9f\u00e9rence : 1 2 3 4 5 ma_liste_1 = [ 1 , 2 , 3 ] ma_liste_2 = ma_liste_1 ma_liste_2 . append ( 4 ) print ( ma_liste_2 ) print ( ma_liste_1 ) Avoir un compteur lors de l'it\u00e9ration d'une liste : 1 2 3 users = [ 'Tom' , 'James' , 'John' ] for i , user in enumerate ( users ): print ( ' {} -> {} ' . format ( i + 1 , user ))","title":"M\u00e9mo Python"},{"location":"memo-python/#introduction-au-language-python","text":"","title":"Introduction au language Python"},{"location":"memo-python/#quest-ce-que-python","text":"Multi-usage (WEB, application graphique, script, serveur etc) Programmation Orient\u00e9e Objet (POO) Tout est objet Interpr\u00e9t\u00e9 Centr\u00e9 sur la lecture et la productivit\u00e9 Syntaxe du code simple Grosse communaut\u00e9 De nombreux packages disponibles sur internet https://pypi.org/ 1 2 3 4 5 6 7 8 # D\u00e9claration d'une variable de type entier x = 5 # D\u00e9claration d'une variable cha\u00eene de caract\u00e8re info = 'X est compris entre 0 et 10' if 0 < x < 10 : print ( info )","title":"Qu'est-ce que Python ?"},{"location":"memo-python/#versions","text":"Python 2 Sortie en 2000 Il est encore tr\u00e8s utilis\u00e9, notamment sur les tutoriels sur internet et quelques projets qui tardent \u00e0 se mettre \u00e0 jour Une adoption massive (QGIS 2) Derni\u00e8re version le 1 janvier 2020 Python 3 Sortie en 2008, mais il s'agit d'une adoption tr\u00e8s lente, tellement Python 2 a \u00e9t\u00e9 massivement adopt\u00e9. Derni\u00e8re version 3.10.0 du 4 octobre 2021 1 version majeure par an, en octobre QGIS 3 requi\u00e8re : Python 3.5 minimum for QGIS 3.4 Python 3.6 minimum for QGIS 3.18 Python 3.7 minimum for QGIS 3.20","title":"Versions"},{"location":"memo-python/#rappel-de-base-sur-python","text":"Un m\u00e9mo Python plus important : https://www.w3schools.com/python/ Un cours Python : https://openclassrooms.com/fr/courses/4262331-demarrez-votre-projet-avec-python","title":"Rappel de base sur Python"},{"location":"memo-python/#les-types-de-donnees","text":"Une variable peut contenir un entier, un bool\u00e9en ( True ou False ), cha\u00eene de caract\u00e8res, nombre d\u00e9cimal, un objet... Il y a un faible typage des variables, c'est-\u00e0-dire qu'une variable peut changer de type au cours de l'ex\u00e9cution du programme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 mon_compteur = 0 type ( mon_compteur ) < class ' int '> mon_compteur = False type ( mon_compteur ) < class ' bool '> mon_compteur = 'oui' type ( mon_compteur ) < class ' str '> mon_compteur = \"non\" type ( mon_compteur ) < class ' str '> mon_compteur = 3.5 type ( mon_compteur ) < class ' float '> mon_compteur = None type ( mon_compteur ) < class ' NoneType '>","title":"Les types de donn\u00e9es"},{"location":"memo-python/#les-structures-de-donnees","text":"Il existe quatre types de structure de donn\u00e9es : les variables simples (ci-dessus) les tuples (non modifiables) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_vide = () liste = ( 1 , 2 , 3 , 'bonjour' ) type ( liste ) < class ' tuple '> len ( liste ) 4 liste [ 0 ] 1 liste [ 0 : 2 ] ( 1 , 2 ) liste [ 2 :] ( 3 , 'bonjour' ) liste [ 5 ] Traceback ( most recent call last ): File \"/usr/lib/python3.7/code.py\" , line 90 , in runcode exec ( code , self . locals ) File \"<input>\" , line 1 , in < module > IndexError : tuple index out of range * les listes (modifiables) 1 2 3 4 5 6 7 nombres = [] type ( nombres ) < class ' list '> nombres . append ( 1 ) nombres . extend ([ 2 , 3 , 4 ]) nombres [ 1 , 2 , 3 , 4 ] les dictionnaires Attention , les dictionnaires ne sont pas ordonn\u00e9s ! Si vraiment il y a besoin, il existe une classe OrderedDict , mais ce n'est pas une structure de donn\u00e9es native dans Python. C'est un objet. 1 2 3 4 5 6 7 personne = {} type ( personne ) # <class 'dict'> personne [ 'prenom' ] = 'etienne' personne [ 'nom' ] = 'trimaille' personne [ 'est_majeur' ] = True personne [ 'age' ] = 30","title":"Les structures de donn\u00e9es"},{"location":"memo-python/#les-commentaires","text":"Pour commenter le code dans un script, pas dans la console : 1 2 3 4 5 6 7 8 # Ceci est un commentaire sur une ligne /* Ceci est un commentaire sur plusieurs lignes */ \"\"\" Ces lignes sont r\u00e9serv\u00e9s pour la documentation de l'API et ne doivent pas \u00eatre des lignes de commentaires. \"\"\"","title":"Les commentaires"},{"location":"memo-python/#arithmetique","text":"1 2 3 4 5 6 7 8 9 a = 10 a += 1 a -= 1 b = a + 1 c = a - 1 d = a * 2 e = a / 2 f = a % 3 # 1 g = a ** 2 # 100","title":"Arithm\u00e9tique"},{"location":"memo-python/#concatener-des-chaines-et-des-variables","text":"Concat\u00e9ner, c'est assembler des assembler des cha\u00eenes de caract\u00e8res dans une seule et m\u00eame sortie. On peut concat\u00e9ner des variables entre elles ou du textes. Il existe plein de mani\u00e8res de faire, mais certaines sont plus pratiques que d'autres 1 2 3 4 5 6 7 # Non recommand\u00e9 a = 'bon' b = 'jour' a + b # 'bonjour' c = 1 a + c # Erreur a + str ( c ) # Marche \u00c0 l'ancienne avec % 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour %s !' % prenom bienvenue = 'Bonjour %s , nous sommes le %s novembre' % ( prenom , numero_jour ) Nouveau avec {} et format 1 2 3 4 5 prenom = 'Pierre' numero_jour = 2 bienvenue = 'Bonjour {} !' . format ( prenom ) bienvenue = 'Bonjour {} , nous sommes le {} novembre' . format ( prenom , numero_jour ) bienvenue = 'Bonjour {prenom} , nous sommes le {jour} novembre' . format ( prenom = prenom , jour = numero_jour ) Encore plus moderne avec Python 3.6 et fstring 1 2 3 4 prenom = 'Pierre' numero_jour = 2 bienvenue = f 'Bonjour { prenom } !' bienvenue = f 'Bonjour { prenom } , nous sommes le { numero_jour } novembre'","title":"Concat\u00e9ner des cha\u00eenes et des variables"},{"location":"memo-python/#operateurs-logiques","text":"1 2 3 4 5 6 7 8 9 10 a > b a >= b a < b a <= b a == b a != b a is b a is not b a in b 0 < a < 10","title":"Op\u00e9rateurs logiques"},{"location":"memo-python/#condition","text":"Important , Python oblige l'indentation sinon il y a une erreur. Par convention, il s'agit de 4 espaces. 1 2 3 4 5 6 7 8 9 10 11 12 note = 13 if note >= 16 : if note == 20 : print ( 'Toutes mes f\u00e9licitations' ) else : print ( 'F\u00e9licitations' ) elif 14 <= note < 16 : print ( 'Tr\u00e8s bien' ) elif 12 <= note < 14 : print ( 'Bien' ) else : print ( 'Peu mieux faire' )","title":"Condition"},{"location":"memo-python/#boucle-for","text":"Utile lors que l'on connait le nombre de r\u00e9p\u00e9titions avant l'\u00e9x\u00e9cution de la boucle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 for x in range ( 10 ): print ( x ) countries = [ 'Allemagne' , 'Espagne' , 'France' ] for country in countries : print ( 'Pays : {} ' . format ( country )) regions = { 'Auvergne-Rh\u00f4ne-Alpes' : 'Lyon' , 'Bourgogne-Franche-Comt\u00e9' : 'Dijon' , 'Bretagne' : 'Rennes' , 'Centre-Val de Loire' : 'Orl\u00e9ans' , } for region in regions : print ( region ) for region in regions . keys (): print ( region ) for city in regions . values (): print ( city ) for region , city in regions . items (): print ( 'R\u00e9gion {} dont le chef lieu est {} ' . format ( region , city ))","title":"Boucle for"},{"location":"memo-python/#recherche-dun-element","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 countries = [ 'Allemagne' , 'Espagne' , 'France' ] # Solution simple if 'Allemagne' in countries : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Plus complexe, avec une fonction pour les minuscules present = False for country in countries : if country . lower () == 'allemagne' : present = True if present : print ( 'Pr\u00e9sent' ) else : print ( 'Non pr\u00e9sent' ) # Le plus pythonique for country in countries : if country . lower () == 'allemagne' : print ( 'Pr\u00e9sent' ) break else : print ( 'Non pr\u00e9sent' ) # Encore plus pythonique avec une list-comprehension","title":"Recherche d'un \u00e9l\u00e9ment"},{"location":"memo-python/#boucle-while","text":"1 2 3 4 x = 0 while x < 10 : print ( x ) x += 1 En Python, il n'y a pas de boucle do ... while , \u00e0 la place, on peut faire ainsi : 1 2 3 executer_une_fonction () while not conditon_echec : executer_une_fonction ()","title":"Boucle while"},{"location":"memo-python/#switch","text":"Python 3.10 uniquement","title":"Switch"},{"location":"memo-python/#list-comprehensions","text":"C'est une fa\u00e7on tr\u00e8s pythonique et tr\u00e8s utilis\u00e9e de cr\u00e9er des listes. Par exemple, cr\u00e9er une liste des nombres impaires entre 1 et 9 : 1 2 3 4 5 6 7 8 # Non pythonique impair = [] for x in range ( 10 ): if x % 2 : impair . append ( x ) # Pythonique impair = [ x for x in range ( 10 ) if x % 2 ] Autre exemple en transformant une liste : 1 2 countries = [ 'Allemagne' , 'Espagne' , 'France' ] countries = [ c . upper () for c in countries ] Il existe aussi les Dict Comprehensions (moins utilis\u00e9)","title":"List Comprehensions"},{"location":"memo-python/#manipulation-sur-les-chaines-de-caracteres","text":"Pour information, les cha\u00eenes de caract\u00e8res sont des listes et on peut faire du slicing sur des listes : 1 2 3 4 5 6 7 8 9 10 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' len ( alphabet ) ',' . join ( alphabet ) alphabet . lower () alphabet . upper () alphabet [ 1 ] # B alphabet [ 1 : 3 ] # BC alphabet [ - 1 ] # Z alphabet [ - 3 :] # XYZ alphabet [: 6 ] # ABCDEF","title":"Manipulation sur les cha\u00eenes de caract\u00e8res"},{"location":"memo-python/#fonctions","text":"Voici des exemples de fonction Python. Encore une fois , attention \u00e0 l'indentation ! 1 2 3 4 5 6 7 8 9 10 def ajouter ( x , y ): \"\"\"Ajouter deux nombres.\"\"\" return x + y def crier ( phrase = 'bonjour' ): print ( phrase . upper ()) def discuter ( texte , personnage = 'Charles' ): \"\"\"Un personnage discute.\"\"\" print ( ' {} : \" {} \"' . format ( personnage , texte )) Une fonction peut retourner plusieurs valeurs : 1 2 3 4 5 def decomposer ( entier , diviser_par ): \"\"\"Retourne la partie enti\u00e8re et le reste d'une division.\"\"\" partie_entiere = entier / diviser_par reste = entier % diviser_par return partie_entiere , reste Il se peut que l'on ne connaisse pas \u00e0 l'avance le nombre pr\u00e9cis d'arguments dans une fonction. args est utilis\u00e9 pour passer un nombre ind\u00e9termin\u00e9 d'argument \u00e0 la fonction kwargs est utilis\u00e9 pour un nombre ind\u00e9termin\u00e9 d'arguments nomm\u00e9s 1 2 3 4 5 6 7 8 9 def une_fonction ( * args , ** kwargs ): print ( 'Les arguments' ) for arg in args : print ( arg ) print ( 'Les arguments non nomm\u00e9s' ) for key , value in kwargs . items (): print ( ' {} -> {} ' . format ( key , value )) une_fonction ( 1 , 2 , 3 , text = 'Ma phrase' )","title":"Fonctions"},{"location":"memo-python/#poo-programmation-orientee-objet","text":"Pour cette partie-l\u00e0, il faut lire le chapitre suivant sur la console ou encore la partie sur l'\u00e9criture d'un script Processing .","title":"POO : Programmation Orient\u00e9e Objet"},{"location":"memo-python/#exceptions","text":"Lire le chapitre sur le parcours des entit\u00e9s .","title":"Exceptions"},{"location":"memo-python/#truc-et-astuces","text":"Warning Attention au passage par r\u00e9f\u00e9rence : 1 2 3 4 5 ma_liste_1 = [ 1 , 2 , 3 ] ma_liste_2 = ma_liste_1 ma_liste_2 . append ( 4 ) print ( ma_liste_2 ) print ( ma_liste_1 ) Avoir un compteur lors de l'it\u00e9ration d'une liste : 1 2 3 users = [ 'Tom' , 'James' , 'John' ] for i , user in enumerate ( users ): print ( ' {} -> {} ' . format ( i + 1 , user ))","title":"Truc et astuces"},{"location":"python-qgis/","text":"Le python dans QGIS # QGIS permet d'utiliser du Python dans divers emplacement que nous allons voir ci-dessous. Python poss\u00e8de de tr\u00e8s nombreux packages/modules disponibles sur internet qui fournissent des fonctions d\u00e9j\u00e0 \u00e9crites. Console # La console est accessible par le menu Extension -> Console Python . Elle permet l'\u00e9criture de commande simple, une par une. On ne peut pas enregistrer les commandes dans un fichier. Script Python # L'\u00e9diteur de script Python est accessible depuis l'ic\u00f4ne d\u00e9di\u00e9e dans la console Python. Il permet un prototypage rapide d'un script. On peut y \u00e9crire du code plus complexe en faisant intervenir des librairies ou des classes. Script Processing # Le menu Traitement dans QGIS donne acc\u00e8s a plusieurs algorithmes d'analyse. Ces algorithms proviennent soient de QGIS, GDAL ou encore de plugins. La bo\u00eete \u00e0 outils de traitements ainsi que le modeleur graphique utilisent le \"framework\" Processing propre \u00e0 QGIS. Ce framework permet de d\u00e9finir les entr\u00e9es et les sorties d'un algorithme. Les algorithms sont donc normalis\u00e9s en suivant tous le m\u00eame mod\u00e8le. Processing impose la fa\u00e7on d'\u00e9crire les scripts. \u00c9crire un script compatible QGIS Processing permet l'int\u00e9gration dans ce menu, permet \u00e9galement l'utilisation de ce-dernier dans un mod\u00e8le ou encore l'utilisation en mode traitement par lot. Le framework peut aussi g\u00e9n\u00e9rer automatiquement l'interface graphique de l'algorithme et le code est optimis\u00e9. Il existe un mod\u00e8le par d\u00e9faut que l'on peut utiliser pour d\u00e9marrer l'\u00e9criture d'un script Processing. Depuis la barre d'outils traitements, Cr\u00e9er un nouveau script depuis un mod\u00e8le. Ce mod\u00e8le utilise la syntaxe Programmation Orient\u00e9e Objet. Depuis QGIS 3.6, on peut \u00e9galement utiliser la syntaxe par d\u00e9corateur @alg . Voir la documentation https://docs.qgis.org/testing/en/docs/user_manual/processing/scripts.html#the-alg-decorator Un mod\u00e8le Processing en Python # Depuis QGIS 3.6, on peut d\u00e9sormais exporter un mod\u00e8le de traitement Processing en Python. Il faut faire un clic droit sur un mod\u00e8le dans la bo\u00eete \u00e0 outils puis choisir \"Exporter le mod\u00e8le comme un algorithme Python\". On peut donc modifier ensuite ce fichier Python afin de rajouter de la logique suppl\u00e9mentaire. Extension (plugin) # Extension c\u00f4t\u00e9 bureautique et m\u00eame c\u00f4t\u00e9 QGIS Serveur. La plupart des plugins sont disponibles sur https://plugins.qgis.org pour le t\u00e9l\u00e9chargement, ou sinon ils peuvent \u00eatre install\u00e9s par un dossier ZIP. Afin de d\u00e9velopper une extension : Utilisation du Plugin Builder ou squelette minimum : https://github.com/wonder-sk/qgis-minimal-plugin Plugin Reloader permet de simplifier le d\u00e9veloppement en \u00e9vitant de recharger QGIS Documentation plugin QGIS Serveur : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/server.html Fournisseur Processing dans une extension (Processing Provider) # Similaire au script Processing, une extension QGIS peut aussi avoir son propre fournisseur d'algorithme. On peut remarquer les plugins DataPlotly , QuickOSM etc. Ajout de Processing \u00e0 un plugin QGIS : soit lors du plugin builder ou manuellement en suivant la documentation pour l'ajout \u00e0 un plugin existant : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/processing.html Il se peut que certaines extensions ne soient que des fournisseurs Processing. Expressions # Les expressions sont souvent pr\u00e9sentes dans QGIS. On peut les utiliser dans nombreux endroits, pour faire des s\u00e9lections, des conditions, etc. On peut \u00e9galement les utiliser \u00e0 chaque fois que vous pouvez voir ce symbole : Un plugin, ou m\u00eame simplement un utilisateur, peut enregistrer ses propres expressions. Ci-dessous, le plugin InaSAFE : Exemple de code d'une expression : 1 2 3 4 5 6 7 8 9 10 11 @qgsfunction ( args = 'auto' , group = 'Custom' ) def my_sum ( value1 , value2 , feature , parent ): \"\"\" Calculates the sum of the two parameters value1 and value2. <h2>Example usage:</h2> <ul> <li>my_sum(5, 8) -> 13</li> <li>my_sum(\"field1\", \"field2\") -> 42</li> </ul> \"\"\" return value1 + value2 Macros # Warning Pensez \u00e0 autoriser les macros dans les Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros Accessible depuis les propri\u00e9t\u00e9s du projet, dans l'onglet Macros . On peut lancer du code Python automatiquement soit : \u00e0 l'ouverture du projet lors de l'enregistrement du projet ou lors de sa fermeture Formulaire # Warning Pensez \u00e0 autoriser les macros dans les Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros On peut personnaliser un formulaire par l'ajout de logique Python. Cependant, dans QGIS 3, l'utilisation de Python n'est plus forc\u00e9ment n\u00e9cessaire, on peut d\u00e9sormais utiliser des expressions (recommand\u00e9) . Actions # Les actions sont des petits traitements que l'on peut lancer soit depuis la table attributaire ou depuis le canevas. Par exemple, on peut ouvrir un lien WEB ou un PDF en fonction d'un attribut d'une entit\u00e9. Il est possible d'\u00e9crire les actions en Python. Pour la cr\u00e9ation : Pour l'utilisation c\u00f4t\u00e9 utilisateur : Application/script ind\u00e9pendant # Sans lancer QGIS graphiquement, on peut utiliser la librairie QGIS dans nos scripts Python. On peut donc cr\u00e9er notre propre application graphique ou notre propre ex\u00e9cutable et ainsi utiliser les fonctions de QGIS. On peut donc faire un programme en ligne de commande qui effectue une certaine op\u00e9ration dans un r\u00e9pertoire donn\u00e9. Depuis QGIS 3.16 , nous pouvons lancer un mod\u00e8le ou un script Processing depuis la ligne de commande depuis l'outil qgis_process . Le fichier \"startup.py\" # Si l'on place un fichier nomm\u00e9 startup.py dans le dossier Python du profil de l'utilisateur, QGIS va le lancer automatiquement \u00e0 chaque ouverture de QGIS.","title":"Python dans QGIS"},{"location":"python-qgis/#le-python-dans-qgis","text":"QGIS permet d'utiliser du Python dans divers emplacement que nous allons voir ci-dessous. Python poss\u00e8de de tr\u00e8s nombreux packages/modules disponibles sur internet qui fournissent des fonctions d\u00e9j\u00e0 \u00e9crites.","title":"Le python dans QGIS"},{"location":"python-qgis/#console","text":"La console est accessible par le menu Extension -> Console Python . Elle permet l'\u00e9criture de commande simple, une par une. On ne peut pas enregistrer les commandes dans un fichier.","title":"Console"},{"location":"python-qgis/#script-python","text":"L'\u00e9diteur de script Python est accessible depuis l'ic\u00f4ne d\u00e9di\u00e9e dans la console Python. Il permet un prototypage rapide d'un script. On peut y \u00e9crire du code plus complexe en faisant intervenir des librairies ou des classes.","title":"Script Python"},{"location":"python-qgis/#script-processing","text":"Le menu Traitement dans QGIS donne acc\u00e8s a plusieurs algorithmes d'analyse. Ces algorithms proviennent soient de QGIS, GDAL ou encore de plugins. La bo\u00eete \u00e0 outils de traitements ainsi que le modeleur graphique utilisent le \"framework\" Processing propre \u00e0 QGIS. Ce framework permet de d\u00e9finir les entr\u00e9es et les sorties d'un algorithme. Les algorithms sont donc normalis\u00e9s en suivant tous le m\u00eame mod\u00e8le. Processing impose la fa\u00e7on d'\u00e9crire les scripts. \u00c9crire un script compatible QGIS Processing permet l'int\u00e9gration dans ce menu, permet \u00e9galement l'utilisation de ce-dernier dans un mod\u00e8le ou encore l'utilisation en mode traitement par lot. Le framework peut aussi g\u00e9n\u00e9rer automatiquement l'interface graphique de l'algorithme et le code est optimis\u00e9. Il existe un mod\u00e8le par d\u00e9faut que l'on peut utiliser pour d\u00e9marrer l'\u00e9criture d'un script Processing. Depuis la barre d'outils traitements, Cr\u00e9er un nouveau script depuis un mod\u00e8le. Ce mod\u00e8le utilise la syntaxe Programmation Orient\u00e9e Objet. Depuis QGIS 3.6, on peut \u00e9galement utiliser la syntaxe par d\u00e9corateur @alg . Voir la documentation https://docs.qgis.org/testing/en/docs/user_manual/processing/scripts.html#the-alg-decorator","title":"Script Processing"},{"location":"python-qgis/#un-modele-processing-en-python","text":"Depuis QGIS 3.6, on peut d\u00e9sormais exporter un mod\u00e8le de traitement Processing en Python. Il faut faire un clic droit sur un mod\u00e8le dans la bo\u00eete \u00e0 outils puis choisir \"Exporter le mod\u00e8le comme un algorithme Python\". On peut donc modifier ensuite ce fichier Python afin de rajouter de la logique suppl\u00e9mentaire.","title":"Un mod\u00e8le Processing en Python"},{"location":"python-qgis/#extension-plugin","text":"Extension c\u00f4t\u00e9 bureautique et m\u00eame c\u00f4t\u00e9 QGIS Serveur. La plupart des plugins sont disponibles sur https://plugins.qgis.org pour le t\u00e9l\u00e9chargement, ou sinon ils peuvent \u00eatre install\u00e9s par un dossier ZIP. Afin de d\u00e9velopper une extension : Utilisation du Plugin Builder ou squelette minimum : https://github.com/wonder-sk/qgis-minimal-plugin Plugin Reloader permet de simplifier le d\u00e9veloppement en \u00e9vitant de recharger QGIS Documentation plugin QGIS Serveur : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/server.html","title":"Extension (plugin)"},{"location":"python-qgis/#fournisseur-processing-dans-une-extension-processing-provider","text":"Similaire au script Processing, une extension QGIS peut aussi avoir son propre fournisseur d'algorithme. On peut remarquer les plugins DataPlotly , QuickOSM etc. Ajout de Processing \u00e0 un plugin QGIS : soit lors du plugin builder ou manuellement en suivant la documentation pour l'ajout \u00e0 un plugin existant : https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/processing.html Il se peut que certaines extensions ne soient que des fournisseurs Processing.","title":"Fournisseur Processing dans une extension (Processing Provider)"},{"location":"python-qgis/#expressions","text":"Les expressions sont souvent pr\u00e9sentes dans QGIS. On peut les utiliser dans nombreux endroits, pour faire des s\u00e9lections, des conditions, etc. On peut \u00e9galement les utiliser \u00e0 chaque fois que vous pouvez voir ce symbole : Un plugin, ou m\u00eame simplement un utilisateur, peut enregistrer ses propres expressions. Ci-dessous, le plugin InaSAFE : Exemple de code d'une expression : 1 2 3 4 5 6 7 8 9 10 11 @qgsfunction ( args = 'auto' , group = 'Custom' ) def my_sum ( value1 , value2 , feature , parent ): \"\"\" Calculates the sum of the two parameters value1 and value2. <h2>Example usage:</h2> <ul> <li>my_sum(5, 8) -> 13</li> <li>my_sum(\"field1\", \"field2\") -> 42</li> </ul> \"\"\" return value1 + value2","title":"Expressions"},{"location":"python-qgis/#macros","text":"Warning Pensez \u00e0 autoriser les macros dans les Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros Accessible depuis les propri\u00e9t\u00e9s du projet, dans l'onglet Macros . On peut lancer du code Python automatiquement soit : \u00e0 l'ouverture du projet lors de l'enregistrement du projet ou lors de sa fermeture","title":"Macros"},{"location":"python-qgis/#formulaire","text":"Warning Pensez \u00e0 autoriser les macros dans les Propri\u00e9t\u00e9s de QGIS \u27a1 G\u00e9n\u00e9ral \u27a1 Fichiers du projet \u27a1 Activer les macros On peut personnaliser un formulaire par l'ajout de logique Python. Cependant, dans QGIS 3, l'utilisation de Python n'est plus forc\u00e9ment n\u00e9cessaire, on peut d\u00e9sormais utiliser des expressions (recommand\u00e9) .","title":"Formulaire"},{"location":"python-qgis/#actions","text":"Les actions sont des petits traitements que l'on peut lancer soit depuis la table attributaire ou depuis le canevas. Par exemple, on peut ouvrir un lien WEB ou un PDF en fonction d'un attribut d'une entit\u00e9. Il est possible d'\u00e9crire les actions en Python. Pour la cr\u00e9ation : Pour l'utilisation c\u00f4t\u00e9 utilisateur :","title":"Actions"},{"location":"python-qgis/#applicationscript-independant","text":"Sans lancer QGIS graphiquement, on peut utiliser la librairie QGIS dans nos scripts Python. On peut donc cr\u00e9er notre propre application graphique ou notre propre ex\u00e9cutable et ainsi utiliser les fonctions de QGIS. On peut donc faire un programme en ligne de commande qui effectue une certaine op\u00e9ration dans un r\u00e9pertoire donn\u00e9. Depuis QGIS 3.16 , nous pouvons lancer un mod\u00e8le ou un script Processing depuis la ligne de commande depuis l'outil qgis_process .","title":"Application/script ind\u00e9pendant"},{"location":"python-qgis/#le-fichier-startuppy","text":"Si l'on place un fichier nomm\u00e9 startup.py dans le dossier Python du profil de l'utilisateur, QGIS va le lancer automatiquement \u00e0 chaque ouverture de QGIS.","title":"Le fichier \"startup.py\""},{"location":"script-processing/","text":"Processing # Processing est un framework pour faire des algorithmes dans QGIS. Toute la boite \u00e0 outils Traitement dans QGIS sont des bas\u00e9s sur \"Processing\". Note , depuis QGIS 3.6, il existe d\u00e9sormais une autre syntaxe pour \u00e9crire script Processing \u00e0 l'aide des d\u00e9corateurs Python. Notion sur la POO en Python # Le framework Processing utilise le concept de la P rogrammation O rient\u00e9e O bjet. Il existe un tutoriel sur le site d'OpenClassRooms sur le sujet. Mais depuis le d\u00e9but de la formation, nous l'utilisons sans trop le savoir. Les objets Qgs* , comme QgsMapLayer utilisent le principe de la POO. Tip Vous pouvez relire le passage sur la POO en d\u00e9but de formation . Nous allons faire un \"tr\u00e8s\" petit exemple rapide. \u00c9crivons notre premier jeu vid\u00e9o en console ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from time import sleep MAX_ENERGIE = 20 class Personnage : def __init__ ( self , nom , energie = MAX_ENERGIE ): self . nom = nom self . energie = energie def marcher ( self ): cout = 5 if self . energie >= cout : print ( f \" { self . nom } marche.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas marcher car il n'a pas assez d'\u00e9nergie.\" ) def courir ( self ): cout = 10 if self . energie >= cout : print ( f \" { self . nom } court.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas courir car il n \\' a pas assez d \\' \u00e9nergie.\" ) def dormir ( self ): print ( f \" { self . nom } dort et fait le plein d'\u00e9nergie.\" ) for i in range ( 2 ): print ( '...' ) sleep ( 1 ) self . energie = MAX_ENERGIE def manger ( self ): energie = 10 print ( f \" { self . nom } mange et r\u00e9cup\u00e8re { energie } points d'\u00e9nergie.\" ) if self . energie <= MAX_ENERGIE - energie : self . energie += energie else : self . energie = MAX_ENERGIE def __str__ ( self ): return f \"Je suis { self . nom } et j'ai { self . energie } points d'\u00e9nergie\" a = Personnage ( 'Bob' ) a . courir () a . dormir () a . manger () print ( a ) Documentation # Pour l'\u00e9criture d'un script Processing, tant en utilisant la POO ou la version avec les d\u00e9corateurs, il y a une page sur la documentation . Utiliser Processing en Python avec un algorithme existant # Sur une couche en EPSG:2154, faire un buffer de 10 m\u00e8tres par exemple. Cliquer sur la petite horloge dans le panneau de Processing/Traitement en haut Cliquer sur le dernier traitement en haut, puis copier/coller la ligne de Python On peut appeler un traitement en ligne de commande Python : 1 2 3 4 5 6 7 8 9 10 11 12 13 processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/CANALISATION_EAU.shp' , 'DISTANCE' : 10 , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) Tip Pour obtenir l'identifiant de l'algorithme, laissez la souris sur le nom de l'algorithme pour avoir son info-bulle dans le panneau traitement. Lien vers la documentation : https://docs.qgis.org/testing/en/docs/user_manual/processing/console.html Pour obtenir la description d'un algorithme : 1 processing . algorithmHelp ( \"native:buffer\" ) Exercice , faire une 3 tampons sur la m\u00eame couche vecteur, distance 10, 20 et 30 m\u00e8tres, avec une fonction. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def tampon ( distance ): result = processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/BARRAGE.shp' , 'DISTANCE' : distance , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) QgsProject . instance () . addMapLayer ( result [ 'OUTPUT' ]) for x in [ 10 , 20 , 30 ]: tampon ( x ) Lancer l'interface graphique de notre algorithme # Au lieu de processing.run , on peut cr\u00e9er uniquement le dialogue. Il faut alors l'afficher manuellement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 dialog = processing . createAlgorithmDialog ( \"native:buffer\" , { 'INPUT' : '/data/lines.shp' , 'DISTANCE' : 100.0 , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 , 'OUTPUT' : '/data/buffers.shp' } ) dialog . show () Ou alors directement lancer ex\u00e9cution du dialogue : 1 2 3 4 5 6 7 8 9 10 11 12 13 processing . execAlgorithmDialog ( \"native:buffer\" , { 'INPUT' : '/data/lines.shp' , 'DISTANCE' : 100.0 , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 , 'OUTPUT' : '/data/buffers.shp' } ) Notre propre script Processing # Nous souhaitons pouvoir cr\u00e9er plusieurs tables vides assez facilement \u00e0 l'aide des fichiers CSV. Nous avons un dossier avec plusieurs fichiers CSV repr\u00e9sentant chacun une table. Le nom du fichier CSV repr\u00e9sente le nom de la table. La premi\u00e8re ligne repr\u00e9sente l'ent\u00eate des colonnes. La deuxi\u00e8me ligne, si elle s'appelle geom , repr\u00e9sente le type de g\u00e9om\u00e9trie et sa projection. Exemple de fichier csv canalisation.csv : name type length precision alias geom polygon 2154 id 2 3 0 ID n 10 10 0 Nom d 2 3 0 Diam\u00e8tre l 2 3 0 Longueur Pr\u00e9paration # Cr\u00e9er un dossier processing_canalisation \u00e0 c\u00f4t\u00e9 du projet avec des fichiers CSV \u00e0 l'int\u00e9rieur : canalisation.csv 1 2 3 4 5 6 name,type,length,precision,alias geom,line,2154,'','' id,2,3,0,ID n,10,10,0,Nom d,2,3,0,Diam\u00e8tre l,2,3,0,Longueur regard.csv : 1 2 3 4 name,type,length,precision,alias geom,point,2154,'','' id,2,3,0,ID n,10,10,0,Nom rue Cr\u00e9ation du coeur de notre script # Commen\u00e7ons par \u00e9crire le script en console Il nous faut une fonction qui liste les CSV dans un dossier. 1 2 3 def liste_csv ( folder ): \"\"\" Liste les CSV disponibles dans le dossier. \"\"\" pass Correction du script Python (et non la correction du script Processing) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import os import csv def liste_csv ( folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csv_file : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer # Appel des fonctions folder = os . path . join ( QgsProject . instance () . homePath (), 'processing_canalisation' ) csv_files = liste_csv ( folder ) for csv_file in csv_files : layer = lire_csv ( csv_file ) QgsProject . instance () . addMapLayer ( layer ) Nous avons le coeur de notre algorithme, qui fonctionne dans la console Python. Si l'utilisateur souhaite changer de th\u00e9matique pour la g\u00e9n\u00e9ration des couches (ne pas utiliser processing_canalisation mais plut\u00f4t processing_fibre_optique ou processing_plu ), il faut qu'il modifie \u00e0 la main la ligne de Python, ce n'est pas tr\u00e8s ergonomique. Nous allons d\u00e9sormais le transformer en Script Processing afin de rajouter une interface graphique. Partons de l'algorithme d'exemple : Panneau Traitement Python en haut Cr\u00e9er un nouveau script depuis un mod\u00e8le Modifions les fonctions une par une : name() displayName() ... Pour le initAlgorithm() , nous devons modifier le param\u00e8tre pour afficher un s\u00e9lecteur de dossier : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def initAlgorithm ( self , config = None ): self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT_LAYERS , self . tr ( 'Couches de sorties' ) ) ) Ajoutons les fonctions liste_csv et lire_csv mais : Ajoutons self comme premier param\u00e8tre dans la signature de la fonction : def lire_csv(self, ...): Ajoutons self lors de l'appel \u00e0 la fonction : self.liste_csv(...) Pour le processAlgorithm , nous allons incorporer le code que l'on a fait avant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Il faut aussi ajouter les imports manquants. Solution finale : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 \"\"\" *************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU General Public License as published by * * the Free Software Foundation; either version 2 of the License, or * * (at your option) any later version. * * * *************************************************************************** \"\"\" import os import csv from qgis.PyQt.QtCore import QCoreApplication from qgis.core import ( edit , QgsField , QgsProcessingContext , QgsProcessingAlgorithm , QgsProcessingParameterFile , QgsProcessingOutputMultipleLayers , QgsVectorLayer , ) class ExampleProcessingAlgorithm ( QgsProcessingAlgorithm ): \"\"\" This is an example algorithm that takes a vector layer and creates a new identical one. It is meant to be used as an example of how to create your own algorithms and explain methods and variables used to do it. An algorithm like this will be available in all elements, and there is not need for additional work. All Processing algorithms should extend the QgsProcessingAlgorithm class. \"\"\" # Constants used to refer to parameters and outputs. They will be # used when calling the algorithm from another algorithm, or when # calling from the QGIS console. INPUT = 'INPUT' OUTPUT = 'OUTPUT' def tr ( self , string ): \"\"\" Returns a translatable string with the self.tr() function. \"\"\" return QCoreApplication . translate ( 'Processing' , string ) def createInstance ( self ): return ExampleProcessingAlgorithm () def name ( self ): \"\"\" Returns the algorithm name, used for identifying the algorithm. This string should be fixed for the algorithm, and must not be localised. The name should be unique within each provider. Names should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'myscript' def displayName ( self ): \"\"\" Returns the translated algorithm name, which should be used for any user-visible display of the algorithm name. \"\"\" return self . tr ( 'My Script' ) def group ( self ): \"\"\" Returns the name of the group this algorithm belongs to. This string should be localised. \"\"\" return self . tr ( 'Example scripts' ) def groupId ( self ): \"\"\" Returns the unique ID of the group this algorithm belongs to. This string should be fixed for the algorithm, and must not be localised. The group id should be unique within each provider. Group id should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'examplescripts' def shortHelpString ( self ): \"\"\" Returns a localised short helper string for the algorithm. This string should provide a basic description about what the algorithm does and the parameters and outputs associated with it.. \"\"\" return self . tr ( \"Example algorithm short description\" ) def initAlgorithm ( self , config = None ): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT , self . tr ( 'Couches de sorties' ) ) ) def liste_csv ( self , folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( self , csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csvfile : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Nous avons d\u00e9sormais un nouveau algorithme dans la bo\u00eete \u00e0 outils pour g\u00e9n\u00e9rer un mod\u00e8le de donn\u00e9es suivant une th\u00e9matique. Introduction aux d\u00e9corateurs # Comme mentionn\u00e9 au d\u00e9but de ce chapitre, il est possible de ne pas utiliser la POO pour \u00e9crire un Script Processing mais plut\u00f4t les d\u00e9corateurs. Reprenons l'exemple de la documentation. Le code suivant utilise le d\u00e9corateur @alg pour : utiliser une couche vectorielle comme entr\u00e9e compter le nombre d'entit\u00e9s faire une op\u00e9ration buffer cr\u00e9er une couche raster \u00e0 partir du r\u00e9sultat de l\u2019op\u00e9ration de tampon renvoyer la couche tampon, la couche raster et le nombre d\u2019entit\u00e9s Dans la documentation QGIS, on trouve la correspondance des d\u00e9corateurs avec la classe Processing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from qgis import processing from qgis.processing import alg @alg ( name = 'bufferrasteralg' , label = 'Buffer and export to raster (alg)' , group = 'examplescripts' , group_label = 'Example scripts' ) # 'INPUT' is the recommended name for the main input parameter @alg . input ( type = alg . SOURCE , name = 'INPUT' , label = 'Input vector layer' ) # 'OUTPUT' is the recommended name for the main output parameter @alg . input ( type = alg . RASTER_LAYER_DEST , name = 'OUTPUT' , label = 'Raster output' ) @alg . input ( type = alg . VECTOR_LAYER_DEST , name = 'BUFFER_OUTPUT' , label = 'Buffer output' ) @alg . input ( type = alg . DISTANCE , name = 'BUFFERDIST' , label = 'BUFFER DISTANCE' , default = 1.0 ) @alg . input ( type = alg . DISTANCE , name = 'CELLSIZE' , label = 'RASTER CELL SIZE' , default = 10.0 ) @alg . output ( type = alg . NUMBER , name = 'NUMBEROFFEATURES' , label = 'Number of features processed' ) def bufferrasteralg ( instance , parameters , context , feedback , inputs ): \"\"\" Description of the algorithm. (If there is no comment here, you will get an error) \"\"\" input_featuresource = instance . parameterAsSource ( parameters , 'INPUT' , context ) numfeatures = input_featuresource . featureCount () bufferdist = instance . parameterAsDouble ( parameters , 'BUFFERDIST' , context ) rastercellsize = instance . parameterAsDouble ( parameters , 'CELLSIZE' , context ) if feedback . isCanceled (): return {} params = { 'INPUT' : parameters [ 'INPUT' ], 'OUTPUT' : parameters [ 'BUFFER_OUTPUT' ], 'DISTANCE' : bufferdist , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 } buffer_result = processing . run ( 'native:buffer' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} params = { 'LAYER' : buffer_result [ 'OUTPUT' ], 'EXTENT' : buffer_result [ 'OUTPUT' ], 'MAP_UNITS_PER_PIXEL' : rastercellsize , 'OUTPUT' : parameters [ 'OUTPUT' ] } rasterized_result = processing . run ( 'qgis:rasterize' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} results = { 'OUTPUT' : rasterized_result [ 'OUTPUT' ], 'BUFFER_OUTPUT' : buffer_result [ 'OUTPUT' ], 'NUMBEROFFEATURES' : numfeatures , } return results Convertir un mod\u00e8le Processing en python # Il est possible de convertir un mod\u00e8le Processing en script Python. On peut alors le modifier avec plus de finesse. On ne peut pas reconvertir un script Python en mod\u00e8le . Depuis un mod\u00e8le, cliquer sur le bouton \"Convertir en script Processing\".","title":"Script Processing"},{"location":"script-processing/#processing","text":"Processing est un framework pour faire des algorithmes dans QGIS. Toute la boite \u00e0 outils Traitement dans QGIS sont des bas\u00e9s sur \"Processing\". Note , depuis QGIS 3.6, il existe d\u00e9sormais une autre syntaxe pour \u00e9crire script Processing \u00e0 l'aide des d\u00e9corateurs Python.","title":"Processing"},{"location":"script-processing/#notion-sur-la-poo-en-python","text":"Le framework Processing utilise le concept de la P rogrammation O rient\u00e9e O bjet. Il existe un tutoriel sur le site d'OpenClassRooms sur le sujet. Mais depuis le d\u00e9but de la formation, nous l'utilisons sans trop le savoir. Les objets Qgs* , comme QgsMapLayer utilisent le principe de la POO. Tip Vous pouvez relire le passage sur la POO en d\u00e9but de formation . Nous allons faire un \"tr\u00e8s\" petit exemple rapide. \u00c9crivons notre premier jeu vid\u00e9o en console ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from time import sleep MAX_ENERGIE = 20 class Personnage : def __init__ ( self , nom , energie = MAX_ENERGIE ): self . nom = nom self . energie = energie def marcher ( self ): cout = 5 if self . energie >= cout : print ( f \" { self . nom } marche.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas marcher car il n'a pas assez d'\u00e9nergie.\" ) def courir ( self ): cout = 10 if self . energie >= cout : print ( f \" { self . nom } court.\" ) self . energie -= cout else : print ( f \" { self . nom } ne peut pas courir car il n \\' a pas assez d \\' \u00e9nergie.\" ) def dormir ( self ): print ( f \" { self . nom } dort et fait le plein d'\u00e9nergie.\" ) for i in range ( 2 ): print ( '...' ) sleep ( 1 ) self . energie = MAX_ENERGIE def manger ( self ): energie = 10 print ( f \" { self . nom } mange et r\u00e9cup\u00e8re { energie } points d'\u00e9nergie.\" ) if self . energie <= MAX_ENERGIE - energie : self . energie += energie else : self . energie = MAX_ENERGIE def __str__ ( self ): return f \"Je suis { self . nom } et j'ai { self . energie } points d'\u00e9nergie\" a = Personnage ( 'Bob' ) a . courir () a . dormir () a . manger () print ( a )","title":"Notion sur la POO en Python"},{"location":"script-processing/#documentation","text":"Pour l'\u00e9criture d'un script Processing, tant en utilisant la POO ou la version avec les d\u00e9corateurs, il y a une page sur la documentation .","title":"Documentation"},{"location":"script-processing/#utiliser-processing-en-python-avec-un-algorithme-existant","text":"Sur une couche en EPSG:2154, faire un buffer de 10 m\u00e8tres par exemple. Cliquer sur la petite horloge dans le panneau de Processing/Traitement en haut Cliquer sur le dernier traitement en haut, puis copier/coller la ligne de Python On peut appeler un traitement en ligne de commande Python : 1 2 3 4 5 6 7 8 9 10 11 12 13 processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/CANALISATION_EAU.shp' , 'DISTANCE' : 10 , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) Tip Pour obtenir l'identifiant de l'algorithme, laissez la souris sur le nom de l'algorithme pour avoir son info-bulle dans le panneau traitement. Lien vers la documentation : https://docs.qgis.org/testing/en/docs/user_manual/processing/console.html Pour obtenir la description d'un algorithme : 1 processing . algorithmHelp ( \"native:buffer\" ) Exercice , faire une 3 tampons sur la m\u00eame couche vecteur, distance 10, 20 et 30 m\u00e8tres, avec une fonction. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def tampon ( distance ): result = processing . run ( \"native:buffer\" , { 'INPUT' : '/home/etienne/tmp/formation_pyqgis/202101_OSM2IGEO_11_ILE_DE_FRANCE_SHP_L93_2154/D_OSM_HYDROGRAPHIE/BARRAGE.shp' , 'DISTANCE' : distance , 'SEGMENTS' : 5 , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 2 , 'DISSOLVE' : False , 'OUTPUT' : 'TEMPORARY_OUTPUT' } ) QgsProject . instance () . addMapLayer ( result [ 'OUTPUT' ]) for x in [ 10 , 20 , 30 ]: tampon ( x )","title":"Utiliser Processing en Python avec un algorithme existant"},{"location":"script-processing/#lancer-linterface-graphique-de-notre-algorithme","text":"Au lieu de processing.run , on peut cr\u00e9er uniquement le dialogue. Il faut alors l'afficher manuellement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 dialog = processing . createAlgorithmDialog ( \"native:buffer\" , { 'INPUT' : '/data/lines.shp' , 'DISTANCE' : 100.0 , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 , 'OUTPUT' : '/data/buffers.shp' } ) dialog . show () Ou alors directement lancer ex\u00e9cution du dialogue : 1 2 3 4 5 6 7 8 9 10 11 12 13 processing . execAlgorithmDialog ( \"native:buffer\" , { 'INPUT' : '/data/lines.shp' , 'DISTANCE' : 100.0 , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 , 'OUTPUT' : '/data/buffers.shp' } )","title":"Lancer l'interface graphique de notre algorithme"},{"location":"script-processing/#notre-propre-script-processing","text":"Nous souhaitons pouvoir cr\u00e9er plusieurs tables vides assez facilement \u00e0 l'aide des fichiers CSV. Nous avons un dossier avec plusieurs fichiers CSV repr\u00e9sentant chacun une table. Le nom du fichier CSV repr\u00e9sente le nom de la table. La premi\u00e8re ligne repr\u00e9sente l'ent\u00eate des colonnes. La deuxi\u00e8me ligne, si elle s'appelle geom , repr\u00e9sente le type de g\u00e9om\u00e9trie et sa projection. Exemple de fichier csv canalisation.csv : name type length precision alias geom polygon 2154 id 2 3 0 ID n 10 10 0 Nom d 2 3 0 Diam\u00e8tre l 2 3 0 Longueur","title":"Notre propre script Processing"},{"location":"script-processing/#preparation","text":"Cr\u00e9er un dossier processing_canalisation \u00e0 c\u00f4t\u00e9 du projet avec des fichiers CSV \u00e0 l'int\u00e9rieur : canalisation.csv 1 2 3 4 5 6 name,type,length,precision,alias geom,line,2154,'','' id,2,3,0,ID n,10,10,0,Nom d,2,3,0,Diam\u00e8tre l,2,3,0,Longueur regard.csv : 1 2 3 4 name,type,length,precision,alias geom,point,2154,'','' id,2,3,0,ID n,10,10,0,Nom rue","title":"Pr\u00e9paration"},{"location":"script-processing/#creation-du-coeur-de-notre-script","text":"Commen\u00e7ons par \u00e9crire le script en console Il nous faut une fonction qui liste les CSV dans un dossier. 1 2 3 def liste_csv ( folder ): \"\"\" Liste les CSV disponibles dans le dossier. \"\"\" pass Correction du script Python (et non la correction du script Processing) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import os import csv def liste_csv ( folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csv_file : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer # Appel des fonctions folder = os . path . join ( QgsProject . instance () . homePath (), 'processing_canalisation' ) csv_files = liste_csv ( folder ) for csv_file in csv_files : layer = lire_csv ( csv_file ) QgsProject . instance () . addMapLayer ( layer ) Nous avons le coeur de notre algorithme, qui fonctionne dans la console Python. Si l'utilisateur souhaite changer de th\u00e9matique pour la g\u00e9n\u00e9ration des couches (ne pas utiliser processing_canalisation mais plut\u00f4t processing_fibre_optique ou processing_plu ), il faut qu'il modifie \u00e0 la main la ligne de Python, ce n'est pas tr\u00e8s ergonomique. Nous allons d\u00e9sormais le transformer en Script Processing afin de rajouter une interface graphique. Partons de l'algorithme d'exemple : Panneau Traitement Python en haut Cr\u00e9er un nouveau script depuis un mod\u00e8le Modifions les fonctions une par une : name() displayName() ... Pour le initAlgorithm() , nous devons modifier le param\u00e8tre pour afficher un s\u00e9lecteur de dossier : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def initAlgorithm ( self , config = None ): self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT_LAYERS , self . tr ( 'Couches de sorties' ) ) ) Ajoutons les fonctions liste_csv et lire_csv mais : Ajoutons self comme premier param\u00e8tre dans la signature de la fonction : def lire_csv(self, ...): Ajoutons self lors de l'appel \u00e0 la fonction : self.liste_csv(...) Pour le processAlgorithm , nous allons incorporer le code que l'on a fait avant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Il faut aussi ajouter les imports manquants. Solution finale : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 \"\"\" *************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU General Public License as published by * * the Free Software Foundation; either version 2 of the License, or * * (at your option) any later version. * * * *************************************************************************** \"\"\" import os import csv from qgis.PyQt.QtCore import QCoreApplication from qgis.core import ( edit , QgsField , QgsProcessingContext , QgsProcessingAlgorithm , QgsProcessingParameterFile , QgsProcessingOutputMultipleLayers , QgsVectorLayer , ) class ExampleProcessingAlgorithm ( QgsProcessingAlgorithm ): \"\"\" This is an example algorithm that takes a vector layer and creates a new identical one. It is meant to be used as an example of how to create your own algorithms and explain methods and variables used to do it. An algorithm like this will be available in all elements, and there is not need for additional work. All Processing algorithms should extend the QgsProcessingAlgorithm class. \"\"\" # Constants used to refer to parameters and outputs. They will be # used when calling the algorithm from another algorithm, or when # calling from the QGIS console. INPUT = 'INPUT' OUTPUT = 'OUTPUT' def tr ( self , string ): \"\"\" Returns a translatable string with the self.tr() function. \"\"\" return QCoreApplication . translate ( 'Processing' , string ) def createInstance ( self ): return ExampleProcessingAlgorithm () def name ( self ): \"\"\" Returns the algorithm name, used for identifying the algorithm. This string should be fixed for the algorithm, and must not be localised. The name should be unique within each provider. Names should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'myscript' def displayName ( self ): \"\"\" Returns the translated algorithm name, which should be used for any user-visible display of the algorithm name. \"\"\" return self . tr ( 'My Script' ) def group ( self ): \"\"\" Returns the name of the group this algorithm belongs to. This string should be localised. \"\"\" return self . tr ( 'Example scripts' ) def groupId ( self ): \"\"\" Returns the unique ID of the group this algorithm belongs to. This string should be fixed for the algorithm, and must not be localised. The group id should be unique within each provider. Group id should contain lowercase alphanumeric characters only and no spaces or other formatting characters. \"\"\" return 'examplescripts' def shortHelpString ( self ): \"\"\" Returns a localised short helper string for the algorithm. This string should provide a basic description about what the algorithm does and the parameters and outputs associated with it.. \"\"\" return self . tr ( \"Example algorithm short description\" ) def initAlgorithm ( self , config = None ): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" self . addParameter ( QgsProcessingParameterFile ( self . INPUT , self . tr ( 'R\u00e9pertoire' ), QgsProcessingParameterFile . Folder , optional = False ) ) self . addOutput ( QgsProcessingOutputMultipleLayers ( self . OUTPUT , self . tr ( 'Couches de sorties' ) ) ) def liste_csv ( self , folder ): \"\"\" Fonction g\u00e9n\u00e9rique pour liste les CSV dans un dossier. \"\"\" csvs = [] for root , directories , files in os . walk ( folder ): for file in files : if file . lower () . endswith ( '.csv' ): csvs . append ( os . path . join ( root , file )) return csvs def lire_csv ( self , csv_file ): \"\"\" Fonction g\u00e9n\u00e9rique pour cr\u00e9er une couche vecteur selon la d\u00e9finition d'un CSV. \"\"\" geom = 'None' crs = None fields = [] with open ( csv_file ) as csvfile : reader = csv . reader ( csvfile ) for i , row in enumerate ( reader ): if i == 0 : # Header du CSV continue elif i == 1 and row [ 0 ] == 'geom' : geom = row [ 1 ] crs = row [ 2 ] else : field = QgsField () field . setName ( row [ 0 ]) field . setType ( int ( row [ 1 ])) field . setLength ( int ( row [ 2 ])) field . setPrecision ( int ( row [ 3 ])) field . setAlias ( row [ 4 ]) fields . append ( field ) name = os . path . splitext ( os . path . basename ( csv_file ))[ 0 ] if geom : geom += '?crs=epsg: {} ' . format ( crs ) layer = QgsVectorLayer ( geom , name , 'memory' ) with edit ( layer ): for field in fields : layer . addAttribute ( field ) return layer def processAlgorithm ( self , parameters , context , feedback ): \"\"\" Here is where the processing itself takes place. \"\"\" folder = self . parameterAsFile ( parameters , self . INPUT , context ) csv_files = self . liste_csv ( folder ) results = [] for csv_file in csv_files : layer = self . lire_csv ( csv_file ) results . append ( layer . id ()) context . temporaryLayerStore () . addMapLayer ( layer ) context . addLayerToLoadOnCompletion ( layer . id (), QgsProcessingContext . LayerDetails ( layer . name (), context . project (), self . OUTPUT ) ) return { self . OUTPUT : results } Nous avons d\u00e9sormais un nouveau algorithme dans la bo\u00eete \u00e0 outils pour g\u00e9n\u00e9rer un mod\u00e8le de donn\u00e9es suivant une th\u00e9matique.","title":"Cr\u00e9ation du coeur de notre script"},{"location":"script-processing/#introduction-aux-decorateurs","text":"Comme mentionn\u00e9 au d\u00e9but de ce chapitre, il est possible de ne pas utiliser la POO pour \u00e9crire un Script Processing mais plut\u00f4t les d\u00e9corateurs. Reprenons l'exemple de la documentation. Le code suivant utilise le d\u00e9corateur @alg pour : utiliser une couche vectorielle comme entr\u00e9e compter le nombre d'entit\u00e9s faire une op\u00e9ration buffer cr\u00e9er une couche raster \u00e0 partir du r\u00e9sultat de l\u2019op\u00e9ration de tampon renvoyer la couche tampon, la couche raster et le nombre d\u2019entit\u00e9s Dans la documentation QGIS, on trouve la correspondance des d\u00e9corateurs avec la classe Processing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from qgis import processing from qgis.processing import alg @alg ( name = 'bufferrasteralg' , label = 'Buffer and export to raster (alg)' , group = 'examplescripts' , group_label = 'Example scripts' ) # 'INPUT' is the recommended name for the main input parameter @alg . input ( type = alg . SOURCE , name = 'INPUT' , label = 'Input vector layer' ) # 'OUTPUT' is the recommended name for the main output parameter @alg . input ( type = alg . RASTER_LAYER_DEST , name = 'OUTPUT' , label = 'Raster output' ) @alg . input ( type = alg . VECTOR_LAYER_DEST , name = 'BUFFER_OUTPUT' , label = 'Buffer output' ) @alg . input ( type = alg . DISTANCE , name = 'BUFFERDIST' , label = 'BUFFER DISTANCE' , default = 1.0 ) @alg . input ( type = alg . DISTANCE , name = 'CELLSIZE' , label = 'RASTER CELL SIZE' , default = 10.0 ) @alg . output ( type = alg . NUMBER , name = 'NUMBEROFFEATURES' , label = 'Number of features processed' ) def bufferrasteralg ( instance , parameters , context , feedback , inputs ): \"\"\" Description of the algorithm. (If there is no comment here, you will get an error) \"\"\" input_featuresource = instance . parameterAsSource ( parameters , 'INPUT' , context ) numfeatures = input_featuresource . featureCount () bufferdist = instance . parameterAsDouble ( parameters , 'BUFFERDIST' , context ) rastercellsize = instance . parameterAsDouble ( parameters , 'CELLSIZE' , context ) if feedback . isCanceled (): return {} params = { 'INPUT' : parameters [ 'INPUT' ], 'OUTPUT' : parameters [ 'BUFFER_OUTPUT' ], 'DISTANCE' : bufferdist , 'SEGMENTS' : 10 , 'DISSOLVE' : True , 'END_CAP_STYLE' : 0 , 'JOIN_STYLE' : 0 , 'MITER_LIMIT' : 10 } buffer_result = processing . run ( 'native:buffer' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} params = { 'LAYER' : buffer_result [ 'OUTPUT' ], 'EXTENT' : buffer_result [ 'OUTPUT' ], 'MAP_UNITS_PER_PIXEL' : rastercellsize , 'OUTPUT' : parameters [ 'OUTPUT' ] } rasterized_result = processing . run ( 'qgis:rasterize' , params , is_child_algorithm = True , context = context , feedback = feedback ) if feedback . isCanceled (): return {} results = { 'OUTPUT' : rasterized_result [ 'OUTPUT' ], 'BUFFER_OUTPUT' : buffer_result [ 'OUTPUT' ], 'NUMBEROFFEATURES' : numfeatures , } return results","title":"Introduction aux d\u00e9corateurs"},{"location":"script-processing/#convertir-un-modele-processing-en-python","text":"Il est possible de convertir un mod\u00e8le Processing en script Python. On peut alors le modifier avec plus de finesse. On ne peut pas reconvertir un script Python en mod\u00e8le . Depuis un mod\u00e8le, cliquer sur le bouton \"Convertir en script Processing\".","title":"Convertir un mod\u00e8le Processing en python"},{"location":"selection-parcours-entites/","text":"Fonctions sur une couche vecteur # Boucler sur les entit\u00e9s d'une couche sans expression # On peut parcourir les entit\u00e9s d'une couche QgsVectorLayer \u00e0 l'aide de getFeatures() : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): print ( feature ) print ( feature [ 'NOM' ]) Utilisation des expressions QGIS # Les expressions sont tr\u00e8s pr\u00e9sentes dans QGIS, tant dans l'interface graphique que dans l'utilisation en Python. Nous partons de la couche des COMMUNES uniquement charg\u00e9 dans QGIS. S\u00e9lection d'entit\u00e9 # Nous souhaitons s\u00e9lectionner les entit\u00e9s dont le code INSEE commence par 77 . Commen\u00e7ons par faire cela graphiquement dans QGIS Desktop. \u00c0 l'aide d'une expression QGIS, s\u00e9lectionner les codes INSEE qui commencent par 77 (\u00e0 choisir un code INSEE propre au jeu de donn\u00e9es). Solution en mode graphique : 1 \"CODE_INSEE\" LIKE '77%' Nous allons faire la m\u00eame chose, mais en utilisant Python. Pensez \u00e0 d\u00e9s\u00e9lectionner les entit\u00e9s. 1 2 3 4 5 layer = iface . activeLayer () layer . removeSelection () layer . selectByExpression ( \" \\\" CODE_INSEE \\\" LIKE ' {} %'\" . format ( 77 )) layer . invertSelection () layer . removeSelection () Boucler sur les entit\u00e9s \u00e0 l'aide d'une expression # L'objectif est d'afficher dans la console le nom des communes dont la population ne contient pas NC . Info Avec PyQGIS, on peut acc\u00e9der aux attributs d'une QgsFeature simplement avec l'op\u00e9rateur [] sur l'objet courant comme s'il s'agissait d'un dictionnaire Python : 1 2 # Pour acc\u00e9der au champ \"NOM_COM\" de l'entit\u00e9 \"feature\" : print ( feature [ 'NOM_COM' ]) L'exemple \u00e0 ne pas faire, m\u00eame si cela fonctionne (car on peut l'optimiser tr\u00e8s facilement) : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): if feature [ 'POPUL' ] != 'NC' : print ( feature [ 'NOM_COM' ]) Tip Ce qui prend du temps lors de l'ex\u00e9cution, c'est surtout le print en lui-m\u00eame. Si vous n'utilisez pas print , mais un autre traitement, cela sera plus rapide. Un simple print ralenti l'ex\u00e9cution d'un script. Optimisation de la requ\u00eate # Dans la documentation, observez bien la signature de la fonction getFeatures . Que remarquez-vous ? Utilisons donc une expression pour limiter les r\u00e9sultats. 1 2 3 request = QgsFeatureRequest ( QgsExpression ( '\"POPUL\" != \\' NC \\' ' )) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants pour' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Nous pouvons accessoirement ordonner les r\u00e9sultats et surtout encore optimiser la requ\u00eate en : Ne demandant pas de charger la g\u00e9om\u00e9trie Ne demandant pas de charger tous les attributs La solution pour les experts 1 2 3 4 5 6 7 8 request = QgsFeatureRequest () request . setFilterExpression ( '\"POPUL\" != \\' NC \\' ' ) request . addOrderBy ( 'NOM' ) request . setFlags ( QgsFeatureRequest . NoGeometry ) # request.setSubsetOfAttributes([1, 4]) autre mani\u00e8re moins pratique request . setSubsetOfAttributes ([ 'NOM' , 'POPUL' ], layer . fields ()) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Faire le test en affichant un champ qui n'est pas dans la requ\u00eate. Rajoutons une intersection spatiale avec l'emprise suivante : 1 request . setFilterRect ( QgsRectangle ( 662737 , 6807733 , 717144 , 6853979 )) Si l'on souhaite \"enregistrer\" le r\u00e9sultat de cette expression QGIS, on peut la mat\u00e9rialiser dans une nouvelle couche : 1 2 memory_layer = layer . materialize ( request ) QgsProject . instance () . addMapLayer ( memory_layer ) Warning Attention \u00e0 la ligne iface.activeLayer() qui peut changer lors de l'ajout d'une nouvelle couche dans la l\u00e9gende. Regardons le r\u00e9sultat et corrigeons ce probl\u00e8me d'export afin d'obtenir les g\u00e9om\u00e9tries et les attributs, il faut supprimer la ligne NoGeometry si vous l'avez. Calculer un champ # Avant-dernier exercice, afficher une liste des communes en incluant la densit\u00e9 de population. Mais regardons avant la gestion des erreurs lors d'un traitement. En effet, nous allons vouloir \"caster\" (transformer le type) de la variable population en entier, mais attention, il y a des valeurs NC dans les valeurs. Les exceptions en Python # Avant de traiter cet exercice, nous devons voir ce qu'est une exception en Python. \u00c0 plusieurs reprises depuis le d\u00e9but de la formation, il est fort \u00e0 parier que nous ayons des messages en rouges dans la console de temps en temps. Ce sont des exceptions. C'est une notion de programmation qui existe dans beaucoup de languages. Dans le langage informatique, une exception peut-\u00eatre : lev\u00e9e (\"raise\" en anglais) pour d\u00e9clencher une erreur attrap\u00e9e (\"catch\" en anglais, ou plut\u00f4t \"except\" en Python) pour traiter l'erreur Essayons dans la console de faire une l'op\u00e9ration 10 / 2 : 1 10 / 2 Essayons cette fois-ci 10 / 0, ce qui est math\u00e9matiquement impossible : 1 10 / 0 On peut \"attraper\" cette erreur Python \u00e0 l'aide d'un try ... except... : 1 2 3 4 try : 10 / 2 except ZeroDivisionError : print ( 'Ceci est une division par z\u00e9ro !' ) Le try permet d'essayer le code qui suit. Le except permet d'attraper en filtrant s'il y a des exceptions et de traiter l'erreur si besoin. Toutes les exceptions h\u00e9ritent de Exception donc le code ci-dessous fonctionne, mais n'est pas recommand\u00e9 car il masque d'autres erreurs : 1 2 3 4 try : 10 / 2 except Exception : print ( 'Ceci est une division par z\u00e9ro !' ) Il existe d'autres mots-cl\u00e9s en Python pour les exceptions comme finally: et else: . On peut imaginer faire une fonction qui divise deux nombres et affiche le r\u00e9sultat dans la QgsMessageBar de QGIS, sans tenir compte de la division par z\u00e9ro : 1 2 3 4 5 def diviser ( a , b ): result = a / b iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 0 ) En tenant compte d'une possible erreur lors de l'op\u00e9ration math\u00e9matique : 1 2 3 4 5 6 7 8 9 def diviser ( a , b ): try : result = a / b except ZeroDivisionError : iface . messageBar () . pushMessage ( 'Division par 0' , f ' { a } / { b } est impossible' , Qgis . Warning ) else : iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 2 ) \u00c9videment, on peut v\u00e9rifier la valeur de b en amont si c'est \u00e9gal \u00e0 0. Mais ceci est pour pr\u00e9senter le concept des exceptions en Python. Retour \u00e0 l'exercice # On souhaite donc savoir si un nombre est transformable en entier, dans le cas de la population (s'il y a NC par exemple) : 1 2 int ( '10' ) int ( 'NC' ) Correction possible de l'exercice : 1 2 3 4 5 6 7 8 9 10 11 12 layer = iface . activeLayer () request = QgsFeatureRequest () # request.setFilterExpression('to_int( \"POPUL\" ) < 1000') request . addOrderBy ( 'NOM' ) request . setSubsetOfAttributes ([ 'NOM' , 'POPUL' ], layer . fields ()) for feature in layer . getFeatures ( request ): area = feature . geometry () . area () / 1000000 try : population = int ( feature [ 'POPUL' ]) except ValueError : population = 0 print ( ' {commune} : {densite} habitants/km\u00b2' . format ( commune = feature [ 'NOM' ], densite = population / area )) Nous souhaitons enregistrer ces informations dans une vraie table avec un nouveau champ densite_population . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): field = QgsField ( 'densite_population' , QVariant . Double ) petites_communes . addAttribute ( field ) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) QgsProject . instance () . addMapLayer ( petites_communes ) Manipulons d\u00e9sormais la g\u00e9om\u00e9trie en ajoutant le centro\u00efde de la commune dans une colonne latitude et longitude en degr\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): petites_communes . addAttribute ( QgsField ( 'densite_population' , QVariant . Double )) # /!\\ Ajouter les 2 lignes ci-dessous petites_communes . addAttribute ( QgsField ( 'longitude' , QVariant . Double )) petites_communes . addAttribute ( QgsField ( 'latitude' , QVariant . Double )) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) # /!\\ Ajouter les 2 lignes ci-dessous \u00e0 propos de la transformation transform = QgsCoordinateTransform ( QgsCoordinateReferenceSystem ( \"EPSG:2154\" ), QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), QgsProject . instance ()) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) # /!\\ Ajouter les lignes ci-dessous geom = feature . geometry () # La transformation affecte directement l'objet Python en cours, mais pas l'entit\u00e9 dans la couche geom . transform ( transform ) centroid = geom . centroid () . asPoint () petites_communes . changeAttributeValue ( feature . id (), 6 , centroid . x ()) petites_communes . changeAttributeValue ( feature . id (), 7 , centroid . y ()) QgsProject . instance () . addMapLayer ( petites_communes ) Valeur NULL # En PyQGIS, il existe la valeur NULL qui peut-\u00eatre pr\u00e9sente dans la table attributaire d'une couche vecteur. 1 2 3 4 5 6 7 8 from qgis.PyQt.QtCore import NULL if feature [ 'nom_attribut' ] == NULL : # Traiter la valeur NULL pass else : # Continuer pass","title":"S\u00e9lection & Parcours"},{"location":"selection-parcours-entites/#fonctions-sur-une-couche-vecteur","text":"","title":"Fonctions sur une couche vecteur"},{"location":"selection-parcours-entites/#boucler-sur-les-entites-dune-couche-sans-expression","text":"On peut parcourir les entit\u00e9s d'une couche QgsVectorLayer \u00e0 l'aide de getFeatures() : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): print ( feature ) print ( feature [ 'NOM' ])","title":"Boucler sur les entit\u00e9s d'une couche sans expression"},{"location":"selection-parcours-entites/#utilisation-des-expressions-qgis","text":"Les expressions sont tr\u00e8s pr\u00e9sentes dans QGIS, tant dans l'interface graphique que dans l'utilisation en Python. Nous partons de la couche des COMMUNES uniquement charg\u00e9 dans QGIS.","title":"Utilisation des expressions QGIS"},{"location":"selection-parcours-entites/#selection-dentite","text":"Nous souhaitons s\u00e9lectionner les entit\u00e9s dont le code INSEE commence par 77 . Commen\u00e7ons par faire cela graphiquement dans QGIS Desktop. \u00c0 l'aide d'une expression QGIS, s\u00e9lectionner les codes INSEE qui commencent par 77 (\u00e0 choisir un code INSEE propre au jeu de donn\u00e9es). Solution en mode graphique : 1 \"CODE_INSEE\" LIKE '77%' Nous allons faire la m\u00eame chose, mais en utilisant Python. Pensez \u00e0 d\u00e9s\u00e9lectionner les entit\u00e9s. 1 2 3 4 5 layer = iface . activeLayer () layer . removeSelection () layer . selectByExpression ( \" \\\" CODE_INSEE \\\" LIKE ' {} %'\" . format ( 77 )) layer . invertSelection () layer . removeSelection ()","title":"S\u00e9lection d'entit\u00e9"},{"location":"selection-parcours-entites/#boucler-sur-les-entites-a-laide-dune-expression","text":"L'objectif est d'afficher dans la console le nom des communes dont la population ne contient pas NC . Info Avec PyQGIS, on peut acc\u00e9der aux attributs d'une QgsFeature simplement avec l'op\u00e9rateur [] sur l'objet courant comme s'il s'agissait d'un dictionnaire Python : 1 2 # Pour acc\u00e9der au champ \"NOM_COM\" de l'entit\u00e9 \"feature\" : print ( feature [ 'NOM_COM' ]) L'exemple \u00e0 ne pas faire, m\u00eame si cela fonctionne (car on peut l'optimiser tr\u00e8s facilement) : 1 2 3 4 layer = iface . activeLayer () for feature in layer . getFeatures (): if feature [ 'POPUL' ] != 'NC' : print ( feature [ 'NOM_COM' ]) Tip Ce qui prend du temps lors de l'ex\u00e9cution, c'est surtout le print en lui-m\u00eame. Si vous n'utilisez pas print , mais un autre traitement, cela sera plus rapide. Un simple print ralenti l'ex\u00e9cution d'un script.","title":"Boucler sur les entit\u00e9s \u00e0 l'aide d'une expression"},{"location":"selection-parcours-entites/#optimisation-de-la-requete","text":"Dans la documentation, observez bien la signature de la fonction getFeatures . Que remarquez-vous ? Utilisons donc une expression pour limiter les r\u00e9sultats. 1 2 3 request = QgsFeatureRequest ( QgsExpression ( '\"POPUL\" != \\' NC \\' ' )) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants pour' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Nous pouvons accessoirement ordonner les r\u00e9sultats et surtout encore optimiser la requ\u00eate en : Ne demandant pas de charger la g\u00e9om\u00e9trie Ne demandant pas de charger tous les attributs La solution pour les experts 1 2 3 4 5 6 7 8 request = QgsFeatureRequest () request . setFilterExpression ( '\"POPUL\" != \\' NC \\' ' ) request . addOrderBy ( 'NOM' ) request . setFlags ( QgsFeatureRequest . NoGeometry ) # request.setSubsetOfAttributes([1, 4]) autre mani\u00e8re moins pratique request . setSubsetOfAttributes ([ 'NOM' , 'POPUL' ], layer . fields ()) for feature in layer . getFeatures ( request ): print ( ' {commune} : {nombre} habitants' . format ( commune = feature [ 'NOM' ], nombre = feature [ 'POPUL' ])) Faire le test en affichant un champ qui n'est pas dans la requ\u00eate. Rajoutons une intersection spatiale avec l'emprise suivante : 1 request . setFilterRect ( QgsRectangle ( 662737 , 6807733 , 717144 , 6853979 )) Si l'on souhaite \"enregistrer\" le r\u00e9sultat de cette expression QGIS, on peut la mat\u00e9rialiser dans une nouvelle couche : 1 2 memory_layer = layer . materialize ( request ) QgsProject . instance () . addMapLayer ( memory_layer ) Warning Attention \u00e0 la ligne iface.activeLayer() qui peut changer lors de l'ajout d'une nouvelle couche dans la l\u00e9gende. Regardons le r\u00e9sultat et corrigeons ce probl\u00e8me d'export afin d'obtenir les g\u00e9om\u00e9tries et les attributs, il faut supprimer la ligne NoGeometry si vous l'avez.","title":"Optimisation de la requ\u00eate"},{"location":"selection-parcours-entites/#calculer-un-champ","text":"Avant-dernier exercice, afficher une liste des communes en incluant la densit\u00e9 de population. Mais regardons avant la gestion des erreurs lors d'un traitement. En effet, nous allons vouloir \"caster\" (transformer le type) de la variable population en entier, mais attention, il y a des valeurs NC dans les valeurs.","title":"Calculer un champ"},{"location":"selection-parcours-entites/#les-exceptions-en-python","text":"Avant de traiter cet exercice, nous devons voir ce qu'est une exception en Python. \u00c0 plusieurs reprises depuis le d\u00e9but de la formation, il est fort \u00e0 parier que nous ayons des messages en rouges dans la console de temps en temps. Ce sont des exceptions. C'est une notion de programmation qui existe dans beaucoup de languages. Dans le langage informatique, une exception peut-\u00eatre : lev\u00e9e (\"raise\" en anglais) pour d\u00e9clencher une erreur attrap\u00e9e (\"catch\" en anglais, ou plut\u00f4t \"except\" en Python) pour traiter l'erreur Essayons dans la console de faire une l'op\u00e9ration 10 / 2 : 1 10 / 2 Essayons cette fois-ci 10 / 0, ce qui est math\u00e9matiquement impossible : 1 10 / 0 On peut \"attraper\" cette erreur Python \u00e0 l'aide d'un try ... except... : 1 2 3 4 try : 10 / 2 except ZeroDivisionError : print ( 'Ceci est une division par z\u00e9ro !' ) Le try permet d'essayer le code qui suit. Le except permet d'attraper en filtrant s'il y a des exceptions et de traiter l'erreur si besoin. Toutes les exceptions h\u00e9ritent de Exception donc le code ci-dessous fonctionne, mais n'est pas recommand\u00e9 car il masque d'autres erreurs : 1 2 3 4 try : 10 / 2 except Exception : print ( 'Ceci est une division par z\u00e9ro !' ) Il existe d'autres mots-cl\u00e9s en Python pour les exceptions comme finally: et else: . On peut imaginer faire une fonction qui divise deux nombres et affiche le r\u00e9sultat dans la QgsMessageBar de QGIS, sans tenir compte de la division par z\u00e9ro : 1 2 3 4 5 def diviser ( a , b ): result = a / b iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 0 ) En tenant compte d'une possible erreur lors de l'op\u00e9ration math\u00e9matique : 1 2 3 4 5 6 7 8 9 def diviser ( a , b ): try : result = a / b except ZeroDivisionError : iface . messageBar () . pushMessage ( 'Division par 0' , f ' { a } / { b } est impossible' , Qgis . Warning ) else : iface . messageBar () . pushMessage ( 'R\u00e9sulat' , f ' { a } / { b } = { result } ' , Qgis . Success ) diviser ( 10 , 2 ) \u00c9videment, on peut v\u00e9rifier la valeur de b en amont si c'est \u00e9gal \u00e0 0. Mais ceci est pour pr\u00e9senter le concept des exceptions en Python.","title":"Les exceptions en Python"},{"location":"selection-parcours-entites/#retour-a-lexercice","text":"On souhaite donc savoir si un nombre est transformable en entier, dans le cas de la population (s'il y a NC par exemple) : 1 2 int ( '10' ) int ( 'NC' ) Correction possible de l'exercice : 1 2 3 4 5 6 7 8 9 10 11 12 layer = iface . activeLayer () request = QgsFeatureRequest () # request.setFilterExpression('to_int( \"POPUL\" ) < 1000') request . addOrderBy ( 'NOM' ) request . setSubsetOfAttributes ([ 'NOM' , 'POPUL' ], layer . fields ()) for feature in layer . getFeatures ( request ): area = feature . geometry () . area () / 1000000 try : population = int ( feature [ 'POPUL' ]) except ValueError : population = 0 print ( ' {commune} : {densite} habitants/km\u00b2' . format ( commune = feature [ 'NOM' ], densite = population / area )) Nous souhaitons enregistrer ces informations dans une vraie table avec un nouveau champ densite_population . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): field = QgsField ( 'densite_population' , QVariant . Double ) petites_communes . addAttribute ( field ) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) QgsProject . instance () . addMapLayer ( petites_communes ) Manipulons d\u00e9sormais la g\u00e9om\u00e9trie en ajoutant le centro\u00efde de la commune dans une colonne latitude et longitude en degr\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 layer = iface . activeLayer () request = QgsFeatureRequest () request . setFilterExpression ( 'to_int( \"POPUL\" ) < 1000' ) petites_communes = layer . materialize ( request ) with edit ( petites_communes ): petites_communes . addAttribute ( QgsField ( 'densite_population' , QVariant . Double )) # /!\\ Ajouter les 2 lignes ci-dessous petites_communes . addAttribute ( QgsField ( 'longitude' , QVariant . Double )) petites_communes . addAttribute ( QgsField ( 'latitude' , QVariant . Double )) request = QgsFeatureRequest () request . setSubsetOfAttributes ([ 4 ]) # /!\\ Ajouter les 2 lignes ci-dessous \u00e0 propos de la transformation transform = QgsCoordinateTransform ( QgsCoordinateReferenceSystem ( \"EPSG:2154\" ), QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), QgsProject . instance ()) with edit ( petites_communes ): for feature in petites_communes . getFeatures ( request ): area = feature . geometry () . area () / 1000000 population = int ( feature [ 'POPUL' ]) densite = population / area petites_communes . changeAttributeValue ( feature . id (), 5 , densite ) # /!\\ Ajouter les lignes ci-dessous geom = feature . geometry () # La transformation affecte directement l'objet Python en cours, mais pas l'entit\u00e9 dans la couche geom . transform ( transform ) centroid = geom . centroid () . asPoint () petites_communes . changeAttributeValue ( feature . id (), 6 , centroid . x ()) petites_communes . changeAttributeValue ( feature . id (), 7 , centroid . y ()) QgsProject . instance () . addMapLayer ( petites_communes )","title":"Retour \u00e0 l'exercice"},{"location":"selection-parcours-entites/#valeur-null","text":"En PyQGIS, il existe la valeur NULL qui peut-\u00eatre pr\u00e9sente dans la table attributaire d'une couche vecteur. 1 2 3 4 5 6 7 8 from qgis.PyQt.QtCore import NULL if feature [ 'nom_attribut' ] == NULL : # Traiter la valeur NULL pass else : # Continuer pass","title":"Valeur NULL"},{"location":"standalone/","text":"Librairie QGIS # QGIS Process # Depuis QGIS 3.16, il existe un outil qgis_process qui permet de lancer QGIS Processing en ligne de commande. Dans le shell OSGEO, taper : 1 2 3 4 5 6 7 8 9 10 11 12 13 cd C: \\O SGeo4W \\a pps \\q gis-ltr \\b in \\ qgis_process ```` ` cd ` pour Change Directory. Il peut s 'agir d' un chemin diff\u00e9rent, comme ` C:/Program Files/QGIS 3 .14/bin/ ` On peut lancer les algorithmes, les mod\u00e8les, les scripts qui sont dans la version graphique de QGIS Processing. On peut donc lancer en ligne de commande, ou alors notre propre ic\u00f4ne sur son bureau un ex\u00e9cutable. ``` bash qgis_process run qgis:buffer -- INPUT = source.shp DISTANCE = 2 OUTPUT = buffered.shp qgis_process help qgis:buffer Standalone application # Il est possible de faire un programme qui ne se lance pas dans QGIS Bureautique mais qui utilise la librairie QGIS qui se trouve sur l'ordinateur. On peut donc cr\u00e9er son propre programme, en ligne de commande ou avec une interface graphique qui utilise le moteur de QGIS en arri\u00e8re-plan pour utiliser ce que sait d\u00e9j\u00e0 faire QGIS. Exemple sur le gist de Thomas Gratier 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # Code borrowed from https://subscription.packtpub.com/book/application_development/9781783984985/1/ch01lvl1sec18/creating-a-standalone-application # and upgraded for QGIS 3.0 import os import sys import shutil import tempfile import urllib.request from zipfile import ZipFile from glob import glob from qgis.core import ( QgsApplication , QgsCoordinateReferenceSystem , QgsFeature , QgsGeometry , QgsProject , QgsRasterLayer , QgsVectorLayer ) from qgis.gui import QgsLayerTreeMapCanvasBridge , QgsMapCanvas from qgis.PyQt.QtCore import Qt # Unused so commented # from qgis.PyQt.QtGui import * app = QgsApplication ([], True ) # On Windows : https://gis.stackexchange.com/questions/334172/creating-standalone-application-in-qgis # On Linux, didn't need to set it so commented # app.setPrefixPath(\"C:/Program Files/QGIS Brighton/apps/qgis\", True) app . initQgis () canvas = QgsMapCanvas () canvas . setWindowTitle ( \"PyQGIS Standalone Application Example\" ) canvas . setCanvasColor ( Qt . white ) crs = QgsCoordinateReferenceSystem ( 'EPSG:3857' ) project = QgsProject . instance () canvas . setDestinationCrs ( crs ) urlWithParams = 'type=xyz&url=https://a.tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png&zmax=19&zmin=0&crs=EPSG3857' rlayer2 = QgsRasterLayer ( urlWithParams , 'OpenStreetMap' , 'wms' ) if rlayer2 . isValid (): project . addMapLayer ( rlayer2 ) else : print ( 'invalid layer' ) # Download shp ne_10m_admin_0_countries.shp and associated files in the same directory url = \"https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_admin_0_countries.zip\" if not glob ( \"ne_10m_admin_0_countries.*\" ): with urllib . request . urlopen ( url ) as response : with tempfile . NamedTemporaryFile ( delete = False ) as tmp_file : shutil . copyfileobj ( response , tmp_file ) with ZipFile ( tmp_file . name , 'r' ) as zipObj : # Extract all the contents of zip file in current directory zipObj . extractall () layer_shp = QgsVectorLayer ( os . path . join ( os . path . dirname ( __file__ ), \"ne_10m_admin_0_countries.shp\" ), \"Natural Earth\" , \"ogr\" ) if not layer_shp . isValid (): print ( \"Layer failed to load!\" ) project . addMapLayer ( layer_shp ) print ( layer_shp . crs () . authid ()) print ( rlayer2 . crs () . authid ()) canvas . setExtent ( layer_shp . extent ()) canvas . setLayers ([ rlayer2 , layer_shp ]) canvas . zoomToFullExtent () # canvas.freeze(True) canvas . show () canvas . refresh () # canvas.freeze(False) canvas . repaint () bridge = QgsLayerTreeMapCanvasBridge ( project . layerTreeRoot (), canvas ) def run_when_project_saved (): print ( 'Saved' ) project . projectSaved . connect ( run_when_project_saved ) project . write ( 'my_new_qgis_project.qgz' ) def run_when_application_state_changed ( state ): print ( 'State changed' , state ) app . applicationStateChanged . connect ( run_when_application_state_changed ) exitcode = app . exec () QgsApplication . exitQgis () sys . exit ( True )","title":"Application standalone"},{"location":"standalone/#librairie-qgis","text":"","title":"Librairie QGIS"},{"location":"standalone/#qgis-process","text":"Depuis QGIS 3.16, il existe un outil qgis_process qui permet de lancer QGIS Processing en ligne de commande. Dans le shell OSGEO, taper : 1 2 3 4 5 6 7 8 9 10 11 12 13 cd C: \\O SGeo4W \\a pps \\q gis-ltr \\b in \\ qgis_process ```` ` cd ` pour Change Directory. Il peut s 'agir d' un chemin diff\u00e9rent, comme ` C:/Program Files/QGIS 3 .14/bin/ ` On peut lancer les algorithmes, les mod\u00e8les, les scripts qui sont dans la version graphique de QGIS Processing. On peut donc lancer en ligne de commande, ou alors notre propre ic\u00f4ne sur son bureau un ex\u00e9cutable. ``` bash qgis_process run qgis:buffer -- INPUT = source.shp DISTANCE = 2 OUTPUT = buffered.shp qgis_process help qgis:buffer","title":"QGIS Process"},{"location":"standalone/#standalone-application","text":"Il est possible de faire un programme qui ne se lance pas dans QGIS Bureautique mais qui utilise la librairie QGIS qui se trouve sur l'ordinateur. On peut donc cr\u00e9er son propre programme, en ligne de commande ou avec une interface graphique qui utilise le moteur de QGIS en arri\u00e8re-plan pour utiliser ce que sait d\u00e9j\u00e0 faire QGIS. Exemple sur le gist de Thomas Gratier 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # Code borrowed from https://subscription.packtpub.com/book/application_development/9781783984985/1/ch01lvl1sec18/creating-a-standalone-application # and upgraded for QGIS 3.0 import os import sys import shutil import tempfile import urllib.request from zipfile import ZipFile from glob import glob from qgis.core import ( QgsApplication , QgsCoordinateReferenceSystem , QgsFeature , QgsGeometry , QgsProject , QgsRasterLayer , QgsVectorLayer ) from qgis.gui import QgsLayerTreeMapCanvasBridge , QgsMapCanvas from qgis.PyQt.QtCore import Qt # Unused so commented # from qgis.PyQt.QtGui import * app = QgsApplication ([], True ) # On Windows : https://gis.stackexchange.com/questions/334172/creating-standalone-application-in-qgis # On Linux, didn't need to set it so commented # app.setPrefixPath(\"C:/Program Files/QGIS Brighton/apps/qgis\", True) app . initQgis () canvas = QgsMapCanvas () canvas . setWindowTitle ( \"PyQGIS Standalone Application Example\" ) canvas . setCanvasColor ( Qt . white ) crs = QgsCoordinateReferenceSystem ( 'EPSG:3857' ) project = QgsProject . instance () canvas . setDestinationCrs ( crs ) urlWithParams = 'type=xyz&url=https://a.tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png&zmax=19&zmin=0&crs=EPSG3857' rlayer2 = QgsRasterLayer ( urlWithParams , 'OpenStreetMap' , 'wms' ) if rlayer2 . isValid (): project . addMapLayer ( rlayer2 ) else : print ( 'invalid layer' ) # Download shp ne_10m_admin_0_countries.shp and associated files in the same directory url = \"https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_admin_0_countries.zip\" if not glob ( \"ne_10m_admin_0_countries.*\" ): with urllib . request . urlopen ( url ) as response : with tempfile . NamedTemporaryFile ( delete = False ) as tmp_file : shutil . copyfileobj ( response , tmp_file ) with ZipFile ( tmp_file . name , 'r' ) as zipObj : # Extract all the contents of zip file in current directory zipObj . extractall () layer_shp = QgsVectorLayer ( os . path . join ( os . path . dirname ( __file__ ), \"ne_10m_admin_0_countries.shp\" ), \"Natural Earth\" , \"ogr\" ) if not layer_shp . isValid (): print ( \"Layer failed to load!\" ) project . addMapLayer ( layer_shp ) print ( layer_shp . crs () . authid ()) print ( rlayer2 . crs () . authid ()) canvas . setExtent ( layer_shp . extent ()) canvas . setLayers ([ rlayer2 , layer_shp ]) canvas . zoomToFullExtent () # canvas.freeze(True) canvas . show () canvas . refresh () # canvas.freeze(False) canvas . repaint () bridge = QgsLayerTreeMapCanvasBridge ( project . layerTreeRoot (), canvas ) def run_when_project_saved (): print ( 'Saved' ) project . projectSaved . connect ( run_when_project_saved ) project . write ( 'my_new_qgis_project.qgz' ) def run_when_application_state_changed ( state ): print ( 'State changed' , state ) app . applicationStateChanged . connect ( run_when_application_state_changed ) exitcode = app . exec () QgsApplication . exitQgis () sys . exit ( True )","title":"Standalone application"}]}