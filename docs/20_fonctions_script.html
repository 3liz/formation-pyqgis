
<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>Fonctions et scripts</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <link href="https://docs.3liz.org/remarkable.css" rel="stylesheet"/>
  <link href="logo.png" rel="icon" type="image/png" >
 </head>
 <body>
 <header class="header-container" style="">
    <h1>Fonctions et scripts</h1>
 </header>
 <article>
<p><a href="./">Index</a></p>

<div class="toc"><span class="toctitle">Table of content</span><ul>
<li><a href="#organisation-du-code-dans-un-script-avec-des-fonctions">Organisation du code dans un script avec des fonctions</a><ul>
<li><a href="#communication-avec-lutilisateur-des-erreurs-et-des-logs">Communication avec l'utilisateur des erreurs et des logs</a></li>
<li><a href="#charger-automatiquement-plusieurs-couches-a-laide-dun-script">Charger automatiquement plusieurs couches à l'aide d'un script</a></li>
<li><a href="#extraction-des-informations-sous-forme-dun-fichier-csv">Extraction des informations sous forme d'un fichier CSV.</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="organisation-du-code-dans-un-script-avec-des-fonctions">Organisation du code dans un script avec des fonctions</h1>
<h2 id="communication-avec-lutilisateur-des-erreurs-et-des-logs">Communication avec l'utilisateur des erreurs et des logs</h2>
<p>Avant de commencer à vraiment écrire un script avec des fonctions, regardons comment communiquer des 
informations à l'utilisateur.</p>
<p>On peut envoyer des messages vers l'utilisateur avec l'utilisation de la <code>messageBar</code> :</p>
<pre><code class="Python">iface.messageBar().pushMessage('Erreur','On peut afficher une erreur', Qgis.Critical)
iface.messageBar().pushMessage('Avertissement','ou un avertissement', Qgis.Warning)
iface.messageBar().pushMessage('Information','ou une information', Qgis.Info)
iface.messageBar().pushMessage('Succès','ou un succès', Qgis.Success)
</code></pre>

<p>On peut aussi écrire des logs comme ceci (plus discret, mais plus verbeux) :</p>
<pre><code class="Python">QgsMessageLog.logMessage('Une erreur est survenue','Notre outil', Qgis.Critical)
QgsMessageLog.logMessage('Un avertissement','Notre outil', Qgis.Warning)
QgsMessageLog.logMessage('Une information','Notre outil', Qgis.Info)
QgsMessageLog.logMessage('Un succès','Notre outil', Qgis.Success)
</code></pre>

<h2 id="charger-automatiquement-plusieurs-couches-a-laide-dun-script">Charger automatiquement plusieurs couches à l'aide d'un script</h2>
<p>La console c'est bien, mais c'est très limitant. Passons à l'écriture d'un script qui va nous faciliter 
l'organisation du code.</p>
<p>Voici le dernier script du fichier précédent, mais avec la gestion des erreurs :</p>
<ul>
<li>Redémarrer QGIS</li>
<li>N'ouvrez pas le projet précédent</li>
<li>Ouvrer la console, puis cliquer sur <code>Afficher l'éditeur</code></li>
<li>Copier/coller le script ci-dessous</li>
<li>Exécuter le</li>
</ul>
<pre><code class="python">from os.path import join, isfile, isdir
dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154'
thematique = 'H_OSM_ADMINISTRATIF'
couche = 'COMMUNE'

racine = QgsProject.instance().homePath()
if not racine:
    iface.messageBar().pushMessage('Erreur de chargement','Le projet n\'est pas enregistré', Qgis.Critical)
else:
    fichier_shape = join(racine, dossier, thematique, '{}.shp'.format(couche))
    if not isfile(fichier_shape):
        iface.messageBar().pushMessage('Erreur de chargement','Le chemin n\'existe pas: &quot;{}&quot;'.format(fichier_shape), Qgis.Critical)
    else:
        layer = QgsVectorLayer(fichier_shape, couche, 'ogr')
        if not layer.isValid():
            iface.messageBar().pushMessage('Erreur de chargement','La couche n\'est pas valide', Qgis.Critical)
        else:
            QgsProject.instance().addMapLayer(layer)
            iface.messageBar().pushMessage('Bravo','Well done!', Qgis.Success)

</code></pre>

<ul>
<li>À l'aide du mémo Python :<ul>
<li>Essayons de faire une fonction qui prend 2 paramètres<ul>
<li>la thématique (le dossier)</li>
<li>le nom du shapefile</li>
</ul>
</li>
<li>La fonction se chargera de faire le nécessaire, par exemple: <code>charger_couche('H_OSM_ADMINISTRATIF', 'COMMUNE')</code></li>
<li>La fonction peut également retourner <code>False</code> si la couche n'est pas chargée (une erreur) ou sinon l'objet couche.</li>
</ul>
</li>
</ul>
<pre><code class="python">def charger_couche(thematique, couche):
    pass
</code></pre>

<ul>
<li>Une des solutions :</li>
</ul>
<pre><code class="python">from os.path import join, isfile, isdir

def charger_couche(thematique, couche):
    &quot;&quot;&quot;Fonction qui charge une couche shapefile dans une thématique.&quot;&quot;&quot;
    dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154'

    racine = QgsProject.instance().homePath()
    if not racine:
        iface.messageBar().pushMessage('Erreur de chargement','Le projet n\'est pas enregistré', Qgis.Critical)
        return False

    fichier_shape = join(racine, dossier, thematique, '{}.shp'.format(couche))
    if not isfile(fichier_shape):
        iface.messageBar().pushMessage('Erreur de chargement','Le chemin n\'existe pas: &quot;{}&quot;'.format(fichier_shape), Qgis.Critical)
        return False

    layer = QgsVectorLayer(fichier_shape, shapefile, 'ogr')
    if not layer.isValid():
        iface.messageBar().pushMessage('Erreur de chargement','La couche n\'est pas valide', Qgis.Critical)
        return False

    QgsProject.instance().addMapLayer(layer)
    iface.messageBar().pushMessage('Bravo','Well done!', Qgis.Success)
    return layer

charger_couche('H_OSM_ADMINISTRATIF', 'COMMUNE')
charger_couche('H_OSM_ADMINISTRATIF', 'ARRONDISSEMENT')
</code></pre>

<ul>
<li>Essayons de faire une fonction qui liste les shapefiles d'une certaine thématique. <code>os.walk(path)</code> permet de parcourir un chemin.</li>
</ul>
<pre><code class="python">import os

def liste_shapefiles(thematique):
    &quot;&quot;&quot;Liste les shapefiles d'une thématique.&quot;&quot;&quot;
    dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154'
    racine = QgsProject.instance().homePath()
    shapes = []
    for root, directories, files in os.walk(os.path.join(racine, dossier, thematique)):
        for file in files:
            if file.lower().endswith('.shp'):
                shapes.append(file.replace('.shp', ''))
    return shapes

shapes = liste_shapefiles('H_OSM_ADMINISTRATIF')
print(shapes)
</code></pre>

<ul>
<li>Permettre le chargement automatique de toute un thématique.</li>
</ul>
<h2 id="extraction-des-informations-sous-forme-dun-fichier-csv">Extraction des informations sous forme d'un fichier CSV.</h2>
<p>On souhaite désormais réaliser une fonction d'export des métadonnées de nos couches au format CSV, avec son
CSVT.
Il existe déjà un module CSV dans Python pour nous aider à écrire un fichier de type CSV, mais nous n'allons
pas l'utiliser.
Nous allons plutôt utiliser l'API QGIS pour créer une nouvelle couche en mémoire comportant les différentes
informations que l'on souhaite exporter.
Puis nous allons utiliser l'API pour exporter cette couche mémoire au format CSV (l'équivalent dans QGIS de
l'action <code>Exporter la couche</code>).</p>
<p>Les différents champs qui devront être exportés sont :</p>
<ul>
<li>son nom</li>
<li>son type de géométrie (format humain, lisible)</li>
<li>la projection</li>
<li>le nombre d'entité</li>
<li>l'encodage</li>
<li>si le seuil de visibilité est activé</li>
<li>la source (le chemin) de la donnée</li>
</ul>
<p>Exemple de sortie : </p>
<table>
<thead>
<tr>
<th>nom</th>
<th>type</th>
<th>projection</th>
<th>nombre_entite</th>
<th>encodage</th>
<th>source</th>
<th>seuil_de_visibilite</th>
</tr>
</thead>
<tbody>
<tr>
<td>couche_1</td>
<td>Line</td>
<td>EPSG:4326</td>
<td>5</td>
<td>UTF-8</td>
<td>/tmp/...geojson</td>
<td>False</td>
</tr>
<tr>
<td>couche_2</td>
<td>Point</td>
<td>No geometry</td>
<td>0</td>
<td></td>
<td>/tmp/...shp</td>
<td>True</td>
</tr>
</tbody>
</table>
<p>Pour créer une couche tabulaire en mémoire :</p>
<pre><code class="python">layer_info = QgsVectorLayer('None', 'info', 'memory')
</code></pre>

<p>La liste des couches :</p>
<pre><code class="python">layers = QgsProject.instance().mapLayers()
</code></pre>

<p>Nous allons avoir besoin de plusieurs classes dans l'API QGIS : </p>
<ul>
<li>Enregistrer un fichier : la classe <code>QgsVectorFileWriter</code></li>
<li>Un champ : <code>QgsField</code></li>
<li>Une entité : <code>QgsFeature</code></li>
</ul>
<p>Il va y avoir plusieurs étapes dans ce script :</p>
<ol>
<li>Créer une couche en mémoire</li>
<li>Ajouter des champs à cette couche en utilisant une session d'édition</li>
<li>Récupérer la liste des couches présentes dans la légende</li>
<li>Itérer sur les couches pour ajouter ligne par ligne les métadonnées dans une session d'édition</li>
<li>Enregistrer en CSV la couche mémoire</li>
</ol>
<p>Solution :</p>
<pre><code class="python">from os.path import join

layers = QgsProject.instance().mapLayers()
if not layers:
    iface.messageBar().pushMessage('Pas de couche','Attention, il n\'a pas de couche', Qgis.Warning)

layers = [layer for layer in layers.values()]

layer_info = QgsVectorLayer('None', 'info', 'memory')

fields = []
fields.append(QgsField('nom', QVariant.String))
fields.append(QgsField('type', QVariant.String))
fields.append(QgsField('projection', QVariant.String))
fields.append(QgsField('nombre_entite', QVariant.Int))
fields.append(QgsField('encodage', QVariant.String))
fields.append(QgsField('source', QVariant.String))
fields.append(QgsField('seuil_de_visibilite', QVariant.String))

with edit(layer_info):
    for field in fields:
        layer_info.addAttribute(field)

QgsProject.instance().addMapLayer(layer_info)

with edit(layer_info):
    for layer in layers:
        feature = QgsFeature()
        attributes = [
            layer.name(),
            QgsWkbTypes.geometryDisplayString(layer.geometryType()),
            layer.crs().authid(),
            layer.featureCount(),
            layer.dataProvider().encoding(),
            layer.source(),
            str(layer.hasScaleBasedVisibility())
        ]
        feature.setAttributes(attributes)
        layer_info.addFeature(feature)

QgsVectorFileWriter.writeAsVectorFormat(
    layer_info,
    join(QgsProject.instance().homePath(), 'test.csv'),
    'utf-8',
    QgsCoordinateReferenceSystem(),
    'CSV',
    layerOptions=['CREATE_CSVT=YES']
)

# Afficher une messageBar pour confirmer que c'est OK, en vert ;-)

</code></pre>
<p><a href="./">Index</a></p>

  </article>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
