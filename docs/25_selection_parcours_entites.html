
<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>Sélections, fonctions</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <link href="https://docs.3liz.org/remarkable.css" rel="stylesheet"/>
  <link href="logo.png" rel="icon" type="image/png" >
 </head>
 <body>
 <header class="header-container" style="">
    <h1>Sélections, fonctions</h1>
 </header>
 <article>
<p><a href="./">Index</a></p>

<div class="toc"><span class="toctitle">Table of content</span><ul>
<li><a href="#boucler-sur-les-entites-dune-couche-sans-expression">Boucler sur les entités d'une couche sans expression</a></li>
<li><a href="#utilisation-des-expressions-qgis">Utilisation des expressions QGIS</a><ul>
<li><a href="#selection-dentite">Sélection d'entité</a></li>
<li><a href="#boucler-sur-les-entites-a-laide-dune-expression">Boucler sur les entités à l'aide d'une expression</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="boucler-sur-les-entites-dune-couche-sans-expression">Boucler sur les entités d'une couche sans expression</h1>
<p>On peut parcourir les entités d'une couche <code>QgsVectorLayer</code> à l'aide de <code>getFeatures()</code> :</p>
<pre><code class="python">layer = iface.activeLayer()
for feature in layer.getFeatures():
    print(feature)
    print(feature['NOM'])
</code></pre>

<h1 id="utilisation-des-expressions-qgis">Utilisation des expressions QGIS</h1>
<ul>
<li>Les expressions sont très présentes dans QGIS, tant dans l'interface graphique que dans l'utilisation en
  Python.</li>
<li>Nous partons de la couche des <code>COMMUNES</code> uniquement chargé dans QGIS.</li>
</ul>
<h2 id="selection-dentite">Sélection d'entité</h2>
<p>Nous souhaitons sélectionner les entités dont le code INSEE commence par <code>77</code>.
Commençons par faire cela graphiquement dans QGIS Desktop. À l'aide d'une expression QGIS, sélectionner
les codes INSEE qui commencent par <code>77</code>.</p>
<p><img alt="Sélectionner par expression" src="./media/console_editeur.png"></p>
<p>Nous allons faire la même chose, mais en utilisant Python. Pensez à désélectionner les entités.</p>
<pre><code class="python">layer = iface.activeLayer()
layer.removeSelection()
layer.selectByExpression(&quot;\&quot;CODE_INSEE\&quot; LIKE '{}%'&quot;.format(77))
layer.invertSelection()
layer.removeSelection()
</code></pre>

<h2 id="boucler-sur-les-entites-a-laide-dune-expression">Boucler sur les entités à l'aide d'une expression</h2>
<p>L'objectif est d'afficher dans la console le nom des communes dont la population ne contient pas <code>NC</code>.</p>
<p>L'exemple à <strong>ne pas</strong> faire, même si cela fonctionne :</p>
<pre><code class="python">layer = iface.activeLayer()
for feature in layer.getFeatures():
    if feature['POPUL'] != 'NC':
        print(feature['NOM'])
</code></pre>

<p>Observez bien la signature de la fonction <code>getFeatures</code>. Que remarquez-vous ?
Utilisons donc une expression pour limiter les résultats.</p>
<pre><code class="python">request = QgsFeatureRequest('&quot;POPUL&quot; != \'NC\'')
for feature in layer.getFeatures(request):
    print('{commune} : {nombre} habitants pour'.format(commune=feature['NOM'], nombre=feature['POPUL']))
</code></pre>

<p>Nous pouvons encore optimiser la requête et accessoirement ordonner les résultats :</p>
<pre><code class="python">request = QgsFeatureRequest()
request.setFilterExpression('&quot;POPUL&quot; != \'NC\'')
request.addOrderBy('NOM')
request.setFlags(QgsFeatureRequest.NoGeometry)
request.setSubsetOfAttributes([1, 4])
for feature in layer.getFeatures(request):
    print('{commune} : {nombre} habitants'.format(commune=feature['NOM'], nombre=feature['POPUL']))
</code></pre>

<p>Faire le test en affichant un champ qui n'est pas dans la requête.</p>
<p>Rajoutons une intersection spatiale avec l'emprise suivante :</p>
<pre><code class="python">request.setFilterRect(QgsRectangle(662737,6807733,717144,6853979))
</code></pre>

<p>Mettons ce résultat dans une nouvelle couche :</p>
<pre><code class="python">memory_layer = layer.materialize(request)
QgsProject.instance().addMapLayer(memory_layer)
</code></pre>

<p>Corrigeons ce problème d'export afin d'obtenir les géométries et les attributs :</p>
<pre><code class="python">request.setFlags(QgsFeatureRequest.NoFlags)
</code></pre>

<p>Avant-dernier exercice, afficher une liste des communes dont la population est inférieur
à 1000 habitants en incluant la densité de population.</p>
<pre><code class="python">layer = iface.activeLayer()
request = QgsFeatureRequest()
request.setFilterExpression('to_int( &quot;POPUL&quot; ) &lt; 1000')
request.addOrderBy('NOM')
request.setSubsetOfAttributes([1, 4])
for feature in layer.getFeatures(request):
    area = feature.geometry().area() / 1000000
    try:
        population = int(feature['POPUL'])
    except ValueError:
        population = 0
    print('{commune} : {densite} habitants/km²'.format(commune=feature['NOM'], densite=population/area))
</code></pre>

<p>Nous souhaitons enregistrer ces informations dans une vraie table avec un nouveau champ <code>densite_population</code>.</p>
<pre><code class="python">layer = iface.activeLayer()

request = QgsFeatureRequest()
request.setFilterExpression('to_int( &quot;POPUL&quot; ) &lt; 1000')
petites_communes = layer.materialize(request)

with edit(petites_communes):
    field = QgsField('densite_population', QVariant.Double)
    petites_communes.addAttribute(field)

request = QgsFeatureRequest()
request.setSubsetOfAttributes([4])
with edit(petites_communes):
    for feature in petites_communes.getFeatures(request):
        area = feature.geometry().area() / 1000000
        population = int(feature['POPUL'])
        densite=population/area
        petites_communes.changeAttributeValue(feature.id(), 5, densite)

QgsProject.instance().addMapLayer(petites_communes)
</code></pre>

<p>Manipulons désormais la géométrie en ajoutant le centroïde de la commune dans une colonne <code>latitude</code> et
<code>longitude</code> en degrées.</p>
<pre><code class="python">layer = iface.activeLayer()

request = QgsFeatureRequest()
request.setFilterExpression('to_int( &quot;POPUL&quot; ) &lt; 1000')
petites_communes = layer.materialize(request)

with edit(petites_communes):
    petites_communes.addAttribute(QgsField('densite_population', QVariant.Double))

    # /!\ Ajouter les 2 lignes ci-dessous
    petites_communes.addAttribute(QgsField('longitude', QVariant.Double))
    petites_communes.addAttribute(QgsField('latitude', QVariant.Double))

request = QgsFeatureRequest()
request.setSubsetOfAttributes([4])

# /!\ Ajouter les 2 lignes ci-dessous à propos de la transformation
transform = QgsCoordinateTransform(
    QgsCoordinateReferenceSystem(2154), QgsCoordinateReferenceSystem(4326), QgsProject.instance())

with edit(petites_communes):
    for feature in petites_communes.getFeatures(request):
        area = feature.geometry().area() / 1000000
        population = int(feature['POPUL'])
        densite=population/area
        petites_communes.changeAttributeValue(feature.id(), 5, densite)

        # /!\ Ajouter les lignes ci-dessous
        geom = feature.geometry()
        geom.transform(transform)
        centroid = geom.centroid().asPoint()
        petites_communes.changeAttributeValue(feature.id(), 6, centroid.x())
        petites_communes.changeAttributeValue(feature.id(), 7, centroid.y())

QgsProject.instance().addMapLayer(petites_communes)
</code></pre>
<p><a href="./">Index</a></p>

  </article>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
