
<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>Console Python</title>
  <link type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <link type="text/css" href="https://docs.3liz.org/remarkable.css" rel="stylesheet"/>
  <link type="image/png" href="logo.png" rel="icon" >
 </head>
 <body>
 <header class="header-container" style="">
    <h1>Console Python</h1>
 </header>
 <article>
<div class="toc"><span class="toctitle">Table of content</span><ul>
<li><a href="#introduction-a-la-console-python-dans-qgis">Introduction à la console Python dans QGIS</a><ul>
<li><a href="#la-documentation-et-les-liens-utiles">La documentation et les liens utiles :</a></li>
<li><a href="#configurer-le-projet">Configurer le projet</a></li>
<li><a href="#manipulation-dans-la-console">Manipulation dans la console</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#parcourir-les-entites">Parcourir les entités</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="introduction-a-la-console-python-dans-qgis">Introduction à la console Python dans QGIS</h1>
<h2 id="la-documentation-et-les-liens-utiles">La documentation et les liens utiles :</h2>
<ul>
<li>QGIS est composé de plusieurs centaines de classes écrites en C++. 
La plupart de ces classes (et donc des fonctions) sont accessibles à travers un API en Python. 
Comme il n'est pas possible de mémoriser entièrement l'API de QGIS, il est nécessaire de connaître la 
documentation et comment rechercher des informations.</li>
<li>QGIS repose sur la librairie Qt version 5 pour l'interface graphique et sur Python version 3.</li>
<li>Toutes les classes QGIS commencent par <code>Qgs</code> et toutes les classes Qt commencent par <code>Q</code>.</li>
</ul>
<p>Voici une liste de liens pour la documentation:</p>
<ul>
<li><a href="https://docs.qgis.org">https://docs.qgis.org</a> qui regroupe:<ul>
<li><a href="https://docs.qgis.org/3.4/en/docs/pyqgis_developer_cookbook/">Le Python Cookbook https://docs.qgis.org/3.4/en/docs/pyqgis_developer_cookbook</a> (recette de cuisine)</li>
<li><a href="https://qgis.org/api/3.4/">L'API C++ https://qgis.org/api/3.4/</a></li>
<li><a href="https://qgis.org/pyqgis/3.4/">L'API Python https://qgis.org/pyqgis/3.4/</a></li>
</ul>
</li>
</ul>
<p>Voici une liste non exhaustive de blog-post utiles pour manipuler PyQGIS:</p>
<ul>
<li><a href="https://nyalldawson.net/2016/10/speeding-up-your-pyqgis-scripts/">Optimisation des couches vecteurs</a></li>
<li><a href="https://www.lutraconsulting.co.uk/blog/2014/07/06/qgis-layer-tree-api-part-1/">Parcourir la légende en 3 parties</a></li>
<li><a href="http://www.qgistutorials.com/en/docs/3/processing_python_plugin.html">Plugin Processing</a></li>
<li><a href="https://madmanwoo.gitlab.io/foss4g-python-workshop/">Workshop sur les expressions en Python</a></li>
</ul>
<p>Autre lien pour l'apprentissage de Python (sans QGIS):
* <a href="https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python">https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python</a></p>
<h2 id="configurer-le-projet">Configurer le projet</h2>
<ul>
<li>Commencer un nouveau projet et enregistrer le.</li>
<li>À côté du projet, ajouter le dossier provenant d’OSM2Igeo, par exemple <code>201909_11_ILE_DE_FRANCE_SHP_L93_2154</code>.</li>
</ul>
<h2 id="manipulation-dans-la-console">Manipulation dans la console</h2>
<ul>
<li>Dans QGIS, <code>Plugins</code> -&gt; <code>Console Python</code></li>
<li>
<p>QGIS nous donne accès au projet actuel via la classe <code>QgsProject</code></p>
<ul>
<li><a href="https://qgis.org/api/classQgsProject.html">https://qgis.org/api/classQgsProject.html</a></li>
<li><a href="https://qgis.org/pyqgis/3.4/core/QgsProject.html">https://qgis.org/pyqgis/3.4/core/QgsProject.html</a></li>
</ul>
</li>
<li>
<p>Dans la documentation (en C++ surtout), on remarque plusieurs sections:</p>
<ul>
<li>Public types</li>
<li>Public slots</li>
<li>Signals</li>
<li>Public Member Functions</li>
<li>Static Public Member Functions</li>
</ul>
</li>
<li>Nous verrons progressivement ces différentes sections.</li>
<li>Recherchons <code>filename</code>.</li>
</ul>
<pre><code class="python">QgsProject.instance().fileName()
</code></pre>

<ul>
<li>Ajoutons un titre à notre projet, recherchons donc <code>title</code> dans la page : <code>setTitle</code>.</li>
<li>Objectif, ajouter une couche vecteur contenu dans un dossier fils :<ul>
<li>Recherchons dans l'API le dossier racine du projet. <em>Indice</em>, en informatique, on appelle souvent cela le <code>home</code>.</li>
<li>Nous allons utiliser le module <code>os.path</code> pour manipuler les dossiers.</li>
<li><a href="https://docs.python.org/3/library/os.path.html">https://docs.python.org/3/library/os.path.html</a></li>
<li><code>join</code>, <code>isfile</code>, <code>isdir</code></li>
</ul>
</li>
</ul>
<pre><code class="python">from os.path import join, isfile, isdir
racine = QgsProject.instance().homePath()
join(racine, 'nexistepas')
'/home/etienne/Documents/3liz/formation/nexistepas'
isfile(join(racine,'nexistepas'))
False
isdir(join(racine,'nexistepas'))
False
chemin = join(racine, '201909_11_ILE_DE_FRANCE_SHP_L93_2154', 'H_OSM_ADMINISTRATIF')
fichier_shape = join(chemin, 'COMMUNE.shp')
isfile(fichier_shape)
True
</code></pre>

<ul>
<li>Charger la couche vecteur à l'aide de <code>iface</code> <a href="https://qgis.org/api/classQgisInterface.html">QgisInterface</a>
  (et non pas <strong>Qgs</strong>Interface!)</li>
</ul>
<pre><code class="python">communes = iface.addVectorLayer(fichier_shape, 'communes', 'ogr')
print(communes)
</code></pre>

<ul>
<li>Charger la couche autrement (conseillé)</li>
</ul>
<pre><code class="python">communes = QgsVectorLayer(fichier_shape, 'communes', 'ogr')
communes.isValid()
QgsProject.instance().addMapLayer(communes)
</code></pre>

<ul>
<li>Explorer l'objet <code>communes</code> qui est un <code>QgsVectorLayer</code> à l'aide de la documentation pour chercher sa
  géométrie, le nombre d'entité.</li>
<li>Pour la géométrie, toujours utiliser l'énumération et non pas le chiffre (explication dans l'exemple
  ci-dessous)</li>
<li>Essayer d'ouvrir et de clore une session d'édition</li>
<li>Essayer désormais de chercher son nom, la projection ou encore les seuils de visibilité de la couche.
On ne les trouve pas dans la page <code>QgsVectorLayer</code> !
Pour cela, il faut faire référence à la notion d'héritage en Programmation Orientée Objet.
L'objet <code>QgsVectorLayer</code> hérite de <code>QgsMapLayer</code> qui est une classe commune avec <code>QgsMapLayer</code>.</li>
<li>Objectif, ne pas afficher la couche commune pour une échelle plus petite que le <code>1:2 000 000</code>.</li>
</ul>
<h2 id="code">Code</h2>
<p>Petit récapitulatif à tester pour voir si cela fonctionne correctement !</p>
<pre><code class="python">from os.path import join, isfile, isdir
dossier = '201909_11_ILE_DE_FRANCE_SHP_L93_2154'
thematique = 'H_OSM_ADMINISTRATIF'
couche = 'COMMUNE'

racine = QgsProject.instance().homePath()
fichier_shape = join(racine, dossier, thematique, '{}.shp'.format(couche))
layer = QgsVectorLayer(fichier_shape, couche, 'ogr')
result = QgsProject.instance().addMapLayer(layer)

print(layer.featureCount())
print(layer.crs().authid())
print('Est en mètre : {}'.format(layer.crs().mapUnits() ==  QgsUnitTypes.DistanceMeters))
print(layer.name())
layer.setScaleBasedVisibility(True)
layer.setMaximumScale(1)
layer.setMinimumScale(2000000)
layer.triggerRepaint()
</code></pre>

<ul>
<li>Ajouter également la couche <code>ARRONDISSEMENT</code> et sélectionner la.</li>
</ul>
<h2 id="parcourir-les-entites">Parcourir les entités</h2>
<p>Un raccourci a savoir, dans la console:</p>
<pre><code class="python">iface.activeLayer()
</code></pre>

<p>retourne la couche <code>QgsMapLayer</code> active dans la légende !</p>
<p>On souhaite désormais itérer sur les polygones et les faire clignoter depuis la console.
Nous allons donc avoir besoin de <code>getFeatures</code>.</p>
<pre><code class="python">layer = iface.activeLayer()
features = layer.getFeatures()
features
feature = QgsFeature()
features.nextFeature(feature)
iface.mapCanvas().flashFeatureIds(layer, [feature.id()])
</code></pre>

<p><em>Note</em>, nous pouvons concaténer les deux dernières lignes à l'aide du caractère <code>;</code> pour que cela soit plus
pratique.</p>
<p>On souhaite désormais afficher le nom des arrondissements à l'aide d'une boucle <code>for</code>.</p>
<pre><code class="python">layer = iface.activeLayer()
for feature in layer.getFeatures():
    # On peut traiter l'entité courante.    
</code></pre>

<p>Noter l'apparition de <code>...</code> au lieu de <code>&gt;&gt;&gt;</code> après avoir écrit la première ligne du <code>for</code>.
Il faut faire une indentation obligatoire !</p>
<p><a href="./readme.html">Retour</a></p>
  </article>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
